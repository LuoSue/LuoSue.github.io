{"meta":{"title":"LuoSue's Blog","subtitle":null,"description":"闲话苑","author":"LuoSue","url":"https://fallensue.cc"},"pages":[{"title":"books","date":"2020-10-27T06:39:26.000Z","updated":"2020-10-27T06:39:26.405Z","comments":true,"path":"books/index.html","permalink":"https://fallensue.cc/books/index.html","excerpt":"","text":""},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-11-07T10:37:48.955Z","comments":false,"path":"about/index.html","permalink":"https://fallensue.cc/about/index.html","excerpt":"","text":"[天意城のLuoSue] 与&nbsp; LuoSue&nbsp; （ 茄子 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-11-02T13:59:35.060Z","comments":false,"path":"lab/index.html","permalink":"https://fallensue.cc/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-11-02T13:58:00.756Z","comments":true,"path":"comment/index.html","permalink":"https://fallensue.cc/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"movies","date":"2020-10-27T06:39:40.000Z","updated":"2020-10-27T06:39:40.381Z","comments":true,"path":"movies/index.html","permalink":"https://fallensue.cc/movies/index.html","excerpt":"","text":""},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-11-02T13:59:23.206Z","comments":false,"path":"donate/index.html","permalink":"https://fallensue.cc/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"artitalk","date":"2020-11-08T14:16:01.000Z","updated":"2020-11-15T08:34:36.071Z","comments":false,"path":"artitalk/index.html","permalink":"https://fallensue.cc/artitalk/index.html","excerpt":"","text":"var img= “https://cdn.jsdelivr.net/gh/LuoSue/cdn/img/custom/avatar.jpg&quot;; var appID= ‘cJsUVOg7I9utk9hiYW4IU7KB-MdYXbMMI’; var appKEY= ‘mzyqLMOSjeVwxY0D09qW8O8z’; var per= “10”; var username= “luosue”; L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/shizuku.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"log\":false});"},{"title":"photos","date":"2020-10-27T06:39:05.000Z","updated":"2020-10-27T06:39:05.034Z","comments":true,"path":"photos/index.html","permalink":"https://fallensue.cc/photos/index.html","excerpt":"","text":""},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://fallensue.cc/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"https://fallensue.cc/tags/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-11-08T04:17:33.609Z","comments":false,"path":"music/index.html","permalink":"https://fallensue.cc/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-11-02T13:59:56.452Z","comments":true,"path":"links/index.html","permalink":"https://fallensue.cc/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"https://fallensue.cc/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://fallensue.cc/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-11-02T13:57:46.174Z","comments":false,"path":"client/index.html","permalink":"https://fallensue.cc/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"https://fallensue.cc/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"OS虚拟内存管理","slug":"OS虚拟内存管理","date":"2020-11-18T07:33:01.000Z","updated":"2020-11-18T07:38:20.209Z","comments":true,"path":"posts/8c7e9ffb.html","link":"","permalink":"https://fallensue.cc/posts/8c7e9ffb.html","excerpt":"","text":"OS虚拟内存管理背景将整个程序置于内存中，其实不是必要的： 程序处理异常错误条件的代码几乎不怎么执行 数组、链表、表所分配的内存量多于实际的值 程序的某些功能和选项几乎不用 即使在需要整个程序的情况下， 也可能并不同时需要整个程序，分段能够执行只有部分处于内存的程序，可以带来许多好处。 程序不再受物理内存的可用量所限制，用户能够给一个巨大的虚拟地址空间编写程序，简化了编程的任务。 由于每个程序占用较少的物理内存，可以同时运行更多的程序，增加了CPU的利用率以及吞吐量，但没有增加响应时间或者周转时间。 由于加载或交换每个用户程序到内存所需的I/O会更少， 用户程序会运行得更快。因此， 运行不完全处于内存的程序将使系统和用户都受益。 虚拟内存将用户逻辑与物理内存分开。进程的虚拟地址空间就是进程如何在内存中存放的逻辑视图。 除了将逻辑内存与物理内存分开外，虚拟内存允许文件和内存通过共享页而为多个进程所共享。这带来了以下好处： 通过将共享对象映射到虚拟地址空间中， 系统库可以为多个进程所共享。 类似地， 虚拟内存允许进程共享内存。 当通过系统调用fork()创建进程时， 可以共享页面， 从而加快进程创建。 请求调页如何从磁盘加载可执行程序到内存？一种选择是，在程序执行时将整个程序加载到物理内存。(但是这种方法的一个问题是，最初可能不需要整个程序都处于内存) 另一种策略是，仅在需要时才加载页面。这种技术被称作请求调页，常常用于虚拟内存系统。不过， 不是将整个进程交换到内存中， 而是采用惰性交换器(lazy swapper), 惰性交换器除非需要某个页面， 否则从不将它交换到内存中。 基本概念调页程序不是调入整个进程， 而是把那些要使用的页调入内存。这样， 调页程序就避免了读入那些不使用的页， 也减少了交换时间和所需的物理内存空间。 使用这种方案需要一定形式的硬件支持， 以区分内存的页面和磁盘的页面。 请注意， 如果进程从不试图访问标记为无效的页面， 那么并没有什么影响。因此， 如果猜测正确并且只调入所有实际需要的页面， 那么进程就如同所有页面都已调入内存一样正常运行。当进程执行和访问那些内存驻留(memory resident)的页面时，执行会正常进行。 对标记为无效的页面访问会产生缺页错误(page fault)。分页硬件在通过页表转换地址时会注意到无效位被设置， 从而陷入操作系统。这种陷阱是由于操作系统未能将所需的页面调入内存引起的。 纯请求调页：当操作系统将指令指针设置为进程的第一条指令时， 由于它所在的页面并不在内存中， 进程立即出现缺页错误。当该页面调入内存后， 进程继续执行；根据需要发生缺页错误， 直到所需每个页面都在内存中。这时， 它可以在没有更多缺页错误的情况下执行。 程序具有局部引用，这使得请求调页具有较为合理的性能。 请求调页的性能请求调页可以显著影响计算机系统的性能。为了说明起见， 下面计一下请求调页内存的有效访问时间。 设p为缺页错误的概率(0&lt;=p&lt;=1) 。希望p接近于0, 即缺页错误很少。那么有效访问时间为：有效访问时间＝（1-p) x ma+ p x缺页错误时间。 总之， 对于请求调页， 降低缺页错误率是极为重要的。否则， 会增加有效访问时间， 从而极大地减缓了进程的执行速度。请求调页的另一个方面是交换空间的处理和整体使用。 写时复制它通过允许父进程和子进程最初共享相同的页面来工作。这些共享页面标记为写时复制， 这意味着如果任何一个进程写入共享页面， 那么就创建共享页面的副本。 显然， 当使用写时复制技术时， 仅复制任何一进程修改的页面， 所有未修改的页面可以由父进程和子进程共享。还要注意， 只有可以修改的页面才需要标记为写时复制。不能修改的页面（包含可执行代码的页面）可以由父进程和子进程共享。 页面置换基本页面置换页面置换采用以下方法。如果没有空闲帧， 那么就查找当前不在使用的一个帧， 并释放它。可以这样来释放一个帧：将其内容写到交换空间， 并修改页表（和所有其他表）， 以表示该页不在内存中。现在可使用空闲帧， 来保存进程出错的页面。 采用修改位(modify bit)（或脏位(dirty bit）） 可减少这种开销。当采用这种方案时， 每个页面或帧都有一个修改位， 两者之间的关联采用硬件。当要选择一个页面进行置换时， 就检查它的修改位。如果该位已被设置， 那么该页面从磁盘读入以后已被修改。 页面置换是请求调页的基础。它完成了逻辑内存和物理内存之间的分离。采用这种机制， 较小的物理内存能为程序员提供巨大的虚拟内存。 为实现请求调页， 必须解决两个主要问题：应设计帧分配算法和页面置换算法。 FIFO页面置换最简单的页面置换算法是FIFO算法。FIFO页面置换算法为每个页面记录了调到内存的时间。当必须置换页面时， 将选择最旧的页面。请注意， 并不需要记录调入页面的确切时间。可以创建一个FIFO队列， 来管理所有的内存页面。置换的是队列的首个页面。当需要调入页面到内存时， 就将它加到队列的尾部。 FIFO页面置换算法易于理解和编程。然而， 它的性能并不总是十分理想。一方面， 所置换的页面可以是很久以前使用过但现已不再使用的初始化模块。另一方面， 所置换的页面可以包含一个被大量使用的变量，它早就初始化了， 但仍在不断使用。 采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。这个最意想不到的结果被称为Belady异常。 最优页面置换(OPT或者MIN)具有所有算法最低的缺页错误率，并且不会遭受Belady异常，简单地说就是置换最长时间不会使用的页面。 但是，最优置换算法难以实现，因为它需要引用串的未来知识，所以主要用于比较研究。 LRU页面置换置换最长时间没有使用的页，这种方法被称为最近最少使用算法。 LRU置换将每个页面与它的上次使用的时间关联起来，这种策略可当作在时间上向后看而不是向前看的最优页面置换算法。 如何实现LRU呢？主要问题是确定由上次使用时间定义的帧的顺序。 计数器：在最简单的情况下，为每个页表条目关联一个使用时间域，并为CPU 添加一个逻辑时钟或计数器。这种方案需要搜索页表以查找LRU 页面，而且每次内存访问都要写到内存（到页表的使用时间域）。当页表更改时（由于CPU 调度）， 还必须保留时间。时钟溢出也要考虑。 堆栈：采用页码堆栈，每当页面被引用是，他就从堆栈中移除并放在顶部。这样，最近使用的页面总是在栈的顶部，最近最少使用的页面总是在底部。 这个置换同样没有Belady异常。 近似LRU页面置换很少有计算机系统能够提供足够的硬件来支持真正的LRU页面置换算法。许多系统都通过引用位的形式提供一定的支持。 最初， 所有引用位由操作系统清零（至0)。当用户进程执行时， 每个引用到的页面引用位由硬件设置（至1）。一段时间后， 我们可以通过检查引用位来确定哪些页面已被使用，哪些页面尚未使用， 虽说我们不知道使用的顺序。 额外引用位算法通过定期记录引用位，我们可以获得额外的排序信息。可以为内存中发的页表的每个页面保留一个8位的字节。在极端情况下， 位数可降为0, 即只有引用位本身。这种算法称为第二次机会页面置换算法。 第二次机会算法第二次机会置换的基本算法是一种FIFO置换算法。然而， 当选择了一个页面时， 需要检查其引用位。如果值为0, 那么就直接置换此页面；如果引用位设置为1，那么就给此页面第二次机会， 并继续选择下一个FIFO页面。 实现第二次机会算法（有时称为时钟算法(clock algorithm)) 的一种方式是采用循环队列。指针（即时钟指针）指示接下来要置换哪个页面。当需要一个帧时， 指针向前移动直到找到一个引用位为0的页面。在向前移动时， 它会清除引用位。一旦找到牺牲页面， 就置换该页面， 并且在循环队列的这个位置上插入新页面。注意， 在最坏的情况下，当所有位都巳设置， 指针会循环遍历整个队列， 给每个页面第二次机会。在选择下一个页面进行置换之前， 它将清除所有引用位。 如果所有位都为1，第二次机会置换退化为FIFO置换。 增强型第二次机会算法通过将引用位和修改位作为有序对， 可以改进二次机会算法。有了这两个位， 就有下面四种可能的类型： (0,0) 最近没有使用且没有修改的页面，最佳的页面置换。 (0,1) 最近没有使用但修改过的页面，不太好的置换，因为在置换前需要将页面写出。 (1,0) 最近使用过但没有修改的页面，可能很快再次使用。 (1,1) 最近使用过且修改过，可能很快再次使用，并且在置换前需要将页面写出到磁盘。 这种算法与更为简单的时钟算法的主要区别在于：这里为那些已修改页面赋予更高级别， 从而降低了所需I/O数量。 基于计数的页面置换页面置换还有许多其他算法。例如， 可以为每个页面的引用次数保存一个计数器， 并且开发以下两个方案。 最不经常使用(LFU) 最经常使用(MFU) 页面缓冲算法除了特定页面置换算法之外， 还经常采用其他措施。例如， 系统通常保留一个空闲帧缓冲池。当出现缺页错误时， 会像以前一样选择一个牺牲帧。 这种方法的扩展之一是， 维护一个修改页面的列表。每当调页设备空闲时， 就选择一个修改页面以写到磁盘上， 然后重置它的修改位。 另一种修改是， 保留一个空闲帧池， 并且记住哪些页面在哪些帧内。 应用程序与页面置换在某些情况下， 通过操作系统的虚拟内存访问数据的应用程序比操作系统根本没有提供缓冲区更差。 另一个例子是数据仓库， 它频繁地执行大址的、顺序的磁盘读取， 随后计算并写入。LRU 算法会删除旧的页面并保留新的页面， 而应用程序将更可能读取较旧的页面而不是较新的页面（因为它再次开始顺序读取）。 系统抖动事实上， 需要研究一下没有“ 足够＂ 帧的进程。如果进程没有需要支待活动使用页面的帧数， 那么它会很快产生缺页错误。此时， 必须置换某个页面。然而， 由于它的所有页面都在使用中， 所以必须立即置换需要再次使用的页面。因此， 它会再次快速产生缺页错误， 再一次置换必须立即返回的页面， 如此快速进行。 这种高度的页面调度活动称为抖动(thrashing)。如果一个进程的调页时间多于它的执行时间，那么这个进程就是在抖动。 通过局部置换算法(localreplacement algorithm)或优先权置换算法(priority replacement al gorithm),可以限制系统抖动。如果一个进程开始抖动， 那么由于采用局部置换， 它不能从另一个进程中获取帧， 而且也不能导致后者抖动。这种方法定义了进程执行的局部性模型(locality model)。 工作集模型如上所述， 工作集模型(working-set model)是基于局部性假设的。这个模型采用参数▲定义工作集窗口(working-setwindow)。它的思想是检查最近▲个页面引用。这最近▲个页面引用的页面集合称为工作集(working-set)（如图9-20所示）。如果一个页面处于活动使用状态， 那么它处在工作集中。如果它不再使用， 那么它在最后一次引用的▲ 时间单位后， 会从工作集中删除。 例如， 给定如图所示的内存引用序列， 如果▲为10个内存引用， 那么t1时的工作集为{1, 2, 5, 6, 7}。 工作集的精度取决于▲ 的选择。如果▲太小， 那么它不能包含整个局部；如果▲太大， 那么它可能包含多个局部。在极端情况下， 如果▲为无穷大， 那么工作集为进程执行所需的所有页面的集合。因此， 最重要的工作集属性是它的大小。如果系统内的每个工作集通过计算为wss,,那么就得到D=IWSS;这里D为帧的总需求量。每个进程都使用其工作集内的页面。因此， 进程l需要WSS;帧。如果总需求大千可用帧的总数(D&gt;m)， 则将发生抖动， 因此有些进程得不到足够的帧数。","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://fallensue.cc/tags/OS/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"","slug":"数据结构-图最小生成树","date":"2020-11-15T13:23:19.716Z","updated":"2020-11-15T13:49:50.190Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://fallensue.cc/posts/0.html","excerpt":"","text":"最小生成树定义在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。 构造网的最小生成树必须解决下面两个问题： 1、尽可能选取权值小的边，但不能构成回路； 2、选取n－1条恰当的边以连通n个顶点； 普里姆(prim)算法1.prim算法 基本思想：假设G＝(V，E)是连通的，TE是G上最小生成树中边的集合。算法从U＝{u0}（u0∈V）、TE＝{}开始。重复执行下列操作： 在所有u∈U，v∈V－U的边(u，v)∈E中找一条权值最小的边(u0,v0)并入集合TE中，同时v0并入U，直到V＝U为止。 此时，TE中必有n-1条边，T=(V，TE)为G的最小生成树。 Prim算法的核心:始终保持TE中的边集构成一棵生成树。 注意：prim算法适合稠密图，其时间复杂度为O(n^2)，其时间复杂度与边得数目无关，而kruskal算法的时间复杂度为O(eloge)跟边的数目有关，适合稀疏图。 例子如图 算法设计由于最小生成树包含每个顶点，那么顶点的选中与否就可以直接用一个数组来标记used[max_vertexes];（我们这里直接使用程序代码中的变量定义，这样也易于理解）；当选中一个数组的时候那么就标记，现在就有一个问题，怎么来选择最小权值边，注意这里最小权值边是有限制的，边的一个顶点一定在已选顶点中，另一个顶点当然就是在未选顶点集合中了。可以设置两个辅助数组lowcost[max_vertexes]和closeset[max_vertexes]，lowcost[max_vertexes]数组记录从U到V－U具有最小代价的边。对于每个顶点v∈V－U,closedge[v], closeset[max_vertexes]记录了该边依附的在U中的顶点。 注意：我们在考虑两个顶点无关联的时候设为一个infinity 1000000最大值。 过程如下表：顶点标号都比图中的小1，比如v1为0，v2为1，这里首先选择v1点。 Lowcost[0] Lowcost[1] Lowcost[2] Lowcost[3] Lowcost[4] Lowcost[5] U V-U closeset v1,∞ v1,6 v1,1 v1,5 v1,∞ v1,∞ v1 v1,v2,v3,v4,v5,v6 可以看到依附到v1顶点的v3的Lowcost最小为1，那么选择v3，选择了之后我们必须要更新Lowcost数组的值，因为记录从U到V－U具有最小代价的边，加入之后就会改变。这里更新Lowcost和更新closeset数组可能有点难理解， for (k=1;k&lt; if (!used[k]&amp;&amp;(G[j][k] { lowcost[k]=G[j][k]; closeset[k]=j; } }","categories":[],"tags":[],"keywords":[]},{"title":"数据结构-图的遍历","slug":"数据结构-图的遍历","date":"2020-11-15T12:00:01.000Z","updated":"2020-11-15T12:05:35.653Z","comments":true,"path":"posts/2b6326c7.html","link":"","permalink":"https://fallensue.cc/posts/2b6326c7.html","excerpt":"","text":"图的遍历深度优先遍历步骤 从一个给定的顶点v开始遍历 访问v的第一个邻居w，然后访问w的第一个还没有被访问过的邻居，以此类推。 如果某个结点没有没被访问过的邻居，那么就回溯到上一个访问的结点，并检查它的邻居是否被访问过 重复上边过程直到所有顶点均被访问 结果为V1,V2,V4,V8,V5,V6,V3,V7 算法的难点： 如何判断是否已经访问过某个顶点？ 如何搜索顶点的邻居？ 解决方案： 设置一个数组Visit[n],当第i个顶点已经被访问时, 设置Visit[i]=1. 根据不同的数据结构改变算法设计 代码分析：DFS需要回溯，那么使用递归。 算法： //访问标志的数组,为1表示访问过，为0表示未被访问 int visted[100]; //邻接表的深度优先遍历算法 void AdjacencyList::DFS(GraphAdjList *G, int i) { EdgeNode *p; visted[i] = 1; cout &lt;&lt; G-&gt;adjList[i].data &lt;&lt; &quot;--&quot;; p = G-&gt;adjList[i].firstedge; while (p) { if (!visted[p-&gt;adjvex]) { //递归访问 DFS(G, p-&gt;adjvex); } p = p-&gt;next; } } //邻接表的深度遍历操作 void AdjacencyList::DFSTraverse(GraphAdjList *G) { //初始化所有顶点都没有访问过 cout&lt;&lt;&quot;深度优先遍历结果为：&quot;&lt;&lt;endl; for (int i = 0; i &lt; G-&gt;numVertexes; i++) { visted[i] = 0; } for (int i = 0; i &lt; G-&gt;numVertexes; i++) { if (visted[i] == 0) { DFS(G, i); } } } 广度优先遍历步骤： 从一个顶点v开始访问 访问v的所有邻居 再访问v的第一个邻居w的所有邻居 再访问v的第二个邻居x的所有邻居 结果为V1,V2,V3,V4,V5,V6,V7,V8 BFS逐层访问结点(类似于层级遍历)，当访问每个结点的时候把它存起来，然后在遍历完这一层的结点之后可以溯回访问它相邻的节点，采用队列存储(给定层级上访问的第一个结点就是要返回的结点) 代码分析： 访问开始结点v 初始化一个队列，v入队 当队列不为空时，删除一个结点，将删除结点的所有邻居（如果没被访问），访问它们并将它们入队 重复以上直到队列为空 void BFSTraverse( Graph G ) { for ( v=1; v&lt;=G.vexnum; ++v ) visited[v] = FALSE; InitQueue(Q); for( v=1; v&lt;=G.vexnum; ++v ) if ( !visited[v] ) { visited[v]=TRUE; VISIT(v); EnQueue(Q, v); while (!EmptyQueue(Q)) { DeQueue(Q,u); for(w=FirstAdjVex(G, u); w&gt;0; w=NextAdjVex(G, u, w)) if( !visited[w] ) { visited[w]=TRUE; VISIT(w); EnQueue(Q, w); } } // end while } // end if }","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-图的存储结构","slug":"数据结构-图的存储结构","date":"2020-11-15T11:00:01.000Z","updated":"2020-11-15T12:05:35.647Z","comments":true,"path":"posts/5d8f99e.html","link":"","permalink":"https://fallensue.cc/posts/5d8f99e.html","excerpt":"","text":"图的存储结构邻接矩阵(Adjacency Matrix)定义设G=(V,E)是一个具有n个顶点的图。G的邻接矩阵是一个nxn的二维数组。A[n] [n]. 无向图的邻接矩阵一定是对称的，有向图的邻接矩阵不一定是对称的。 构造一个具有n个顶点与e条边的无向网G的时间复杂度为O(n^2+e*n)，初始化邻接矩阵化了O(n^2)的时间 代码实现邻接矩阵数据类型定义 #define MaxVertices 100 //定义最大容量 typedef struct{ //包含权的邻接矩阵的的定义 int Vertices[MaxVertices]; //顶点信息的数组 int Edge[MaxVertices][MaxVertices]; //边信息的数组 int numV; //顶点数 int numE; //边数 }AdjMatrix; 创建无向图的邻接矩阵 void CreateGraph(AdjMatrix *G) //图的生成函数 { int n,e,vi,vj,w,i,j; printf(&quot;请输入图的顶点数和边数（以空格分隔）：&quot;); scanf(&quot;%d%d&quot;,&amp;n,&amp;e); G-&gt;numV=n;G-&gt;numE=e; for(i=0;i&lt;n;i++) //图的初始化 for(j=0;j&lt;n;j++) { if(i==j) G-&gt;Edge[i][j]=0; else G-&gt;Edge[i][j]=32767; } for(i=0;i&lt;G-&gt;numV;i++) //将顶点存入数组中 { printf(&quot;请输入第%d个顶点的信息:&quot;,i+1); scanf(&quot;%d&quot;,&amp;G-&gt;Vertices[i]); } printf(&quot;\\n&quot;); for(i=0;i&lt;G-&gt;numE;i++) { printf(&quot;请输入边的信息i,j,w(以空格分隔):&quot;); scanf(&quot;%d%d%d&quot;,&amp;vi,&amp;vj,&amp;w); //若为不带权值的图，则w输入1 //若为带权值的图，则w输入对应权值 G-&gt;Edge[vi-1][vj-1]=w;//① G-&gt;Edge[vj-1][vi-1]=w;//② //无向图具有对称性的规律，通过①②实现 //有向图不具备此性质，所以只需要① } } 邻接表(Adjacency List)定义对于图来说，邻接矩阵是不错的一种图存储结构，但是我们也发现，对于边数相对顶点较少的图，这种结构是存在对存储空间的极大浪费的。因此我们考虑另外一种存储结构方式：邻接表（Adjacency List），即数组与链表相结合的存储方法。 每个结点由三个域组成，邻接点域(Adjvex)指示与顶点vi邻接的点在图中的位置，链域(nextarc)指示下一条边或弧的结点；数据域(info)存储和边或弧相关的信息，如权值等。 每个链表有一个表头结点，在表头结点中除了设有链域(firstarc)指向链表中第一个结点之外，还设有存储顶点vi的名或其他相关信息的数据域(data) 如图所示 代码实现#include&lt;iostream&gt; using namespace std; #define MAXVEX 100 /* 最大顶点数,应由用户定义 */ typedef char VertexType; /* 顶点类型应由用户定义 */ typedef int EdgeType; /* 边上的权值类型应由用户定义 */ typedef struct EdgeNode /* 边表结点 */ { int adjvex; /* 邻接点域,存储该顶点对应的下标 */ EdgeType weight; /* 用于存储权值,对于非网图可以不需要 */ struct EdgeNode *next; /* 链域,指向下一个邻接点 */ } EdgeNode; typedef struct VextexNode /* 顶点表结点 */ { VertexType data; /* 顶点域,存储顶点信息 */ EdgeNode *firstedge; /* 边表头指针 */ } VextexNode, AdjList[MAXVEX]; typedef struct { AdjList adjList; int numNodes, numEdges; /* 图中当前顶点数和边数 */ } GraphAdjList; void CreateALGraph(GraphAdjList *Gp) { int i, j, k; EdgeNode *pe; cout &lt;&lt; &quot;输入顶点数和边数(空格分隔）:&quot; &lt;&lt; endl; cin &gt;&gt; Gp-&gt;numNodes &gt;&gt; Gp-&gt;numEdges; for (i = 0 ; i &lt; Gp-&gt;numNodes; i++) { cout &lt;&lt; &quot;输入顶点信息：&quot; &lt;&lt; endl; cin &gt;&gt; Gp-&gt;adjList[i].data; Gp-&gt;adjList[i].firstedge = NULL; /* 将边表置为空表 */ } for (k = 0; k &lt; Gp-&gt;numEdges; k++) /* 建立边表 */ { cout &lt;&lt; &quot;输入边(vi,vj)的顶点序号i,j（空格分隔）:&quot; &lt;&lt; endl; cin &gt;&gt; i &gt;&gt; j; pe = (EdgeNode *)malloc( sizeof(EdgeNode)); pe-&gt;adjvex = j; /* 邻接序号为j */ /* 将pe的指针指向当前顶点上指向的结点 */ pe-&gt;next = Gp-&gt;adjList[i].firstedge; Gp-&gt;adjList[i].firstedge = pe; /* 将当前顶点的指针指向pe */ pe = (EdgeNode *)malloc( sizeof(EdgeNode)); pe-&gt;adjvex = i; pe-&gt;next = Gp-&gt;adjList[j].firstedge; Gp-&gt;adjList[j].firstedge = pe; } } int main( void) { GraphAdjList GL; CreateALGraph(&amp;GL); return 0; } 在建立邻接表以及逆邻接表时，若输入的顶点信息为顶点的编号，则建立邻接表的时间复杂度为O(n+e)，否则，需要通过查找才能得到顶点在图中位置，则时间复杂度为O(n*e)","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-图的基本定义","slug":"数据结构-图基本定义","date":"2020-11-14T13:30:01.000Z","updated":"2020-11-15T10:44:58.195Z","comments":true,"path":"posts/790212ce.html","link":"","permalink":"https://fallensue.cc/posts/790212ce.html","excerpt":"","text":"图的基本定义基本术语图（graph）图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中的顶点的集合，E是图G中边的集合。 顶点(Vertex)图中的数据元素。线性表中我们把数据元素叫元素，树中将数据元素叫结点。 边顶点之间的逻辑关系用边来表示，边集可以是空的。 无向边(Edge)若两个顶点之间的边没有方向，则称这条边为无向边。用(V1,V2)表示。(V1,V2) ≠ (V2,V1) 有向边(弧)(Arc)若两个顶点之间的边有方向，则称这条边为有向边。用&lt;V1,V2&gt;表示，V1为弧尾(Tail)(或终端点)，V2为弧头(Head)(或初始点)。&lt;V1,V2&gt; ≠ &lt;V2,V1&gt; 无向图(Undirected graphs)图中任意两个顶点之间的边都是无向边。 有向图(Directed graphs) 图中任意两个顶点之间的边都是有向边。 完全图(Completed graph) 有(1/2)*n(n-1)条边的无向图称为无向完全图，有n(n-1)条弧的有向图称为有向完全图。 稀疏图(Sparse graph)有很少条边或弧(如e&lt;nlogn)的图。 稠密图(Dense graph):不是稀疏图的图。 权（Weight）与图的边或弧相关的数。 网（Network）带权的图。 子图（Subgraph）假设G=（V,{E}）和G‘=（V’,{E’}），如果V’包含于V且E’包含于E，则称G’为G的子图。 邻接点(Adjacent)如果边(v,w)属于E，则称顶点v与w互为邻接点,v与w相邻接。边(v,w)依附于顶点v与w，或者说(v,w)和顶点v和w相关联。 度(Degree)是与v相关联的边的数目，记为TD(V).有向图中，入度表示指向自己的边的数目，出度表示指向其他边的数目，该顶点的度等于入度与出度的和. 路径(Path)从一个点到另一个的顶点序列，第一个顶点与最后一个顶点相同的路径称为回路或环(Cycle)。序列中顶点不重复的路径称为简单路径。 连通图(Connected graph)图中任意两个顶点都是连通的(从一个顶点到另一个顶点有路径)。 连通分量(Connected Component)无向图中的极大连通子图。 强连通图有向图中任意两个顶点之间都有路径。 生成树极小连通子图，含有图中全部顶点，但只有足以构成一棵树的n-1条边。","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"OS内存管理","slug":"OS内存管理","date":"2020-11-10T13:55:01.000Z","updated":"2020-11-18T07:31:58.845Z","comments":true,"path":"posts/48e0383b.html","link":"","permalink":"https://fallensue.cc/posts/48e0383b.html","excerpt":"","text":"内存管理为什么需要内存管理？原因： 内存越来越不值钱 需要高效的利用CPU的能力 背景CPU根据程序计数器的值从内存中提取指令，这些指令可能引起对特定内存地址的额外加载以及存储。 一个典型的指令执行周期， 首先从内存中读取指令。接着， 该指令会被解码， 也可能需要从内存中读取操作数。内存单元只看到地址流，而不知道这些地址从何产生。 基本硬件CPU可以直接访问的通用存储只有内存和处理器内置的寄存器。因此，执行指令以及指令使用的数据，应该处在这些可以直接访问的存础设备上。如果数据不在内存中， 那么在CPU 使用它们之前应先把数据移到内存。 CPU 内置寄存器通常可以在一个CPU 时钟周期内完成访问。完成内存的访问可能需要多个CPU 时钟周期。在这种情况下， 由于没有数据以便完成正在执行的指令， CPU 通常需要暂停(stall)。由于内存访问的频繁，这种情况是我们不想见到的。补救措施是在CPU 与内存之间， 通常是在CPU 芯片上， 增加更快的内存；这称为高速缓存(cache)。 为了确保操作的正确，首先，我们需要确保每个进程都有一个单独的内存空间。单独的进程内存空间可以保护进程而不互相影响，这对于将多个进程加到内存以便并发执行来说至关重要，通过两个寄存器，通常为基地址和界限地址，如图8所示，我们可以提供这种保护。基地址寄存器含有最小的合法的物理内存地址，而界限地址寄存器指定了范围的大小。 内存空间的保护是通过CPU对在用户模式下产生的地址与寄存器的地址进行比较而得成的。只有操作系统可以通过特殊的特权指令，才能加载基地址寄存器和界限地址寄存器。这个方案允许操作系统修改这两个寄存器的值，而不允许用户程序修改它们。 在内核模式下执行的操作系统可以无限制地访问操作系统及用户的内存。 地址绑定源程序中的地址通常是用符号表示，编译器会将这些符号地址绑定到可重定位的地址。链接程序或加载程序再将这些可重定位的地址绑定到绝对地址（如74014)。每次绑定都是从一个地址空间到另一个地址空间的映射。 通常，指令和数据绑定到存储器地址可在沿途的任何一步中进行： 编译时：如果在编译时就已知道进程将在内存中的驻留地址，那么就可以生成绝对代码。 加载时：如果在编译时并不知道进程将驻留在何处，那么编译器就应生成可重定位代码。 执行时：如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定应延迟到执行时才进行。 逻辑地址空间与物理地址空间CPU生成的地址叫做逻辑地址，内存单元看到的地址（即加载到内存地址寄存器的地址）通常称为物理地址。 编译时和加载时的地址绑定方法生成相同的逻辑地址和物理地址。然而， 执行时的地址绑定方案生成不同的逻辑地址和物理地址。在这种情况下， 我们通常称逻辑地址为虚拟地址。 从虚拟地址到物理地址的运行时映射是由内存管理单元（MMU）来完成。 动态加载为了获得更好的内存空间利用率，可以使用动态加载。采用动态加载时，一个程序只有在调用时才会加载。当一个程序需要调用另一个程序时，调用程序首先检查另一个程序是否加载。如果没有，则将其加载到内存中。 优点：只有一个程序被需要时才会加载，不需要操作系统提供特别支持。 交换进程必须在内存中以便执行。不过，进程可以暂时从内存交换到备份存储器，当再次执行时再调回内存中。 标准交换标准交换在内存与备份存储之间移动进程。备份存储通常是快速硬盘。系统维护一个可运行的所有进程的就绪队列，它们的映像在备份存储或者是内存中。 这种交换的上下文切换时间相当高。主要耗时是传输时间，为有效使用这种方法， 用户需要告诉系统它的内存需求情况。因此， 具有动态内存需求的进程需要通过系统调用来通知操作系统内存使用情况。 想换出一个进程必须保证它是空闲的。 现代操作系统现在并不使用标准交换。它的交换时间太多， 它提供的执行时间太少， 不是合理的内存管理的解决方案。 连续内存分配内存通常分为两个区域：一个用于驻留操作系统，另一个用于用户进程。 通常， 我们需要将多个进程同时放在内存中。因此我们需要考虑， 如何为输入队列中需要调入内存的进程分配内存空间。在采用连续内存分配时，每个进程位于一个连续的内存区域， 与包含下一个进程的内存相连。 内存保护防止进程访问不属于它的内存，可以采用重定位寄存器以及界限寄存器。每个逻辑地址应在界限寄存器规定的范围内。MMU通过动态地将逻辑地址加上重定位寄存器的值， 来进行映射。映射后的地址再发送到内存。 内存分配最简单：将内存分为多个固定大小的分区，每个分区可以只包含一个进程。（多分区方法）当一个分区空闲时，可以从输入队列中选择一个进程，来调入空闲分区。当该进程终止时，它的分区可以用于其他进程。 对于可变分区方案，操作系统有一个表，用于记录哪些内存可用和哪些内存已用。一大块的可用内存被称为孔 从一组可用孔中选择一个空闲孔的最常用方法包括：首次适应、最优适应、最差适应 首次适应：分配首个足够大的孔。 最优适应：分配最小的足够大的空。 最差适应：分配最大的孔。 碎片用于内存分配的首次适应和最优适应算法都有外部碎片的问题。 外部碎片问题：随着进程加载到内存和从内存退出， 空闲内存空间被分为小的片段。当总的可用内存之和可以满足请求但并不连续时， 这就出现了外部碎片问题：存储被分成了大量的小孔。这个问题可能很严重。最坏情况下，每两个进程之间就有空闲（或浪费的）块。 内部碎片：因此， 通常按固定大小的块为单位（而不是字节）来分配内存。采用这种方案， 进程所分配的内存可能比所需的要大。这两个数字之差称为内部碎片，这部分内存在分区内部，但又不能用。 外部碎片问题解决方法：紧缩，目的是移动内存内容以便将所有空闲空间合并成一整块。 外部碎片化问题的另一个可能的解决方案是：允许进程的逻辑地址空间是不连续的。 分段定义将内存看作一组不同长度的段，这些段之间并没有一定的顺序。逻辑地址空间是由一组段构成。每个段都有名称以及长度。地址指定了段名称以及段内偏移。用户通过两个量来指定地址：段名称和段偏移。 为了实现简单，段是编号的，是通过段号而不是段名称来引用。 逻辑地址由一个有序对&lt;段号，偏移&gt;组成。 允许进程的物理地址空间非连续。 分段硬件段表：将用户定义的二维地址映射到一维物理地址。 段表的每个条目都有段基地址和段界限，段基地址包含该段在内存中的开始物理地址，而段界限指定该段的长度。 每个逻辑地址由两部分组成：段号s和段偏移d，段号是段表的索引，逻辑地址偏移应该在0和段界限之间。如果不合法就由操作系统处理，如果合法，那么就与基地址相加而得到所需字节的物理内存地址。因此，段表实际上是基址寄存器值和界限寄存器值的数组。 每个段都在段表中有一个条目， 它包括段在物理内存内的开始地址（基地址）和该段的长度（界限）。 分页优势：避免了外部碎片以及紧缩，分段不可以。避免了将不同大小的内存块匹配到交换空间的麻烦问题。 基本方法将物理内存分为固定大小的块，称为帧或页帧；将逻辑内存也分为同样大小的块，称为页或页面。 逻辑地址空间要求的内存可以远远的大于实际的物理内存。 硬件支持由CPU生成的每个地址分为两个部分：页码(p)和页偏移(d)。页码作为页表的索引。页表包含每页所在物理内存单元的基地址。这个基地址与页偏移的组合就形成了物理内存地址，可发送到物理单元。如下图所示。 页大小（同帧大小一样）是由硬件来决定的。将页的大小选为2的幂可以方便地将逻辑地址转换为页码与页偏移。如果逻辑地址空间为2^m,且页的大小为2^n字节，那么逻辑地址的高m-n位表示页码，低n位表示页偏移。逻辑地址如下图所示 其中p作为页表的索引，而d作为页的偏移。 分页本身是一种动态的重定位。每个逻辑地址由分页硬件绑定位某个物理地址。采用分页类似于采用一组基址(重定位)寄存器，每个基址对应着一个内存帧。 分页不会产生外部碎片：每个空闲帧都可以分配给需要它的进程。 不过分页会有内部碎片，因为分配是以桢为单位来进行的，如果进程要求的内存并不是也的整数倍，那么最后一个帧可能会用不完。如果进程大小与页大小无关，那么每个进程的内部碎片的均值为半页。 分页内存系统的物理内存大小不同于进程的最大逻辑大小。分页允许我们使用的物理内存大于CPU地址指针可访问的空间。 分页的一个重要方面是，程序员视图的内存和实际的物理内存的清楚分离。帧同样有帧表用于保存。分页增加了上下文切换的时间。 页表结构分层分页两层分页算法：将页表再分页。 例如，再次假设一个系统，具有32位逻辑地址空间和4K大小的页。一个逻辑地址被分为20位的页码和12位的页偏移。因为要对页表进行再分页，所以此页码可分为10位的页码以及10位的页偏移。如下图所示。 其中p1是用来访问外部页表的索引， 而p2是内部页表的页偏移。采用这种结构的地址转换方法如图所示，这种方案称作向前映射页表。 但是如果外部页表实在太大，要分层分页就会很多，对于64位的架构，这个通常是不恰当的。 哈希页表通常用于处理大于32位地址空间，采用虚拟页码作为哈希值。 哈希页表的每一个条目都包括一个链表， 该链表的元素哈希到同一位置（该链表用来解决处理碰撞）。每个元素由三个字段组成： 1） 虚拟页码， 2 ) 映射的帧码， 3） 指向链表内下一个元素的指针。 该算法工作如下：虚拟地址的虚拟页码哈希到哈希表。用虚拟页码与链表内的第一个元素的第一个字段相比较。如果匹配， 那么相应的帧码（第二个字段）就用来形成物理地址；如果不匹配， 那么与链表内的后续节点的第一个字段进行比较， 以查找匹配的页码。如图所示。 倒置页表对千每个真正的内存页或帧， 倒置页表才有一个条目。每个条目包含保存在真正内存位置上的页的虚拟地址，以及拥有该页进程的信息。因此， 整个系统只有一个页表， 并且每个物理内存的页只有一条相应的条目。工作原理如图所示。","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://fallensue.cc/tags/OS/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"Hello Hexo","slug":"Hello Hexo","date":"2020-11-06T14:16:01.000Z","updated":"2020-11-14T14:13:35.320Z","comments":true,"path":"posts/a1751c09.html","link":"","permalink":"https://fallensue.cc/posts/a1751c09.html","excerpt":"","text":"序言过了这么久终于能够有一个自己的博客了，以后有什么想法就会往上面发。","categories":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://fallensue.cc/tags/Hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}]}]}