{"meta":{"title":"LuoSue's Blog","subtitle":null,"description":"闲话苑","author":"LuoSue","url":"https://fallensue.cc"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-11-07T10:37:48.955Z","comments":false,"path":"about/index.html","permalink":"https://fallensue.cc/about/index.html","excerpt":"","text":"[天意城のLuoSue] 与&nbsp; LuoSue&nbsp; （ 茄子 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bb","date":"2020-12-01T03:18:06.000Z","updated":"2020-12-01T03:18:07.013Z","comments":false,"path":"bb/index.html","permalink":"https://fallensue.cc/bb/index.html","excerpt":"","text":"","keywords":null},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-11-02T13:59:23.206Z","comments":false,"path":"donate/index.html","permalink":"https://fallensue.cc/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"books","date":"2020-10-27T06:39:26.000Z","updated":"2020-10-27T06:39:26.405Z","comments":true,"path":"books/index.html","permalink":"https://fallensue.cc/books/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-11-02T13:57:46.174Z","comments":false,"path":"client/index.html","permalink":"https://fallensue.cc/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://fallensue.cc/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"artitalk","date":"2020-11-08T14:16:01.000Z","updated":"2020-11-15T08:34:36.071Z","comments":false,"path":"artitalk/index.html","permalink":"https://fallensue.cc/artitalk/index.html","excerpt":"","text":"var img= “https://cdn.jsdelivr.net/gh/LuoSue/cdn/img/custom/avatar.jpg&quot;; var appID= ‘cJsUVOg7I9utk9hiYW4IU7KB-MdYXbMMI’; var appKEY= ‘mzyqLMOSjeVwxY0D09qW8O8z’; var per= “10”; var username= “luosue”;"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-11-02T13:58:00.756Z","comments":true,"path":"comment/index.html","permalink":"https://fallensue.cc/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"movies","date":"2020-10-27T06:39:40.000Z","updated":"2020-10-27T06:39:40.381Z","comments":true,"path":"movies/index.html","permalink":"https://fallensue.cc/movies/index.html","excerpt":"","text":""},{"title":"photos","date":"2020-10-27T06:39:05.000Z","updated":"2020-10-27T06:39:05.034Z","comments":true,"path":"photos/index.html","permalink":"https://fallensue.cc/photos/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-11-08T04:17:33.609Z","comments":false,"path":"music/index.html","permalink":"https://fallensue.cc/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-11-02T13:59:35.060Z","comments":false,"path":"lab/index.html","permalink":"https://fallensue.cc/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"https://fallensue.cc/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"https://fallensue.cc/tags/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-11-02T13:59:56.452Z","comments":true,"path":"links/index.html","permalink":"https://fallensue.cc/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://fallensue.cc/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"https://fallensue.cc/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"马克思主义基本原理概论","slug":"马克思主义基本原理概论","date":"2020-12-17T13:55:30.000Z","updated":"2020-12-17T14:04:24.975Z","comments":true,"path":"posts/8e9fc0a0.html","link":"","permalink":"https://fallensue.cc/posts/8e9fc0a0.html","excerpt":"","text":"马克思主义基本原理概论导论一、马克思主义的创立与发展 什么是马克思主义？ 狭义马克思主义和广义马克思主义 马克思主义基本立场 马克思主义基本观点 马克思主义基本方法 马克思主义的创立 社会根源 生产力的快速发展 资本主义带来的社会灾难 阶级基础 三大工人起义 法国里昂工人起义 英国宪章运动 德国西里西亚纺织工人起义 思想渊源 德国古典哲学 英国古典政治经济学 英法两国的空想社会主义 马克思主义的发展 马克思主义从理论到实践——十月革命 马克思主义中国化 二、马克思主义的鲜明特征 科学性 革命性 实践性 人民性 发展性 三、马克思主义的当代价值四、自觉学习和运动马克思主义第一章 世界的物质性及发展规律第一节 世界多样性与物质统一性 一、物质及其存在形态 物质概念 物质的客观实在性 物质的存在形态 物质的根本属性是运动 绝对运动和相对静止的对立统一 时间和空间是物质运动的存在形式 时间的性质 空间的性质 有限性与无限性的对立统一 实践是自然存在与社会存在区分和统一的基础 二、物质与意识的辩证关系 物质决定意识 从意识起源上看，意识是自然界和社会历史发展的长期产物 从意识本质上看，意识是人脑的机能和属性 从意识作用上看，意识对物质具有能否的反作用，发挥主观能动性需要尊重客观规律 意识对物质具有反作用 意识活动具有目的性和计划性 意识活动具有创造性 意识具有指导实践改造客观世界的作用 意识具有调控人的行为和生理活动的作用 主观能动性和客观规律性的统一 三、世界的物质统一性 人类社会也统一于物质 第二节 事物的联系和发展 一、联系和发展的普遍性 事物的普遍联系 联系具有客观性 联系具有普遍性 联系具有多样性 联系具有有条件性 事物的变化发展 运动、变化和发展的概念 发展的实质是新事物的产生和旧事物的灭亡 二、联系和发展的基本环节 内容与形式 本质与现象 原因与结果 必然与偶然 现实与可能 三、对立统一规律是事物发展的根本规律 矛盾的同一性和斗争性及其在事物发展的作用 矛盾同一性与斗争性的辩证统一 矛盾的普遍性和特殊性及其相互关系 主要矛盾和次要矛盾 矛盾的主要方面和次要方面 两点论和重点论的统一 四、量变质变规律和否定之否定规律 量变质变规律 质、量、度 量变和质变的辩证关系 事物发展的渐进性和飞跃性的统一 否定之否定规律 肯定-否定-否定之否定三阶段 事物发展的前进性和曲折性的统一 第三节 唯物辩证法是认识世界和改造世界的根本方法 一、唯物辩证法是科学的认识方法 二、辩证思维方法与现代科学思维方法 三、学习唯物辩证法，不断增强思维能力 第二章 实践与认识及其发展规律第一节 实践与认识 一、实践的本质与基本结构 实践是人类能动地改造世界的社会性活动 实践的三大基本特性 直接现实性 自觉能动性 社会历史性 实践的基本结构 实践主体、实践客体、实践中介 主体客体化与客体主体化 实践的多样性 物质生产实践（人类最基本的实践活动） 社会政治实践 科学文化实践 虚拟实践（新形式） 实践在认识活动中的决定作用 实践是认识的来源 实践是认识发展的动力 实践是认识的目的 实践是检验认识真理的唯一标准 二、认识的本质与过程 认识的本质 不同哲学派别对认知本质的不同观点 唯物主义 朴素唯物主义 形而上学唯物主义 辩证唯物主义 唯心主义 主观唯心主义 客观唯心主义 从实践到认识 实践-认识-实践 从感性认识到理性认识 感性认识和理性认识的辩证统一 从认识到实践 认识世界的目的是为了改造世界 认识的真理性只有在实践中才能得到检验和发展 三、实践与认识的辩证运动及其规律 实践-认识-再实践-再认识，循环往复以至无穷的辩证法发展过程 主观统一与客观，认识统一于实践 第二节 真理与价值 一、真理的客观性、绝对性和相对性 真理的客观性决定了真理的一元性 真理内容上的一元性与形式上多样性的统一 真理的绝对性和相对性的辩证统一 真理与谬误的对立统一 二、真理的检验标准 实践是检验真理的唯一标准 实践标准的确定性与不确定性 三、真理与价值的辩证统一 价值概念 价值既具有主体特性，又具有客观基础 价值的基本特性 主体性 客观性 多维性 社会历史性 真理与价值在实践中的辩证统一 价值尺度必须以真理为前提 人类自身需要的内在尺度，推动着人们不断发现新的真理 第三节 认识世界与改造世界 一、认识世界和改造世界相结合 认识世界和改造世界的辩证关系 改造客观世界和改造主观世界的辩证关系 认识世界和改造世界的过程是从必然走向自由的过程 二、一切从实际出发，实事求是 一切从实际出发是马克思主义认识论的根本要求 实事求是是中国共产党思想路线的核心 三、实现理论创新和实践创新的良性互动 实践创新为理论创新提供不竭的动力源泉 理论创新为实践创新提供科学的行动指南 努力实现理论创新和实践创新的良性互动 第三章 人类社会及其发展规律第一节 社会基本矛盾及其运动规律 一、社会存在与社会意识 唯物史观和唯心史观 社会存在 自然地理环境 人口因素 物质生产方式 社会意识 社会意识是社会生活的精神方面，是社会存在的反映 意识形态和非意识形态 社会存在与社会意识的辩证统一 社会存在决定社会意识 社会意识是社会存在的反映，并反作用于社会存在 社会意识的相对独立性 二、生产力与生产关系的矛盾运动及其规律 生产力基本要素 劳动资料（劳动手段） 劳动对象 劳动者 体力劳动和脑力劳动 生产关系 生产资料所有制关系 生产中人与人的关系 产品分配关系 生产力与生产关系的相互关系 生产力决定生产关系 生产关系对生产力具有能动的反作用 生产关系一定要适合生产力状况 三、经济基础与上层建筑的矛盾运动及其规律 经济基础 是指由社会一定发展阶段的生产力所决定的生产关系的总和 上层建筑 是建立在一定经济基础质上的意识形态以及与之相应的制度、组织和设施 经济基础与上层建筑的相互关系 经济基础决定上层建筑 上层建筑对经济基础具有反作用 经济基础与上层建筑的相互作用构成二者的矛盾运动 上层建筑一定要适合经济基础状况 四、社会形态更替的一般规律及特殊形式 社会形态 原始社会-奴隶社会-封建社会-资本主义社会-社会主义社会 社会形态更替的统一性和多样性 社会形态更替的必然性与人们的历史选择性 社会形态更替的前进性与曲折性 第二节 社会历史发展的动力 一、社会基本矛盾在历史发展中的作用 生产力和生产关系、经济基础和上层建筑的矛盾是社会基本矛盾 社会基本矛盾是历史发展的根本动力 生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定力量 社会基本矛盾特别是生产力和生产关系的矛盾，决定着社会中其他矛盾的存在和发展 社会基本矛盾具有不同的表现形式和解决方式，并从根本上影响和促进社会形态的变化和发展 社会主要矛盾 社会主要矛盾不是一成不变的，它在一定条件下会发生变化 正确认识和把握社会主要矛盾，是无产阶级政党正确判断形势和确立工作重心的客观依据 人民日益增长的物质文化需要同落后的社会生产之间的矛盾（八大） 人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾（十八大新时代） 二、阶级斗争和社会革命在阶级社会发展中的作用 阶级斗争是阶级社会发展的直接动力 阶级斗争是一个经济范畴，也是一个历史范畴 一切阶级斗争归根结底都是围绕经济利益这个轴心展开的 社会革命是阶级斗争发展到一定阶段的产物，是推动社会发展的重要动力 广义社会革命 人与自然关系、人与人的社会关系、思维方式、思想观念的重大变革 狭义社会革命 社会形态的变更，即新的社会形态取代旧的社会形态 马克思主义的阶级分析方法是认识阶级社会的科学方法 三、改革在社会发展中的作用 改革是同一种社会形态发展过程中的量变与质变，是推动社会发展的又一重要动力 四、科学技术在社会发展中的作用 科学技术作为先进生产力的重要标志,对于推动社会发展有着非常重要的作用 科技革命是推动经济和社会发展的强大杠杆 正确把握科学技术的社会作用 第三节 人民群众在历史发展中的作用 一、人民群众是历史的创造者 英雄史观和群众史观 人民群众在创造历史过程中的决定作用 人民群众是历史的主体，是历史的创造者 人民群众是社会物质财富的创造者 人民群众是社会精神财富的创造者 人民群众是社会变革的决定力量 人民群众创造历史的活动受到一定社会历史条件的制约 经济条件 政治条件 精神文化条件 无产阶级政党的群众路线 一切为了群众，一切依靠群众 从群众中来，到群众中去 二、个人在社会历史中的作用 杰出人物的历史作用 促进作用和阻碍作用 辩证地理解和评价个人的历史作用 必然与偶然的统一 历史分析方法 阶级分析方法 第四章 资本主义的本质及规律第一节 商品经济和价值规律 一、商品经济的形成和发展 简单商品经济和发达商品经济 在资本主义社会商品经济才成为普遍的经济形式 商品经济产生的历史条件 社会分工 生产资料和劳动产品属于不同的所有者 商品的二因素和生产商品的劳动的二重性 商品是用来交换、能满足人的某种需要的劳动产品 使用价值 是指商品能满足人的某种需要的有用性，反映的是人与自然之间的物质关系 是商品的自然属性 价值 是凝结在商品中的无差别的一般人类劳动，即人的脑力和体力的耗费 是商品所特有的社会属性 商品的使用价值和价值的对立统一 二者相互排斥、不可兼得 二者缺一不可 使用价值是价值的物质承担者 价值寓于使用价值之中 生产商品的劳动的二重性 具体劳动 是指产生一定使用价值的具体形式的劳动 具体劳动创造商品的使用价值 抽象劳动 是指撇开一切具体形式的、无差别的一般人类劳动，即人的脑力和体力的耗费 抽象劳动形成商品的价值 具体劳动和抽象劳动的对立统一 对立 具体劳动是劳动的自然属性 抽象劳动是劳动的社会属性 统一 具体劳动和抽象劳动是同一劳动的两种规定 商品价值量的决定 质的规定 无差别的一般人类劳动 量的规定 价值量是由劳动者生产商品所耗费的劳动量决定的，而劳动量则按照劳动时间来计量 社会必要劳动时间决定商品价值量 社会必要劳动时间概念 劳动生产率概念 关系图 简单劳动和复杂劳动 价值形式的发展与货币的产生 商品价值形式的发展四阶段 简单的或偶然的价值形式 总和的或扩大的价值形式 一般价值形式 货币价值形式 货币的五种基本职能 价值尺度 流通手段 贮藏手段 支付手段 世界货币 货币的出现解决了商品交换的困难，促进了商品经济的发展；但是没有解决商品经济的基本矛盾，即私人劳动和社会劳动的矛盾 二、价值规律及其作用 价值规律是商品生产和商品交换的基本规律 主要内容和客观要求 商品的价值量由生产商品的社会必要劳动时间决定，商品交换以价值量为基础，按照等价交换的原则进行 表现形式 商品的价格围绕商品的价值自发波动 受供需关系影响 长期看商品的平均价格和价值是一致的 价值规律的作用 自发地调节生产资料和劳动力在社会各个生产部门之间的分配比例 自发地刺激社会生产力的发展 自发地调节社会收入的分配 消极后果 导致社会资源浪费 阻碍技术的进步 导致收入两极分化 三、以私有制为基础的商品经济的基本矛盾 私人劳动和社会劳动的矛盾构成私有制商品经济的基本矛盾 决定着商品经济的本质及其发展过程 是商品经济其他一切矛盾的基础 决定着商品生产者的命运 四、科学认识马克思劳动价值论 科学的劳动价值论 商品的二因素和生产商品的劳动的二重性及其相互关系 价值的质和量的规定性及其变化规律 价值形式的发展和货币的起源 商品经济的基本矛盾和基本规律及其作用 马克思劳动价值论的理论和意义以及深化认知 第二节 资本主义经济制度的本质 一、资本主义经济制度的产生 前资本主义社会形态的演进和更替 原始社会-奴隶社会（第一个阶级剥削社会）-封建社会-资本主义社会生产关系的特点 资本主义生产关系的产生的两个途径 一是从小商品经济分化出来 二是从商人和高利贷者转化而来 资本的原始积累 资本原始积累就是生产者与生产资料相分离，资本迅速集中于少数人手中，资本主义得以迅速发展的历史过程 社会的生活资料和生产资料转化为资本 直接生产者转化为雇佣工人 资本原始积累的两个主要途径 一是用暴力手段剥夺农民的土地 二是用暴力手段掠夺货币财富 资本主义生产方式的确立 17世纪到18世纪后期的资产阶级革命 18世纪60年代起的工业革命 二、劳动力成为商品与货币转化为资本 资本主义经济制度是以资本主义私有制和雇佣劳动为基础的一种剥削制度。资本主义经济制度的形成是以劳动力成为商品为前提条件的。所以，认识资本主义经济制度的本质必须从理解劳动力成为商品入手。 - 劳动力成为商品的基本条件 - 劳动力和劳动的概念 - 劳动力成为商品要具备两个条件 - 劳动者 自由人，能够把自己的劳动力当作自己的商品来支配 - 劳动者没有别的商品可以出卖，自由的一无所有，没有任何实现自己劳动力所必需的的物质条件 - 劳动力商品的特点与货币转化为资本 - 劳动力的价值，是由生产、发展。维持和延续劳动力所必须的生活必需品的价值决定的。它包括三个部分 - 劳动力商品在使用价值上的特点 - 它的使用价值是价值的源泉 - 它在消费过程中能够创造新的价值 - 这个新的价值比劳动力本身的价值更大（超出劳动力价值的就是剩余价值） - 一旦货币购买了劳动力带来了剩余价值，货币也就变成了资本 - 剩余价值来源于资本家对雇佣工人劳动力的剥削 三、资本主义所有制 资本主义所有制的含义 资本主义所有制是生产资料归资本家所有的一种私有制形式 资本家拥有生产资料所有权 拥有对雇佣劳动者的支配权 从而实现对全部劳动产品的占有和支配 经济上的所有制和法律上的所有制 所有制和所有权的关系 所有制决定所有权 所有权是所有制的法律形态 资本主义所有制的本质 资本主义所有制是雇佣劳动赖以存在的基础，是资本与雇佣劳动之间剥削与被剥削关系的体现 四、生产剩余价值是资本主义生产方式的绝对规律 剩余价值的生产过程和资本的不同部分在剩余价值生产中的作用 劳动过程三要素 劳动者的劳动 劳动对象 劳动资料 资本主义劳动过程的两个特点 劳动隶属于资本家 劳动成果或产品全部归资本家所有 价值增值过程是剩余价值的生产过程 价值增殖过程的概念 必要劳动和剩余劳动 资本家无偿占有剩余劳动创造的价值，体现了剥削与被剥削关系 生产资料和劳动力 不变资本和可变资本 不变资本不发生增殖 可变资本购买劳动力，创造价值和剩余价值 剥削程度：剩余价值率 m’ = m / v 以物化劳动的形式表示资本家对工人的剥削程度 m’为剩余价值率 m为剩余价值 v为可变资本 m’ = 剩余劳动 / 必要劳动 = 剩余劳动时间 / 必要劳动时间 以活劳动的形式表示资本家对工人的剥削程度 剩余价值生产的两种基本方法 绝对剩余价值的生产 在必要劳动时间不变的条件下，由于延长工作日的长度和提高劳动强度而产生的剩余价值 容易引起工人反抗 相对剩余价值的生产 在工作日长度不变的条件下，通过缩短必要劳动时间而相对延长剩余劳动时间所产生的剩余价值 改进技术 改善经营管理 提高劳动生产率 获得超额剩余价值 超额剩余价值概念 资本积累 把剩余价值转化为资本，或者说，剩余价值的资本化，就是资本积累 简单再生产和扩大再生产 简单再生产概念 扩大再生产概念 资本积累的源泉是剩余价值，其规模的大小取决于 资本家对工人的剥削程度 劳动生产率的高低 所用资本和所费资本之间的差额 资本家垫付资本的大小 资本积累的影响 社会财富占有两极分化 资本主义社会失业现象产生的根源 资本有机构成c:v c为不变资本 v为可变资本 资本家为了获取相对剩余价值，必然提高资本有机构成 资本有机构成提高，导致劳动力相对过剩，导致失业 资本积累的趋势 资本主义生产越来越具有社会性 资本越来越集中于少数资本家手中 生产社会化和生产资料资本主义私人占有之间的矛盾日益加剧 资本主义制度必然灭亡。社会主义制度必然胜利 资本的循环周转与再生产 产业资本在循环过程中的阶段和职能 购买阶段G-W(A+Pm) 货币资本 准备生产剩余价值 生产阶段W(A+Pm)…P…W’ 生产资本 生产剩余价值 售卖阶段W’-G’ 商品资本 实现剩余价值 产业资本运动的两个基本前提条件 一是产业资本的三种职能形式必须在空间上并存 二是产业资本的三种职能形式必须在时间上继起 影响资本周转快慢的两个关键因素 资本周转时间 生产资本的固定资本和流动资本构成 社会总资本的再生产和流通 社会总产品 两大部类 第一部类（I）由生产生产资料的部门所构成，其产品进入生产领域 第二部类（II）由生产消费资料的部门所构成，其产品进入生活消费领域 三个组成部分 包括在产品中的生产资料的转移价值（c） 凝结在产品中的由工人必要劳动创造的价值（v） 凝结在产品中的由工人在剩余劳动时间里创造的价值（m） 使社会总产品在价值上得到补偿，在事物上得到替换，以使社会再生产顺利进行，是不以人的意志为转移的客观规律 工资与剩余价值的分配 资本主义工人工资的本质是劳动力的价值或价格 资本主义工资的形式主要有两种 计时工资 计件工资 剩余价值转化为利润时，剩余价值与可变资本的关系便被掩盖了 利润转化为平均利润 剩余价值理论的意义 深刻揭露了资本主义生产关系的剥削本质 阐明了资产阶级与无产阶级之间阶级斗争的经济根源 指出了无产阶级革命的历史必然性 五、资本主义的基本矛盾与经济危机 资本主义的基本矛盾 生产社会化和资本主义生产资料私人占有之间的矛盾 资本主义经济危机 生产过剩是资本主义经济危机的本质特征 资本主义经济危机的周期性 经济危机爆发的根本原因是资本主义的基本矛盾 第三节 资本主义政治制度和意识形态 一、资本主义政治制度及其本质 资本主义国家的职能和本质 对内职能和对外职能 对内实行政治统治和社会管理 对外进行国际交往和维护国家安全及利益 资本主义国家本质上是资产阶级进行阶级统治的工具 资本主义的民主制度及其本质 民主制度 民主与法制 政权组织形式 选举制度 政党制度等 资本主义政治制度本质上是资产阶级进行政治统治和社会管理的手段和方式，是为资产阶级专政服务的。 资本主义民主制度的进步作用和历史局限性 二、资本主义意识形态及其本质 资本主义意识形态的形成 资本主义意识形态的本质 第一，资本主义意识形态是资本主义社会条件下的观念上层建筑，是为资本主义的经济基础服务的，因而是为资本主义国家的政治上层建筑服务的 第二，资本主义意识形态是资产阶级的阶级意识的集中体现。 辩证地分析资本主义意识形态 第五章 资本主义的发展及其趋势第一节 垄断资本主义的形成与发展 一、资本主义从自由竞争到垄断 生产集中与垄断的形成 自由竞争-生产集中和资本集中-垄断 垄断产生的原因 第一，生产高度集中使少数企业，它们联合以获得高额利润 第二，企业规模巨大限制竞争 第三，竞争损失惨重，企业联合避免两败俱伤 垄断条件下竞争的特点 第一，垄断没有消除产生竞争的经济条件 第二，垄断必须通过竞争来维持 第三，任何垄断组织都不可能把全部社会生产都包下来 金融资本与金融寡头 金融资本是由工业垄断资本和银行垄断资本融合在一起而形成的一种垄断资本 金融寡头是指操纵国民经济命脉，并在实际上控制国家政权的少数垄断资本家或垄断资本家集团 金融寡头的统治地位 经济领域 “参与制” 政治领域 “个人联合” 垄断利润和垄断价格 垄断利润来源 剥削本国劳动人民 获取其他企业的利润 剥削其他国家劳动人民 利用政权将国民收入的一部分变成垄断收入 垄断价格实现垄断利润 垄断高价 是指垄断组织出售商品时规定的高于生产价格的价格 垄断低价 是指垄断组织在购买非垄断企业所生产的原材料等生产资料时规定的低于生产价格的价格 垄断价格=成本价格+平均利润+垄断利润 二、垄断资本主义的发展 国家垄断资本主义的形成及作用 国家垄断资本主义产生的背景 第一世界大战 交战国推行国民经济军事化 1929-1933年资本主义世界经济危机 美国“罗斯福新政” 英国“凯恩斯主义” 1939-1945年第二次世界大战 帝国主义各国建立了战时经济管理体制 国家垄断资本主义形成的原因 首先，社会生产力的发展，要求资本主义生产资料在更大范围内被支配，从而促进了国家垄断资本主义的产生 其次，经济波动和经济危机的深化，要求国家垄断资本主义的产生 最后，缓和矛盾，协调利益关系，要求国家垄断资本主义的产生 国家垄断资本主义的五种主要形式 国家所有并直接经营的企业 国家与私人共有、合营企业 国家通过多种形式参与私人垄断资本的再生产过程 宏观调节 微观规制 国家垄断资本主义对资本主义经济发展的积极作用 首先，国家垄断资本主义的出现在一定程度上有利于社会生产力的发展 其次，资产阶级国家凌驾于私人垄断资本之上，代表整个垄断资产阶级的利益，调节经济过程和经济活动，这在一定范围内突破了私人垄断资本主义的狭隘界限 再次，通过国家的收入再分配手段，使劳动人民生活水平有所改善和提高 最后，在国家垄断资本主义的参与和干预下，各主要资本主义国家的农业、工业、商业、通信业及交通运输业的现代化水平迅速提高，社会生产和社会生活的面貌改观，加快了这些国家国民经济的现代化进程 国家垄断资本主义并没有改变垄断资本主义的性质 最终目的在于维护资本主义制度和垄断统治的地位，追求高额垄断利润 金融垄断资本的发展 一方面促进了资本主义经济的发展 另一方面导致金融危机的频繁发生 垄断资本向世界范围内扩展的形式 借贷资本输出 生产资本输出 商品资本输出 私人资本输出和国家资本输出 垄断资本向世界范围输出的社会经济后果 对资本输出国的社会经济影响 带来了巨额的利润 带动扩大了商品输出 改善了国际收支状况 巩固了垄断优势地位 对资本输入国的社会经济影响 积极作用 不利影响 垄断资本主义的实质 垄断资本主义的五个基本特征 垄断组织在经济生活中起决定作用 在金融资本的基础上形成金融寡头的统治 资本输出具有特别重要的意义 瓜分世界的资本家国际垄断同盟已经形成 最大资本主义列强已把世界上的领土分割完毕 垄断资本主义的实质 垄断资本凭借垄断地位获取高额垄断利润 垄断资本对内通过“参与制”和“个人联合”谋求从经济到政治对整个国家的统治 对外运用经济的、政治的甚至战争的手段进行扩张，谋求对整个世界经济和政治的控制 三、经济全球化及其影响 经济全球化概念 经济全球化发展的三个阶段 殖民扩张和世界市场形成阶段 两个平行世界市场阶段 经济全球化阶段 经济全球化的表现 第一，国际分工进一步深化 第二，贸易全球化 第三，金融全球化 第四，企业生产经营全球化 经济全球化的动因 一、科学技术的进步和生产力的发展经济全球化提供了坚实的基础 二、跨国公司的发展为经济全球化提供了适宜的组织形式 三、各国经济体制的变革是经济全球化的体制保障 经济全球化的影响 经济全球化对发展中国家的积极作用 第一，经济全球化为发展中国家提供先进技术和管理经验 第二，经济全球化为发展中国家提供更多的就业机会 第三，经济全球化推动发展中国家国际贸易发展 第四，经济全球化促进发展中国家跨国公司发展 经济全球化带来的负面影响 一是发达国家与发展中国家在经济全球化过程中的地位和收益不平等、不平衡 二是加剧了发展中国家资源短缺和环境污染恶化 三是一定程度上增加了经济风险 第二节 正确认识当代资本主义的新变化 一、第二次世界大战后资本主义变化的新特点 新变化的表现 生产资料所有制的变化 劳资关系和分配关系的变化 社会阶级和阶层结构的变化 经济调节机制和经济危机形态的变化 政治制度的变化 新变化的原因和实质 科学技术革命和生产力的发展（根本推动力量） 工人阶级争取自身权利斗争（重要力量） 社会主义制度初步显示的优越性 主张改良主义的政党对资本主义制度的改革 二、2008年国际金融危机以来资本主义的矛盾与冲突 第一，经济发展“失调” 虚拟经济与实体经济发展失衡 福利风险增加 债务负担沉重 第二，政治体制“失灵” 西式选举往往难以选贤 政党利益可能凌驾于国家利益之上 “民主陷阱”会阻碍国家治理 传统精英政治走向衰落 第三，社会融合机制“失效” 社会极端思潮抬头 社会流动性退化 社会矛盾激化 第三节 资本主义的历史地位和发展趋势 一、资本主义的历史地位 历史进步性 资本主义将科学技术转变为强大的生产力 资本追求剩余价值的内在动力和竞争的外在压力推动了社会生产力的迅速发展 资本主义的意识形态和政治制度作为上层建筑在战胜封建社会自给自足的小生产的生产方式，保护、促进和完善资本主义生产方式方面起着重要作用，从而推动了社会生产力的迅速发展，促进了社会进步 历史局限性 资本主义基本矛盾阻碍社会生产力的发展 资本主义制度下财富占有两极分化，引发经济危机 资本家阶级支配和控制资本主义经济和政治的发展和运行，不断激化社会矛盾和冲突 二、资本主义为社会主义所代替的历史必然性 资本主义的内在矛盾决定了资本主义必然被社会主义所代替 社会主义代替资本主义是一个长期的历史过程 第六章 社会主义的发展及其规律第一节 社会主义五百年的历史进程 一、社会主义从空想到科学 空想社会主义三阶段 16-17世纪的早期空想社会主义 18世纪的空想平均共产主义 19世纪初期批判的空想社会主义 唯物史观和剩余价值学说为实现社会主义从空想到科学的飞跃奠定了坚实的理论基础 二、社会主义从理想到现实 第一国际与巴黎公社 十月革命胜利与第一个社会主义国家的建立 十月革命实现了社会主义从理想到现实的伟大飞跃，开辟了人类历史的新纪元 三、社会主义从一国到多国 社会主义在苏联一国的实践 巩固苏维埃政权时期 战时共产主义时期 新经济政策时期 社会主义发展到多个国家 四、社会主义在中国焕发出强大生机活力 站起来—富起来—强起来”三大历史性飞跃 第二节 科学社会主义一般原则 一、科学社会主义一般原则及其主要内容 第一，人类社会发展规律和资本主义基本矛盾是“资本主义必然灭亡、社会主义必然胜利”的根本依据 第二，无产阶级是最先进最革命的阶级，肩负着推翻资本主义旧世界、建立社会主义和共产主义新世界的历史使命 第三，无产阶级革命是无产阶级进行斗争的最高形式，以建立无产阶级专政的国家为目的 第四，社会主义社会要在生产资料公有制基础上组织生产，以满足全体社会成员的需要为生产的根本目的 第五，社会主义社会要对社会生产进行有计划的指导和调节，实行按劳分配原则 第六，社会主义社会要合乎自然规律地改造和利用自然，努力实现人与自然的和谐共生 第七，社会主义社会必须坚持科学的理论指导，大力发展社会主义先进文化 第八，无产阶级政党是无产阶级的先锋队，社会主义事业必须始终坚持无产阶级政党的领导 第九，社会主义社会要大力解放和发展生产力，逐步消灭剥削和消除两级分化，实现共同富裕和社会全面进步，并最终向共产主义社会过渡 二、正确把握科学社会主义一般原则 第一，必须始终坚持科学社会主义一般原则，反对任何背离科学社会主义一般原则的错误倾向 第二，要善于把科学社会主义一般原则与本国实际相结合 第三，紧跟时代和实践的发展，在不断总结新鲜经验中进一步丰富和发展科学社会主义一般原则 第三节 在实践中探索现实社会主义的发展规律 一、经济文化相对落后国家建设社会主义的长期性 生产力发展状况的制约 经济基础和上层建筑发展状况的制约 国际环境的严峻挑战 马克思主义执政党对社会主义发展道路的探索和对社会主义建设规律的认识，需要一个长期的过程 二、社会主义发展道路的多样性 各个国家的生产力状况和社会发展阶段决定了社会主义发展道路具有不同特点 历史文化传统的差异性是造成不同国家社会主义发展道路多样性的重要条件 时代和实践的不断发展，是造成社会主义发展道路多样性的现实原因 三、社会主义在实践探索中开拓前进 探索社会主义发展道路，必须坚持对待马克思主义的科学态度 探索社会主义发展道路，必须从当时当地的历史条件出发，坚持走“自己的路 ” 探索社会主义发展道路，必须充分吸收人类一切文明成果 第七章 共产主义崇高理想及其最终实现第一节 展望未来共产主义新社会 一、预见未来社会的方法论原则 （一）在揭示人类社会发展一般规律的基础上指明社会发展的方向 （二）在剖析资本主义社会旧世界中阐发未来新世界的特点 （三）在社会主义社会发展中不断深化对未来共产主义社会的认识 （四）立足于揭示未来社会的一般特征,而不可能对各种细节作具体描绘 二、共产主义社会的基本特征 （一）物质财富极大丰富，消费资料按需分配 （二）社会关系高度和谐,人们精神境界极大提高 （三）实现每个人自由而全面的发展，人类从必然王国向自由王国的飞跃 第二节 实现共产主义是历史发展的必然趋势 一、实现共产主义是历史发展的必然 二、实现共产主义是长期的历史过程 两个必然和两个决不会 “两个必然” 资本主义必然灭亡 社会主义必然胜利 “两个决不会” 无论哪一个社会形态，在它所能容纳的全部生产力发挥出来以前，是决不会灭亡的 而新的更高的生产关系，在它的物质存在条件在旧社会的胎胞里成熟以前，是决不会出现的 第三节 共产主义远大理想与中国特色社会主义共同理想 一、坚持远大理想与共同理想的辩证统一 二、坚定理想信念，投身新时代中国特色社会主义事业","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"马原","slug":"马原","permalink":"https://fallensue.cc/tags/马原/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"资本主义的本质及规律","slug":"资本主义的本质及规律","date":"2020-12-16T10:51:58.000Z","updated":"2020-12-16T10:39:39.638Z","comments":true,"path":"posts/4f746d1e.html","link":"","permalink":"https://fallensue.cc/posts/4f746d1e.html","excerpt":"","text":"资本主义的本质及规律商品经济以交换为目的而进行生产的经济形式得以产生的社会历史条件 存在社会分工 生产资料和劳动产品属于不同的所有者 商品二因素 商品是具有使用价值和价值两个因素或两种属性，是使用价值和价值的矛盾统一体 使用价值：商品能够满足人的某种需要的有用性，反映的是人与自然之间的物质关系，商品的自然属性，是一切劳动产品所共有的属性 使用价值构成社会财富的物质内容 使用价值是交换价值的物质承担者 交换价值首先表现为一种使用价值同另一种使用价值相交换的量的关系或比例 价值是凝结在商品中的无差别的一般人类劳动，即人的脑力和体力的耗费，商品所特有的社会属性 价值是交换价值的基础，交换价值是价值的表现形式 商品的使用价值与价值之间是对立统一的关系，二者不可兼得 作为商品，必须同时具有使用价值（自然属性）和价值（社会因素）两个因素 劳动二重性 生产商品的劳动可区分为 具体劳动 生产一定使用价值的具体形式的劳动 创造商品的使用价值 抽象劳动 人的脑力与体力的耗费，没有具体形式 形成商品的价值 以上两种劳动分别反映劳动的不同属性 正是劳动的二重性决定了商品的二因素 商品价值量的决定 不是生产商品的个别劳动时间，只能是社会必要劳动时间 价值量与生产商品所耗费的劳动时间成正闭，与劳动生产率成反比 价值形式的发展与货币的产生 商品的交换是以货币为媒介的，货币是在长期交换过程中形成的固定充当一般等价物的商品 货币的五种基本职能 价值尺度 流通手段 贮藏手段 支付手段 世界货币 基本矛盾 私人劳动和社会劳动的矛盾 价值规律及其作用 是商品生产和商品交换的基本规律 主要内容与客观要求 商品的价值量由生产商品的社会必要劳动时间决定，商品交换以价值量为基础，按照等价交换的原则进行 贯穿于商品经济的全部过程 表现形式 商品的价格围绕商品的价值自发波动 是在市场配置资源的过程中体现它的客观要求和作用的 作用表现在 自发地调节生产资料和劳动力在社会各生产部门之间的分配比例 自发地刺激社会生产力的发展 自发地调节社会收入的分配 价值规律在对经济活动进行自发调节时，会产生一些消极的后果 导致社会资源浪费 阻碍社会的进步 导致收入两极分化 以私有制为基础的商品经济的基本矛盾 私人劳动和社会劳动的矛盾 资本主义制度下，这种矛盾进一步发展成资本主义的基本矛盾，及生产社会化和生产资料资本主义私人占有之间的矛盾，正是这一矛盾的不断运动，才使资本主义最终被社会主义制度所取代具有了客观必然性 科学认识马克思劳动价值论 马克思在继承英国古典政治经济学劳动创造价值的理论的同时，创立了劳动二重性理论 劳动二重性理论成为“理解政治经济学的枢纽” 深化对马克思劳动价值论的认识 深化对创造价值的劳动的认识，对生产性劳动作出新的界定 深化对科技人员、经营管理人员在社会生产和价值创造中所起作用的认识 深化对价值创造和价值分配关系的认识 资本主义经济制度的本质资本主义产生的途径 从小商品经济分化出来 从商人和高利贷者转化而来 资本的原始积累 暴力手段剥夺农民的土地 暴力手段掠夺货币财富 资产阶级政治统治的建立和资本主义生产方式支配地位的形成，标志着资本主义制度的最终确立资本主义经济制度 以资本主义私有制和雇佣劳动为基础的一种剥削制度 形成是以劳动力成为商品为前提条件 劳动力 人的劳动能力，是人的脑力和体力的总和 劳动力的使用即劳动 成为商品的两个基本条件 劳动者是自由人，能够把自己的劳动力当作自己的商品来支配 劳动者没有别的商品可以出卖，自由的一无所有 劳动力价值是由生产、发展、维持和延续劳动力所必需的生活必需品的价值决定的 包括 维持劳动者本人生存的所必需的生活资料的价值 维持劳动者家属的生存所必需的生活资料的价值 劳动者接受教育和训练所支出的费用 它的使用价值是价值的源泉 一旦货币购买的劳动力带来剩余价值，货币也就成了资本 生产剩余价值是资本主义生产方式的绝对规律 资本主义生产过程是劳动过程和价值增值过程的统一 雇佣劳动者的剩余劳动是剩余价值的唯一源泉 要确定资本家对工人的剥削程度，就应该拿剩余价值和雇佣劳动者的可变资本相比 剩余价值/可变资本=剩余价值率 生产剩余价值的两种基本方法 绝对剩余价值的生产 必要劳动时间不变的条件下，由于延长工作日的长度和提高劳动强度而生产的剩余价值 相对剩余价值的生产 工作日长度不变的条件下，通过缩短必要劳动时间来相对延长剩余劳动时间所生产的剩余价值 超额剩余价值是指企业由于提高劳动生产率而使商品的个别价值低于社会价值的差额 生产自动化 只是意味着剩余价值生产所使用的生产工具更加先进了 资本家获取高额剩余价值的手段，雇佣工人的剩余劳动仍然是这种剩余价值的唯一源泉 资本积累 剩余价值转化为资本，也称剩余价值的资本化 资本主义简单再生产 资本家将剩余价值完全用于个人消费，生产在原有规模的基础上重复进行 扩大再生产 本质 资本家不断地无偿占有的工人创造的剩余价值来扩大自己的资本规模，进一步加强和扩大对工人的剥削和统治 源泉 剩余价值 规模的大小 取决于资本家对工人的剥削程度、劳动生产率的高低、所用资本和所费资本之间的差额以及资本家垫付资本的大小 历史趋势是资本主义制度的必然灭亡和社会主义制度的必然胜利 资本的技术构成 生产的技术水平决定的生产资料和劳动力之间的比例 资本主义生产的唯一动机和直接目的 追求剩余价值 资本的循环周转和再生产 产业资本循环过程之中的三个不同的阶段 购买阶段，生产资料和劳动力的购买阶段 属于商品的流通过程，产业资本执行的是货币资本的职能 生产阶段，生产资料和生产力从事资本主义生产的过程 执行的是生产资本的职能 售卖阶段 执行的是商品资本的职能 产业资本的运动 两个前提条件 一是产业资本的三种职能形式必须在空间上并存 二是产业资本的三种职能形式必须在时间上继起 资本的周转 不断反复、周而复始的资本循环 影响周转快慢的关键因素 资本周转的时间 生产资本的固定资本和流动资本的构成 社会再生产核心问题 社会总产品的实现问题，社会总产品的价值补偿和实物补偿问题 工资与剩余价值的分配 工资是劳动力的价值或价格 掩盖了资本主义的剥削关系 只要资本和雇佣劳动的基本经济关系不变，资本主义工资的实质就不会发生根本变化 平均利润率 剩余价值总量与社会总资本的比率 资本主义的基本矛盾与经济危机 基本矛盾 生产社会化和生产资料资本主义私人占有之间的矛盾 经济危机 本质特征 生产过剩 抽象的一般的可能性 是由货币作为流通手段和支付手段引起的 根本原因 资本主义的基本矛盾 两个方面 生产无限扩大的趋势与劳动人民有支付能力的需求相对缩小的矛盾 单个企业内部生产的有组织性和整个社会生产的无政府状态之间的矛盾 资本主义政治制度和意识形态资本主义国家职能 以服务资本主义制度和资产阶级利益为根本内容 对内职能 政治统治的职能 对外职能 资本主义国家对外进行国际交往与维护国家安全和利益的职能 资本主义国家本质上是资产阶级进行阶级统治的工具资本主义政治制度的阶级的和历史的局限性 资本主义的民主是金钱操控下的民主，资产阶级精英统治下的民主 法律名义上的平等掩盖着事实上的不平等 资本主义国家的政党制是一种维护资产阶级统治的政治制度","categories":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}],"tags":[{"name":"马原","slug":"马原","permalink":"https://fallensue.cc/tags/马原/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}]},{"title":"资本主义的发展及其趋势","slug":"资本主义的发展及其趋势","date":"2020-12-16T07:51:58.000Z","updated":"2020-12-16T10:39:39.638Z","comments":true,"path":"posts/ccb0dc76.html","link":"","permalink":"https://fallensue.cc/posts/ccb0dc76.html","excerpt":"","text":"资本主义的发展及其趋势垄断资本主义的形成与发展生产集中与垄断的形成 生产集中 生产资料、劳动力和商品的生产日益集中与少数大企业的过程 其结果是大企业所占的比重不断增加 资本集中 大资本吞并小资本，或由多数小资本合并而成大资本的过程 其结果是越来越多的资本为少数大资本家所支配 垄断 少数资本主义大企业为了获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产、销售和价格进行操纵和控制 原因 为获得高额利润 形成对竞争的限制 避免两败俱伤 垄断组织的本质 通过联合实现独占和瓜分商品生产和销售市场，操纵垄断价格，以获取高额垄断利润 垄断条件下竞争的特点 垄断不能消除竞争，反而使竞争变得更加复杂和激烈 垄断没有消除产生竞争的经济条件 垄断必须通过竞争来维持 社会生产是复杂多样的，任何垄断组织都不可能把包罗万象的社会生产都包下来 新特点 为了获取高额垄断利润，并不断巩固和扩大自己的垄断地位和统治权力 自由竞争主要运用经济手段，但垄断采取了非经济的手段，不仅经济领域的竞争多种多样，而且还扩大到经济领域以外进行竞争 金融资本与金融寡头 金融资本 工业垄断资本和银行垄断资本融合在一起形成的一种垄断资本 金融寡头 操纵国民经济命脉，并在实际上控制国家政权的少数垄断资本家或垄断资本家集团 在经济领域中的统治主要是通过“参与制”来实现的 对国家机器的控制主要是通过同政府的“个人联合”来实现的 垄断利润和垄断价格 垄断资本的实质在于获取垄断利润 垄断利润 垄断资本家凭借其在社会生产和流通过程中的垄断地位而获得的超过平均利润的高额利润 归根结底来自无产阶级与其他劳动人民所创造的剩余价值 来源 来自对本国无产阶级和其他劳动人民剥削的加强 由于垄断资本可以通过垄断高价和垄断低价来控制市场，使得它能够获得一些其他企业特别是非垄断企业的利润 通过加强对其他国家劳动人民的剥削和掠夺从国外获取利润 通过资本主义国家政权进行有利于垄断资本的再分配，从而将劳动人民创造的国民收入的一部分变成垄断资本的收入 主要是通过垄断组织制定的垄断价格来实现的 垄断价格 垄断组织在销售或购买产品时，凭借其垄断地位规定的、旨在保证获取最大限度利润的市场价格 垄断价格=成本价格+平均利润+垄断利润 包括垄断高价和垄断低价两种形式 没有否定价值规律，它是价值规律在垄断资本主义阶段作用的具体体现 垄断资本主义的发展 国家垄断资本主义的形成及作用 国家垄断资本主义是国家政权和私人垄断资本融合在一起的垄断资本主义 形成 社会生产力的发展（根本） 经济波动和经济危机的深化，要求国家资本主义的产生 缓和社会矛盾，协调利益关系，要求国家垄断资本主义的产生 国家垄断资本主义的主要形式 国家所有并直接经营的企业 国家与私人共有、合营企业 国家通过多种形式参与私人垄断资本的再生产过程 宏观调节 微观规制 经济全球化及其影响 经济全球化是指在生产不断发展、科技加速进步、社会分工和国际分工不断深化、生产的社会化和国际化程度不断提高的情况下，世界各国、各地区的经济活动越来越超出某一国家和地区的范围而相互联系、相互依赖的过程 经济全球化的表现 国际分工进一步深化 贸易全球化 指商品和劳务在全球范围内的自由流动 金融全球化 指世界各国、各地区在金融业务、金融政策等方面相互协调、相互渗透、相互竞争不断加强，使全球金融市场更加开放、金融体系更加融合、金融交易更加自由的过程 企业生产经营全球化 指跨国公司在全球范围内建立分支机构，借助母公司与分支机构之间各种形式的联系，实行跨国投资和生产的过程 经济全球化的动因 主要因素 科学技术的进步和生产力的发展为经济全球化提供了坚实的物质基础和根本的推动力 跨国公司的发展为经济全球化提供了适宜的企业组织形式 各国经济体制的变革是经济全球化的体制保障 经济全球化的影响 带来巨大的分工利益，推动世界生产力的发展 积极作用主要表现在 为发展中国家提供先进技术和管理经验 为发展中国家提供更多的就业机会 推动发展中国家国际贸易发展 消极 发达国家与发展中国家在经济全球化过程中的地位与收益不平等、不平衡 加剧了发展中国家资源短缺和环境污染恶化 一定程度上增加经济风险（蝴蝶效应） 正确认识当代资本主义的新变化表现 生产资料所有制的变化 劳资关系和分配关系的变化 相关制度 职工参与决策 终身雇佣 职工持股 社会阶层和阶级结构的变化 经济调节机制和经济危机形态的变化 政治制度的变化 新变化的原因和实质 二战后，资本主义发生新变化的原因主要有以下几个方面 科学技术革命和生产力的发展，是当代资本主义发生新变化的根本推动力量 工人阶级争取自身权利和利益的斗争，是推动当代资本主义发生新变化的重要力量 社会主义制度初步显示的优越性对当代资本主义产生了重要影响 主张改良主义的政党对资本主义制度的改革，也对当代资本主义新变化发挥了重要作用 资本主义的矛盾与冲突 经济发展“失调” 经济发展仍然面临着一系列问题 虚拟经济和实体经济发展失衡 福利风险增加 债务负担沉重 政治体制“失灵” 西式选举往往难以“选贤” 政党利益可能凌驾于国家利益之上 “民主陷阱”会阻碍国家治理 社会融合机制“失效” 占领华尔街运动的实质就是西方普通民众看不到希望，要抗争求变 分支主题 3","categories":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}],"tags":[{"name":"马原","slug":"马原","permalink":"https://fallensue.cc/tags/马原/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}]},{"title":"世界的物质性及其发展规律","slug":"世界的物质性及发展规律","date":"2020-12-16T03:51:58.000Z","updated":"2020-12-16T01:14:08.691Z","comments":true,"path":"posts/8a78b0c5.html","link":"","permalink":"https://fallensue.cc/posts/8a78b0c5.html","excerpt":"","text":"世界的物质性及发展规律世界多样性与物质统一性物质及其存在形态 世界上万事万物归结于两大现象 物质现象 精神现象 人类一切活动归结于两类活动 认识世界 改造世界 存在和思维关系问题 又称为物质和精神的关系问题 全部哲学的基本问题 恩格斯说 全部哲学，特别是近代哲学的重大的基本问题，是思维（意识）和存在（物质）的关系问题 两个方面的内容 存在与思维究竟谁是世界本原 物质第一性，思维第二性 唯物主义 思维第一性，物质第二性 唯心主义 存在和思维有没有同一性 思维能否正确认识存在 能：可知论 不能：不可知论 对这个问题的回答是解决其他一切哲学问题的前提与基础 物质 唯物史观：把历史当作物质分析而得 正确理解是我们认识和把握世界本质与规律的前提 古代朴素唯物主义 物质为本原解释世界 近代形而上学唯物主义 物质等同于原子 但是马克思批判了上面两个 要从能动的实践出发去把握客观世界的意义 恩格斯 物质这个概念是从各种物的总和中抽象出来的 列宁 对物质的概念做了全面而科学的规定 标志客观实在的物质范畴 人通过感觉感知 不依赖于感觉存在 不为感觉而变 马克思主义的物质范畴理论 万事万物的共同特性（唯一特性） 客观实在性 坚持了唯物主义一元论，同唯心主义一元论和二元论划清界限 坚持了能动的反映论和可知论，批判了不可知论 体现了辩证法和唯物论的统一，克服了形而上学唯物主义的缺陷 体现了唯物主义自然观与唯物主义历史观的统一，为彻底的唯物主义奠定了理论基础 物质的存在形态 根本属性：运动 运动：标志一切事物和现象的变化及其过程的哲学范畴 物质与运动不可分割 物质世界的运动是绝对的，而物质在运动过程中又有某种相对的静止 运动与静止相互依赖、相互渗透、相互包含 无条件的绝对运动与有条件的相对静止对立统一 时间与空间 物质运动存在形式 时间是指物质运动的持续性、顺序性，特点是一维性 空间是指物质运动的广延性、伸张性，特点是三维性 物质运动与之不可分割，证明了其客观性 实践是自然存在与社会存在区分和统一的基础 马克思从时间出发解释社会的本质，指出“全部社会生活在本质上是实践的” 从实践出发理解社会生活的本质 实践是使物质世界分化为自然界与人类社会的物质前提 是使自然界与人类社会统一起来的现实基础 实践是人类社会的基础，是理解与解释一切社会现象的钥匙 社会关系形成的基础 形成了社会生活的基本领域 构成了社会发展的动力 物质与意识的辩证关系 物质决定意识 意识 人脑的机能和属性 客观世界的主观映象 不仅自然界长期发展的产物，而且是社会历史发展的产物 在产生与发展中劳动起了决定性作用 提供了客观需要和可能 语言促进了意识的发展 内容上客观，形式上主观，客观内容与主观形式的统一 决定作用表现在 意识的起源、本质与作用上 意识对物质具有反作用✨ 意识的能动作用 意识活动具有目的性和计划性 意识活动具有创造性 意识具有指导实践改造客观世界的作用 意识具有调控人的行为和生理活动的作用 主观能动性与客观规律性的统一 尊重客观规律是正确发挥主观能动性的前提 只有充分发挥主观能动性，才能正确认识和利用客观规律 正确发挥主观能动性前提条件 从实际出发是正确发挥人的主观能动性的前提 实践是正确发挥人的主观能动性的基本途径 正确发挥人的主观能动性，需要依赖一定的物质条件和物质手段 世界的物质统一性 马克思主义认为，物质是世界的本原，世界统一于物质 首先体现在，意识统一于物质 还体现在，人类社会统一于物质 人类社会的物质性主要表现在 人类社会是物质世界的组成部分 人类获取生活资料的活动是物质性的活动 人类社会存在和发展的基础是物质资料的生产方式 原理及其意义✨ 马克思主义的基石 在认识世界和改造世界的过程中，坚持实事求是，一切从实际出发是世界的物质统一性原理在现实生活中和实际工作中的生动体现 事物的联系与发展联系与发展的观点是唯物辩证法的总观点和总特征联系是指事物内部各要素之间和事物之间相互影响、相互制约、相互作用的关系联系 客观性 事物的联系是事物固有的，不是主观臆想的 普遍性 任何事物内部的不同部分和要素之间相互联系，任何事物具有内在的结构性 任何事物均不能孤立的存在，都同其他事物处于一定的联系之中 整个世界是相互联系的统一整体，任何事物都处于普遍联系、交互作用之中 多样性 世界上的事物是多样的，事物间的联系也是多样的 条件性 条件对事物的发展和人的活动具有支持或制约作用 条件可以改变 改变与创造条件不是任意的，必须尊重事物发展的客观规律 事物的变化发展 发展是前进的，上升的运动，发展的实质是新事物的产生与旧事物的灭亡 新事物不可战胜 新事物有新的要素、结构、功能，它适应已经变化了的环境和条件 新事物脱胎于旧事物，扬长避短，还添加了新的东西 符合人民群众的利益要求，得到人民群众的拥护 联系与发展的基本环节 内容与形式 任何事物都是内容与形式的统一 一方面，内容是事物存在的基础，对形式具有决定作用 另一方面，形式对内容有反作用 内容是构成事物的一切要素的综合，形式指把诸要素统一起来的结构或表现内容的形式 本质与现象 相互区别 本质一般的、普遍的，相对稳定 现象个别的、具体的，多变易逝 相互依存 本质决定现象 现象表现本质 原因与结构 相互区别 引起某种现象的现象是原因，被某种现象引起的现象是结果 相互依存与相互转化 必然与偶然 相互依存 必然是事物联系与发展中确定不移的趋势 偶然是指事物联系与发展中不确定的趋势 必然总是伴随着偶然，必然要通过偶然表现出来，为自己开辟道路 相互转化 现实与可能 相互区别 相互转化 一方面，现实蕴含着未来的发展方向，会不断产生出新的可能 另一方面，可能包含着发展成为现实的因素和依据，一旦条件成熟就会转化为现实 发展就是现实与可能相互转化的过程 对立统一规律是事物发展的根本规律 唯物辩证法基本规律 对立统一规律 是唯物辩证法的实质和核心 揭示了事物普遍联系的根本内容和变化发展的内在动力，从根本上回答了事物为什么会发展的问题 贯穿量变质变规律、否定之否定规律以及唯物辩证法基本范畴的中心线索 对立统一规律提供了人民认识世界和改造世界的根本方法——矛盾分析法 量变质变规律 否定之否定规律 矛盾 对立属性（斗争性） 矛盾的对立面相互排斥，相互分离的性质与趋势 无条件的，绝对的 事物发展过程中作用 矛盾双方斗争村健矛盾双方力量的变化，竟长争高、此消彼长，造成双方力量的不平衡，为对立面的转化、事物的质变创造条件 矛盾双方的斗争是一种矛盾统一体向另一种矛盾统一体过渡的决定力量 统一属性（同一性） 双方相互依存，相互贯通的性质和趋势 矛盾的对立面相互依存，互为存在的前提，并处于同一个统一体中 矛盾的对立面相互贯通，一定条件下可以相互转化 有条件的，相对的 同一性与斗争性相互联结，相辅相成 没有斗争性就没有同一性，反之亦然 斗争性寓于同一性之中，同一性通过斗争性来体现 ✨运用矛盾的同一性与斗争性原理指导实践，还要正确把握和谐对事物发展的作用 普遍性和特殊性及其相互关系 普遍性 矛盾存在于一切事物之中和事物发展过程的始终，事物始终在矛盾中运动 共性 无条件，绝对 特殊性 指各个具体事物的矛盾、每一个矛盾的各个方面在发展的不同阶段上各具有其特点 个性 有条件，相对 辩证统一的 矛盾是共性和个性的有机统一 事物的性质是由主要矛盾的主要方面所决定的 把主要矛盾和次要矛盾、矛盾的主要方面和次要方面的辩证关系运用到实际工作中，就是要坚持“两点论”和“重点论”的统一 量变质变规律和否定之否定规律 量变质变规律 事物的矛盾运动表现为量变与质变及其相互转化 事物变化的两种基本状态和形式 量变与质变的相互作用、相互转化构成了 量变 不显著变化，体现了事物发展渐进过程的连续性 质变 事物性质根本变化，事物由一种质态向另一种质态的飞跃，体现了事物发展渐进过程和连续性的中断 量变质变辩证关系 量变是质变的必要准备 质变是量变的必然结果 量变和质变是相互渗透的，一方面，在总的量变过程中有阶段性和局部性的部分质变；另一方面，在质变过程中也有旧质在量上的收缩和新质在量上的扩张 否定之否定规律 事物内部均有 肯定因素 维持现存事物存在的因素 否定因素 促使现存事物灭亡的因素 ✨辩证否定观的基本内容 否定是事物的自我否定 否定是事物发展的环节 否定是新旧事物联系的环节 辩证否定的实质是“扬弃”，即新事物对旧事物即批判又继承，即克服其消极因素又保留其积极因素 事物的辩证发展 经过两次否定、三个阶段，形成一个周期 否定之否定阶段仿佛是向原来出发点的“回复”，但这是在更高阶段的“回复” 揭示了事物发展的前进性和曲折性的统一 唯物辩证法是认识世界和改造世界的根本方法唯物辩证法是客观辩证法与主观辩证法的统一 客观辩证法是指客观事物或客观存在的辩证法 主观辩证法是指人类认识和思维运动的辩证法 上面两个本质上是统一的，但在表现形式上却是不同的，客观辩证法采取外部必然性形式，主观辩证法则采取观念的、逻辑的形式 矛盾分析方法是根本的认识方法 矛盾分析方法是对立统一规律在方法论上的体现，在唯物辩证法的方法论体系中居于核心的地位，是我们认识事物的根本方法 物生有两，相反相成 一分为二，合二为一 和而不同，执用两中 和实生物，同则不继 核心要求 善于分析矛盾的特殊性，做到具体矛盾具体分析，具体情况具体分析 列宁指出：“马克思主义的活的灵魂：对具体情况做具体分析”","categories":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}],"tags":[{"name":"马原","slug":"马原","permalink":"https://fallensue.cc/tags/马原/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}]},{"title":"实践与认识发展及其规律","slug":"实践与认识及其发展规律","date":"2020-12-16T02:51:58.000Z","updated":"2020-12-16T01:14:08.697Z","comments":true,"path":"posts/f302a3b6.html","link":"","permalink":"https://fallensue.cc/posts/f302a3b6.html","excerpt":"","text":"实践与认识及其发展规律实践与认识实践的本质与基本结构 实践 人类能动改造世界的社会性的物质活动 基本特征 直接现实性 自觉能动性 社会历史性 基本结构 客体，主体，中介三项基本要素的有机统一 实践主体 有一定的主体能力、从事社会实践活动的人 能力包括自然能力与精神能力，精神能力包括知识性因素与非知识性因素 实践客体 实践活动所指向的对象 实践中介 各种形式的工具、手段以及运用操作这些工具、手段的程序和方法 主体与客体相互作用的关系 实践关系（最根本） 认识关系 价值关系 主体客体化 人通过实践使自己的本质力量作用于客体，使按照主题的需要发生结构和功能上的变化，形成了世界上本来不存在的对象物 客体主体化 客体从客观对象的存在形式转化为主体生命结构的因素或主题本质力量的因素，客体失去客体性的形式，变成主题的一部分 形式的多样性 三种基本类型 物质生产实践（人类最基本的实践活动） 社会政治实践 科学文化实践 新的实践形式 虚拟实践（相对独立性） 认识活动中的决定作用 实践的观点是辩证唯物论的认识论之第一的和基本的观点 表现于以下四个方面 实践是认识的来源 实践是认识发展的动力 实践是认识的目的 实践是检验认识真理性的唯一标准 认识的本质与过程 认识的本质是主题在实践基础上对客体的能动反映 认识的本质 两条根本对立的认识路线 坚持从物到感觉和思想的唯物主义认识路线 坚持反映论的立场 旧唯物主义认识论：意识被动地反映与接收外界对象（直观、消极） 辩证唯物主义认识论：能动的反映论 认识的本质是主体在实践基础上对客体的能动反映 坚持从思想和感觉到物的唯心主义认识路线 从实践到认识 人们认识事物的过程，是一个从实践到认识，再从认识到实践的过程 认识的过程首先是从实践到认识的过程 这个过程主要表现为在实践基础上认识活动由感性认识能动地飞跃到理性认识 认识运动的第一次飞跃 感性认识 三种形式 感觉 知觉 表象 理性认识 三种形式 概念 判断 推理 感性认识与理性认识辩证统一 感性认识有待于发展和深化成理性认识 理性认识依赖于感性认识 感性认识与理性认识相互渗透、相互包含 如果割裂二者这个关系 走向唯理论 走向经验论 从感性认识到理性认识 基本条件 投身实践，深入调查，获取十分丰富与合乎实际的感性材料 必须经过思考的作用，运用理论思维和科学抽象 认识运动是复杂的运动过程 表现在 无论在感性认识还是理性认识当中，都有非理性因素的作用 非理性因素主要是指认识主体的情感和意志 人的认识过程是理性因素与非理性因素协同作用的结果 从认识到实践 认识过程的第二次的能动的飞跃 必要性与重要性 认识世界的目的是为了改造世界 认识的真理性只有在实践中才能得到检验与发展 实践与认识的辩证运动及其规律 由感性认识到理性认识，又由理性认识到实践的飞跃，是实践、认识、再实践、再认识，循环往复以至无穷的辩证发展过程 真理与价值真理的客观性 真理不是客观的 马克思主义认为，真理是标志主观与客观相符合的哲学范畴，是对客观事物及其规律的正确反映 真理的客观性指真理的内容是对客观事物及其规律的正确反映，真理中包含着不依赖人和人的意识的客观内容。客观性是真理的本质属性 决定了真理的一元性，指在同一条件下对于特定的认识客体的真理性认识只有一个，而不可能有多个 真理的绝对性和相对性 真理的绝对性 真理主客观统一的确定性和发展的无限性 是指任何真理都标志着客观与主观之间的符合，都包含着不依赖于人和人的意识的客观内容，都同谬误有原则的界限 人类的认识按照其本性来说，能够正确认识无限发展着的物质世界，认识每前进一步，都是对无限发展着的物质世界的接近，这一点也是绝对的、无条件的 真理的相对性 人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限度的、不完善的 任何真理都是对一部分事物的正确认识 认识有待深化，真理是有限度的 二者关系 辩证统一 二者相互依存 二者互相包含 无数相对的真理之总和就是绝对的真理 真理永远处于由相对向绝对的转化和发展中，是从真理的相对性走向绝对性、接近绝对性的过程 任何真理性的认识都是由真理的相对性向绝对性转化过程中的一个环节，这是真理发展的规律 源于人认识世界的能力的无限性与有限性、绝对性与相对性之间的矛盾 真理与谬误 谬误 是同客观事物及其发展规律相违背的认识，是对客观事物及其发展规律的歪曲反映 一对永恒矛盾，既对立又统一 相互对立 对立是相对的，它们在一定条件下能够相互转化 真理的检验标准 实践是检验真理的唯一标准 由真理的本性与实践的特点决定的 从真理的本性看，真理是人们对客观事物及其发展规律的正确反映，它的本性在于主观与客观相符合 从实践的特点看，实践是人们改造世界的客观的物质性活动，具有直接现实性的特点 真理与价值的辩证统一 价值 指在实践基础上形成的主体与客体之间的一一关系，是客体对个人、群体乃至整个社会的生活和活动所具有的积极意义 基本特性 主体性 客观性 多维性 社会历史性 价值评价及其特点 价值评价 主体对客体的价值以及价值大小所作的评判或判断，因而也被称作价值判断 基本特点 评价以主客体的价值关系为认识对象 评价结果与评价主体直接相关 评价结果的正确与否依赖于对客体状况和主体需要的认识 在实践中的辩证统一 真理尺度 在实践中人们必须遵循正确反映客观事物本质和规律的真理 真理与价值或真理尺度与价值尺度是紧密联系、不可分割的辩证统一关系","categories":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}],"tags":[{"name":"马原","slug":"马原","permalink":"https://fallensue.cc/tags/马原/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}]},{"title":"导论","slug":"导论","date":"2020-12-16T01:51:58.000Z","updated":"2020-12-16T01:14:08.686Z","comments":true,"path":"posts/ee59981a.html","link":"","permalink":"https://fallensue.cc/posts/ee59981a.html","excerpt":"","text":"导论马克思主义的创立与发展什么是马克思主义（了解即可） 是由马克思和恩格斯创立并为后继者所不断发展的科学理论体系（内涵） 是关于自然、社会和人类思维发展一般规律的学说，是关于社会主义必然替代资本主义、最终实现共产主义的学说（内容） 是关于无产阶级解放、全人类解放和每个人自由而全面发展的学说（目的） 是指引人民创造美好生活的指南（立场） 马克思主义的构成（三个基本组成部分）（了解即可） 马克思主义哲学 马克思主义政治经济学 科学社会主义 基本立场（选择题） 以无产阶级的解放和全人类的解放为己任，以人的全面自由发展为美好目标，以人民为中心，一切为民，一切靠民 基本观点（选择题） 是关于自然、社会和人类思维发展一般规律的科学认识 是对人类思想成果和社会实践经验的科学总结 基本方法（看看就好） 建立在辩证唯物主义和历史唯物主义世界观和方法论基础上 实事求是的方法 辩证分析的方法 社会基本矛盾和主要矛盾分析的方法 历史分析的方法 阶级分析的方法 群众路线的方法 马克思主义的创立 社会根源 资本主义生产方式已经在西欧有了相当的发展 阶级基础 无产阶级在反抗资产阶级剥削与压迫的斗争中，逐步走向自觉，并迫切渴望科学的理论指导 思想渊源 德国古典哲学 英国古典政治经济学 英法两国的空想社会主义 标志 1848年《共产党宣言》的发表，马克思主义公开问世 马克思两个伟大发现 唯物史观 剩余价值学说 马克思主义的鲜明特征具有鲜明的 科学性（独有） 对自然、社会和人类思维发展本质和规律的正确反映（解释） 科学的世界观与方法论基础（理论优势，重要体现） 辩证唯物主义 历史唯物主义 革命性 集中表现 彻底的批判精神 鲜明的无产阶级立场 实践性（独有，区别于其他理论的显著特征） 从实践中来，到实践中去，在实践中接受检验，随实践不断发展的学说。 实践观点是马克思主义首要的和基本的观点（重要） 人民性 人民至上是马克思主义的政治立场 马克思主义的人民性事以阶级性为深刻基础的，是无产阶级先进性的体现 发展性 是不断发展的学说 具有与时俱进的理论品质 马克思主义的当代价值（不怎么考，看个乐子）观察当代世界变化的认识工具指引当代中国发展的行动指南引领人类社会进步的科学真理","categories":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}],"tags":[{"name":"马原","slug":"马原","permalink":"https://fallensue.cc/tags/马原/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}]},{"title":"人类社会及其发展规律","slug":"人类社会及其发展规律","date":"2020-12-16T00:51:58.000Z","updated":"2020-12-16T01:14:08.684Z","comments":true,"path":"posts/853d5c4.html","link":"","permalink":"https://fallensue.cc/posts/853d5c4.html","excerpt":"","text":"人类社会及其发展规律社会基本矛盾及其运动规律社会存在与社会意识 关系问题是社会历史观的基本问题 社会存在 社会生活的物质方面 自然 人口 生产方式 社会意识 社会生活的精神方面，社会存在的反映 意识形态 政治法律思想是随着阶级和国家的出现而产生的，是最直接、最集中反映经济基础的意识形态，在意识形态居于核心地位，起主导作用 非意识形态 辩证关系 二者是辩证统一的 社会存在决定社会意识 社会意识是社会存在的反映，并反作用于社会存在 社会存在是社会意识内容的客观来源 社会意识是社会物质生活过程及其条件的主观反映 社会意识的相对独立性 社会意识与社会存在发展的不完全同步性和不平衡性 社会意识内部各种形式之间的相互影响以及各自具有的历史继承性 社会意识对社会存在能动的反作用 在对待社会历史发展及其规律问题上，有两种根本对立的观点 唯物史观 唯心史观 生产力与生产关系的矛盾运动及其规律 人类社会发展的基本规律 生产力与生产关系 生产力 是人类在生产实践中形成的改造和影响自然以使其适合社会需要的物质力量 是人类社会生活和全部历史的基础 生产关系 是人们在物质生产过程中形成的不以人的意志为转移的经济关系 是社会关系中最基本的关系 ✨生产资料所有制关系(最为基本) 区分不同生产方式、判定社会经济结构性质的客观依据 生产中人与人的关系 产品分配关系 社会生产中二者不可分割 生产力决定生产关系 生产关系反作用于生产力 生产关系对生产力具有能动的反作用 ✨生产关系一定要适合生产力状况的规律是社会形态发展的普遍规律 社会主义的根本任务是解放和发展社会生产力 经济基础与上层建筑的矛盾运动及其规律 经济基础与上层建筑矛盾运动的规律，是人类社会发展的另一个基本规律 经济基础 由社会一定发展阶段的生产力所决定的生产关系的总和 上层建筑 建立在一定经济基础之上的意识形态以及与之相应的制度、组织和设施 意识形态又被叫做观念上层建筑 政治上层建筑居主导地位，国家政权是核心 经济基础与上层建筑是辩证统一的 经济基础决定上层建筑 上层建筑对经济基础具有反作用 经济基础与上层建筑的相互作用构成二者的矛盾运动 经济基础和上层建筑之间的内在联系构成了上层建筑一定要适合经济基础状况的规律 社会形态更替的一般规律及特殊形式 社会形态 关于社会运动的具体形式、发展阶段和不同质态的范畴 同生产力发展一定阶段相适应的经济基础与上层建筑的统一体 包括社会的经济形态、政治形态和意识形态，是三者历史的、具体的统一 更替的统一性与多样性，根源于社会发展的客观必然性与人们的历史选择性相统一的过程 更替表现为历史的前进性与曲折性、顺序性与跨越性的统一 社会历史发展的动力生产力和生产关系、经济基础与上层建筑的矛盾是社会基本矛盾社会基本矛盾是历史发展的根本动力，在历史发展中的作用 生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展与进步的最终决定力量 生产力是社会进步的根本内容，是衡量社会进步的根本尺度 社会基本矛盾特别是生产力和生产关系的矛盾，决定着社会中其他矛盾的存在和发展 经济基础与上层建筑的矛盾也会影响和制约生产力和生产关系的矛盾 社会基本矛盾具有不同的表现形式和解决方式，并从根本上影响和促进社会形态的变化和发展 阶级斗争是阶级社会发展的直接动力社会革命是实现社会形态更替的重要手段和决定性环节改革是同一种社会形态发展过程中的量变和部分之变，是推动社会发展的又一重要动力科学技术作为先进生产力的重要标志，对于推动社会发展有着非常重要的作用 对生产方式产生了深刻影响 对生活方式产生了巨大影响 促进了思维方式的变革 人民群众在历史发展中的作用人民群众是历史的创造者人民群众在创造历史过程中的决定作用 人民群众是社会历史的主体，是历史的创造者，这是马克思主义最基本的观点之一 人民群众是社会物质财富的创造者 人民群众是社会精神财富的创造者 人民群众是社会变革的决定性力量 群众路线 是我党的生命线和根本工作路线，也是我们党的优良传统 是群众观点的具体应用，即一切为了群众，一切依靠群众，从群众中来，到群众中去","categories":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}],"tags":[{"name":"马原","slug":"马原","permalink":"https://fallensue.cc/tags/马原/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}]},{"title":"数据结构排序","slug":"数据结构排序","date":"2020-12-14T02:34:15.000Z","updated":"2020-12-14T14:08:32.574Z","comments":true,"path":"posts/57ab72d4.html","link":"","permalink":"https://fallensue.cc/posts/57ab72d4.html","excerpt":"","text":"冒泡排序(Bubble Sort)特点：最简单的排序算法，重复的遍历若干次要排序的数列，每次遍历的时候都会从前往后依次的比较两个相邻数据的大小；如果前者比后者大，那么就会交换它们的位置。这样一来，经过一次遍历之后，最大的元素就会在数列末尾；采用同样的方法再一次遍历后，第二大的元素就会被排序在最大元素之前。重复这个操作直到整个数列均有序。 第一种实现方法： void bubble_sort1(int a[], int n) { int i,j,temp; for (i=n-1; i&gt;0; i--) { // 将a[0...i]中最大的数据放在末尾 for (j=0; j&lt;i; j++) { if (a[j] &gt; a[j+1]){ temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; } } } } 但是这种方法效率不高，我们添加一个标记位用于判断一次遍历中是否发生交换，如果没有发生交换，则排序完成！ 第二种实现方法： void bubble_sort2(int a[], int n) { int i, j, temp; int flag; // 标记 for (i = n - 1; i &gt; 0; i--) { flag = 0; // 初始化标记为0 // 将a[0...i]中最大的数据放在末尾 for (j = 0; j &lt; i; j++) { if (a[j] &gt; a[j+1]) { temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; flag = 1; // 若发生交换，则设标记为1 } } if (flag == 0) break; // 若没发生交换，则说明数列已有序。 } } 时间复杂度：时间复杂度为O(n^2)，假设参与排序的数列中有n个数。遍历一趟的时间复杂度为O(n)，需要遍历N-1次，因此时间复杂度为O(n^2). 稳定性：冒泡排序是稳定的算法，它满足稳定算法的定义。算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！ 直接插入排序(Straight Insertion Sort)特点：简单直观的排序算法，工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并完成插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因此在从后向前扫描过程中，需要反复将已排序元素逐步向后挪位，为最新元素提供插入空间 举一个简单易懂或许的例子，打扑克牌大家应该都玩过，如果桌子上的扑克牌排序是{7,3,6,4,5,8}，很明显这是顺子。我们拿起第一张7，之后手里的牌就是{7}；拿起第二张3，3比7小，放在前边,手里的牌是{3,7}；拿起第三张6，6比3大但比7小，放在中间，手里的牌是{3,6,7}；依次类推，插入排序就是这么个原理。 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 C代码实现： void Insertion_sort(int arr[],int len){ int i,j,key; //i=1是因为我们认为第一个元素已经被排序 for(i=1;i &lt; len;i++){ key = arr[i];//取出下一个元素 j = i - 1; //如果已排序元素大于新元素，将元素移到下一个位置 while((j &gt;= 0) &amp;&amp; (arr[j] &gt; key)){ arr[j+1] = arr[j]; j--; } //找到已排序的元素小于或者等于新元素的位置 //将新元素插入到该位置之后 arr[j+1] = key; } } 时间复杂度：O(n^2)，假设被排列的数列中有n个数，遍历一趟的时间复杂度为O(n),需要遍历n-1次。 最好情况：序列已经是升序排列的序列，这种情况下，比较操作只需要n-1次即可。 最坏情况：序列是降序排列，那么一共需要进行n(n-1)/2次。插入排序不太适合对于数据量比较大的排序应用 稳定性：稳定的排序算法 算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！ 希尔排序（Shell Sort）特点：插入排序的更高效的改进版本。又被称作缩小增量排序 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 希尔排序实质上是一种分组插入方法。它的基本思想是：对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。 例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样： 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 然后我们对每一列进行排序 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序： 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 排序之后变为： 10 14 13 25 23 33 27 25 59 39 65 73 45 94 82 94 最后以1步长进行排序（此时就是简单的插入排序了）。 代码实现： void shell_sort(int arr[], int len) { int gap, i, j; int temp; //gap为步长，每次减为原来的一半 for (gap = len/2; gap &gt; 0; gap /= 2) //一共有gap个组，对每一组均执行直接插入排序 //i:代表即将插入的元素角标，作为每一组比较数据的最后一个元素角标 //j:代表与i同一组的数组元素角标 for (i = gap; i &lt; len; i++) { //此处减是防止数组角标越界 for (j = i - gap; j &gt;= 0; j -= gap) //j+gap代表即将插入元素所在的角标 //符合条件，插入元素（交换位置） if(arr[j]&gt;arr[j+gap]){ temp = arr[j]; arr[j] = arr[j+gap]; arr[j+gap] = temp; } } } 时间复杂度：希尔排序的时间复杂度与增量(即，步长gap)的选取有关。例如，当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为O(n²)，而Hibbard增量的希尔排序的时间复杂度为O(n^3/2)。 稳定性：不稳定算法 算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！ 选择排序(Selection Sort)特点：选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 算法描述： n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 代码实现： /* * 选择排序 * * 参数说明： * a -- 待排序的数组 * n -- 数组的长度 */ void select_sort(int a[], int n) { int i; // 有序区的末尾位置 int j; // 无序区的起始位置 int min; // 无序区中最小元素位置 for(i=0; i&lt;n-1; i++) { min=i; // 找出&quot;a[i+1] ... a[n]&quot;之间的最小元素，并赋值给min。 for(j=i+1; j&lt;n; j++) { if(a[j] &lt; a[min]) min=j; } // 若min!=i，则交换 a[i] 和 a[min]。 // 交换之后，保证了a[0] ... a[i] 之间的元素是有序的。 if(min != i){ int temp = a[min]; a[min] = a[i]; a[i] = temp; } } } 时间复杂度：O(n²)，假设要被排列的数列中有n个数，遍历一遍的时间复杂度为O(n)，一共要遍历n-1次。 稳定性：稳定算法 算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！ 堆排序(Heap Sort)特点：堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。 若以升序排序说明，把数组转换成最大堆(Max-Heap Heap)，这是一种满足最大堆性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。 重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆维持最大堆性质。 堆结点的访问：通常堆是通过一维数组来实现的。在数组起始位置为0的情形中： 父节点i的左子节点在位置(2i+1) 父节点i的左子节点在位置(2i+2) 子节点i的父节点在位置floor((i-1)/2) 堆的操作： 在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作： 最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点 创建最大堆（Build Max Heap）：将堆中的所有数据重新排序 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 代码实现(C): #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; /* * (最大)堆的向下调整算法 * * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。 * 其中，N为数组下标索引值，如数组中第1个数对应的N为0。 * * 参数说明： * a -- 待排序的数组 * start -- 被下调节点的起始位置(一般为0，表示从第1个开始) * end -- 截至范围(一般为数组中最后一个元素的索引) */ void maxHeapDown(int* a, int start, int end) { int dad = start; // 父节点的位置 int lchild = 2*dad + 1; // 左(left)孩子的位置 int tmp = a[dad]; // 父节点的大小 //子结点指标在范围内才考虑比较 while(lchild&lt;=end){ //先比较两个子结点大小，选择最大的一个 if(lchild+1&lt;=end&amp;&amp;a[lchild]&lt;a[lchild+1]) lchild++; //如果父节点大于子结点则调整完毕，直接跳出 if(a[dad]&gt;a[lchild]) return; //否则交换父子内容继续子节点与孙节点比较 else{ a[dad] = a[lchild]; a[lchild] = temp; dad = lchild; lchild = dad*2+1; } } } /* * 堆排序(从小到大) * * 参数说明： * a -- 待排序的数组 * n -- 数组的长度 */ void heapSortAsc(int* a, int n) { int i,tmp; // 从(n/2-1) --&gt; 0逐次遍历。遍历之后，得到的数组实际上是一个(最大)二叉堆。 for (i = n / 2 - 1; i &gt;= 0; i--) maxHeapDown(a, i, n-1); // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素 for (i = n - 1; i &gt; 0; i--) { // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最大的。 tmp = a[0]; a[0] = a[i]; a[i] = tmp; // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最大堆。 // 即，保证a[i-1]是a[0...i-1]中的最大值。 maxHeapDown(a, 0, i-1); } } 时间复杂度：堆排序的时间复杂度是O(nlog₂n)。假设被排序的数列中有n个数。遍历一趟的时间复杂度是O(n)，需要遍历多少次呢？堆排序是采用的二叉堆进行排序的，二叉堆就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是log₂(n+1)。最多是多少呢？由于二叉堆是完全二叉树，因此，它的深度最多也不会超过log₂(2n)。因此，遍历一趟的时间复杂度是O(n)，而遍历次数介于log₂(n+1)和log₂(2n)之间；因此得出它的时间复杂度是O(nlog₂n)。 稳定性：堆排序是不稳定的算法，它不满足稳定算法的定义。它在交换数据的时候，是比较父结点和子节点之间的数据，所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化。算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！ 快速排序(Quick Sort)特点：又被称作“快排”、分区交换排序。采用分治策略，基本思想：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分所有数据比另一部分所有数据小。然后，再按此方法对这两部分数据再次分别进行快速排序（递归），直至整个数据变成有序序列 算法流程： 从数列中挑出一个基准值 将所有比基准值小的放在基准值的前面，比基准值大的放在后面（相同数随意），完成之后这个基准便处于数列的中间位置。 递归排序基准值前面的子数列与后面的子数列 代码实现(C): /* * 快速排序 * * 参数说明： * a -- 待排序的数组 * l -- 数组的左边界(例如，从起始位置开始排序，则l=0) * r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1) */ void quick_sort(int a[], int l, int r) { if (l &lt; r) { int i,j,x; i = l; j = r; x = a[i]; while (i &lt; j) { while(i &lt; j &amp;&amp; a[j] &gt; x) j--; // 从右向左找第一个小于x的数 if(i &lt; j) a[i++] = a[j]; while(i &lt; j &amp;&amp; a[i] &lt; x) i++; // 从左向右找第一个大于x的数 if(i &lt; j) a[j--] = a[i]; } a[i] = x; quick_sort(a, l, i-1); /* 递归调用 */ quick_sort(a, i+1, r); /* 递归调用 */ } } 时间复杂度：快速排序的时间复杂度在最坏情况下是O(n²)，平均的时间复杂度是O(n*log₂n)。这句话很好理解：假设被排序的数列中有N个数。遍历一次的时间复杂度是O(n)，需要遍历多少次呢？至少log₂(n+1)次，最多n次。(01) 为什么最少是log₂(N+1)次？快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是log₂(n+1)。因此，快速排序的遍历次数最少是log₂(n+1)次。(02) 为什么最多是n次？这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是n。因此，快读排序的遍历次数最多是n次。 稳定性：不稳定的算法，不满足稳定算法的定义 算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"leetcode链表题解(简单)","slug":"leetcode链表题解(简单)","date":"2020-12-09T14:16:13.000Z","updated":"2020-12-09T13:35:32.333Z","comments":true,"path":"posts/f442ae61.html","link":"","permalink":"https://fallensue.cc/posts/f442ae61.html","excerpt":"","text":"前言这一学期专业课添加了数据结构，学分还挺高，期中过后便刷了几道leetcode的题目，收获颇丰,虽然都是些简单的题目。但还是写点题解吧，期末快到了，数据结构还是第一科，权当做个小复习，此处题解均为leetcode中的链表的简单题目部分 链表面试题 02.03. 删除中间节点实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。 示例： 输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f 这一题其实考的是链表的结构特性，我们知道链表一个结点由数据域与指针域表示，如果要删除某个结点，那么肯定需要改变指针域和数据域。 我们只需要将结点c指向的下一个结点的值赋给结点c，即目前可以看作是a-&gt;b-&gt;d-&gt;d-&gt;e-&gt;f，这时候相当于有两个结点d，我们怎么删除它呢？ 我们只需要将结点c(此时值为d)的next指针指向结点e即可，由于是单向链表，所以此时相当于删除了结点c。 C++代码： /** * Definition for singly-linked list. * struct ListNode { * int data; * ListNode *next; * ListNode(int x) : data(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { node-&gt;data = node-&gt;next-&gt;data; node-&gt;next = node-&gt;next-&gt;next; } }; 237. 删除链表中的节点跟上道题是一摸一样的，自己看吧 1290. 二进制链表转整数给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。 请你返回该链表所表示数字的 十进制值 。 不断左移相或就完事了 C++代码如下: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: int getDecimalValue(ListNode* head) { int res = 0; while(head){ res = res | head-&gt;val; if(head-&gt;next) res&lt;&lt;=1; head = head-&gt;next; } return res; } }; 剑指 Offer 22. 链表中倒数第k个节点输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5. 这道题直接使用双指针，不过你先遍历一次链表的长度n，再用指针走(n-k)步也无伤大雅。先初始化一个快的指针fast,然后再初始化一个慢的指针slow分别指向头指针，然后先让fast走k步，slow才走，这样只要链表长度大于k，fast永远比slow多走k步。当fast走到链表结尾n时，slow恰好处于倒数第k个结点的位置，直接返回即可。 C++代码示例: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* getKthFromEnd(ListNode* head, int k) { if(k&lt;0||head == NULL) return NULL; ListNode* fast = head; ListNode* slow = head; for(int i = 0;i&lt;k-1;i++){ if(fast-&gt;next){ fast = fast-&gt;next; } else{ return NULL; } } while(fast-&gt;next){ slow = slow-&gt;next; fast = fast-&gt;next; } return slow; } }; 剑指 Offer 06. 从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 这里有两种解法，一个递归，一个非递归 递归：如果头指针是空的，那么返回空。然后开始递归。一直走到链表末尾然后反过来一个个push_back()，成功 class Solution { public: vector&lt;int&gt; reversePrint(ListNode* head) { if(!head) return {}; vector&lt;int&gt; a=reversePrint(head-&gt;next); a.push_back(head-&gt;val); return a; } }; 非递归： 先计算长度然后一个个插入 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: vector&lt;int&gt; reversePrint(ListNode* head) { const ListNode* node = head; std::size_t count = 0; while (node != nullptr) { ++count; node = node-&gt;next; } std::vector&lt;int&gt; nums(count); node = head; for (auto i = nums.rbegin(); i != nums.rend(); ++i) { *i = node-&gt;val; node = node-&gt;next; } return nums; } }; 剑指 Offer 24. 反转链表定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 还是我们可爱的双指针同学，直接定义两个指针pre与cur,pre在前面,cur在后面。 每次都让pre的next指向cur，这样相当于一次反转 反转完后两个指针都往前移动一个位置 循环上述过程直至pre到达了链表的尾部 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* cur = NULL, *pre = head; while (pre != NULL) { ListNode* t = pre-&gt;next; pre-&gt;next = cur; cur = pre; pre = t; } return cur; } }; 876. 链表的中间结点给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 先遍历遍算表长，然后求得中间值，再走一遍完事 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* middleNode(ListNode* head) { ListNode* cut=head; int num=0; while(cut){ cut = cut-&gt;next; num++; } int k=0; cut=head; while(k&lt;num/2){ cut=cut-&gt;next; k++; } return cut; } }; 21. 合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 新建一个链表，然后逐个比较l1和l2中的值，谁小谁进去，然后当有一个为空了就插另一个 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* preHead = new ListNode(); ListNode* prev = preHead; while (l1 != nullptr &amp;&amp; l2 != nullptr) { if (l1-&gt;val &lt; l2-&gt;val) { prev-&gt;next = l1; l1 = l1-&gt;next; } else { prev-&gt;next = l2; l2 = l2-&gt;next; } prev = prev-&gt;next; } prev-&gt;next = l1 == nullptr ? l2 : l1; return preHead-&gt;next; } }; 剑指 Offer 52. 两个链表的第一个公共节点输入两个链表，找出它们的第一个公共节点。 如下面的两个链表： 在节点 c1 开始相交。 这道题十分的浪漫，其实真的很浪漫。原理相当于只要我们两个人最后会走一样的路，一定会在路的起点处牵手(没错这就是解题思路) 我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA的头结点。 这样，当它们相遇时，所指向的结点就是第一个公共结点。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode* pa=headA; ListNode* pb=headB; while(pa!=pb){ pa = pa !=NULL?pa-&gt;next : headB; pb = pb !=NULL?pb-&gt;next : headA; } return pa; } }; 删除链表的节点和上面的差不多……就是按照传的值删除，给你一个头指针和值来删除。 自己看代码吧，就是跟上面一个意思，只不过用了递归 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* deleteNode(ListNode* head, int val) { if(head==NULL){ return head; } if(head-&gt;val == val){ return head-&gt;next; } head-&gt;next = deleteNode(head-&gt;next,val); return head; } }; 83.删除排序链表中的重复元素给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&gt;1-&gt;2输出: 1-&gt;2 示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 怎么删除就不用说了吧，上面已经讲过了，还没理解的朋友们可以翻回去慢慢看，何况这还是个排序过的链表。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if(head==NULL||head-&gt;next==NULL){ return head; } ListNode*p=head; while(p-&gt;next!=NULL){ if(p-&gt;val == p-&gt;next-&gt;val){ p-&gt;next=p-&gt;next-&gt;next; } else{ p=p-&gt;next; } } return head; } }; 141.环形链表给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 解题思路：双指针，一个快一个慢，快的每次走两步，慢的走一步，如果有环那么就是追及相遇问题了。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(fast != nullptr &amp;&amp; fast-&gt;next != nullptr) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (fast == slow) { return true; } } return false; } }; 回文链表编写一个函数，检查输入的链表是否是回文的。 解题思路：双指针，一个快，一个慢，快2步，慢一步。快终点，慢中间，反转一半，开始比较 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool isPalindrome(ListNode* head) { ListNode* fast=head; ListNode* slow=head; while(fast&amp;&amp;fast-&gt;next){ fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; } ListNode* temp; ListNode* pre=NULL; while(slow!=NULL){ temp=slow-&gt;next; slow-&gt;next=pre; pre=slow; slow=temp; } while(pre!=NULL){ if((head-&gt;val)!=(pre-&gt;val)){return false;} head=head-&gt;next;pre=pre-&gt;next; } return true; } }; 移除链表元素删除链表中等于给定值val的所有结点 class Solution { public: //题解1：递归法 ListNode* removeElements_1(ListNode* head, int val) { //1、递归边界 if(!head)return nullptr; //2、递去：直到到达链表尾部才开始删除重复元素 head-&gt;next=removeElements(head-&gt;next,val); //3、递归式：相等就是删除head，不相等就不用删除 return head-&gt;val==val?head-&gt;next:head; } //题解2：迭代法 ListNode *removeElements(ListNode* head,int val){ if(!head)return nullptr; ListNode *cur=head,*del; //每次循环我们判断cur的next节点值是否为val，确定是否删除 while(cur-&gt;next){ if(cur-&gt;next-&gt;val==val){//若cur-&gt;next的节点值为val，那么我们需要删除cur-&gt;next del=cur-&gt;next; cur-&gt;next=del-&gt;next; delete del; } else{//若不为val，那么我们需要移动cur cur=cur-&gt;next; } } return head-&gt;val==val?head-&gt;next:head; } }; 大佬的题解在此","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://fallensue.cc/tags/leetcode/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构查找","slug":"数据结构查找","date":"2020-12-01T14:16:13.000Z","updated":"2020-12-07T13:12:54.891Z","comments":true,"path":"posts/c024d7ad.html","link":"","permalink":"https://fallensue.cc/posts/c024d7ad.html","excerpt":"","text":"顺序查找按一定的顺序检查数组中每一个元素，直到找到所要找的特定值为止 优点：十分简单 缺点：如果要寻找的特定值不在这个数组或者是数组里的最后一个元素，这就需要进行n次比较，浪费时间 设置哨兵：把要查找的值添加到数组的首位置或者最后一个位置，之后从添加的另一端开始逐个比较 算法C代码实现: int S_search(int S[],int key){ S[0] = key;/*哨兵*/ for(int i = n;S[i] != key;i--) return i;/*返回0或者是找到的位置*/ } 最好的时间复杂度:O(1) 最坏的时间复杂度:O(n) 平均查找次数:(n+1)/2 顺序查找一般用于数组以及链表 二分查找二分查找适用于有序的顺序表 基本思路： 首先找到表两个端点(最大值与最小值),分别记为high和low 求中间端点mid=[(low+high)/2]；如果key = array[mid],则查找成功 若key&lt;array[mid],则下一个查找范围设置成[low,mid-1] 若key&gt;array[mid],则下一个查找范围设置成[mid+1,high] 重复如上直到查找成功，但当low&gt;high时或者是根本不存在时查找失败 算法时间复杂度：O(logn)(n为表长) 算法C代码实现: /*递归实现*/ int binary_search(const int arr[], int start, int end, int khey) { if (start &gt; end) return -1; int mid = start + (end - start) / 2; //直接平均可能会溢位，所以用此算法 if (arr[mid] &gt; khey) return binary_search(arr, start, mid - 1, khey); else if (arr[mid] &lt; khey) return binary_search(arr, mid + 1, end, khey); else return mid; //最后检测相等是因为多数搜寻状况不是大于要不就小于 } /*while循环实现*/ int binary_search(const int arr[], int start, int end, int key) { int ret = -1; // 未搜索到数据返回-1下标 int mid; while (start &lt;= end) { mid = start + (end - start) / 2; //直接平均可能会溢位，所以用此算法 if (arr[mid] &lt; key) start = mid + 1; else if (arr[mid] &gt; key) end = mid - 1; else { // 最后检测相等是为多数搜寻状况不是大于要不就小于 ret = mid; break; } } return ret; // 单一出口 } 索引查找将一个搜索列表R[n]分成b个子列表。每个子列表可以不按数据大小排序，但是前子列表中的最大数据必须低于下一个后继列表中的最小数据。 建立一个索引表ID[b].ID[i]存储的是第i个表中的最大数据，索引表ID[b]是一个有序表 查找方法： 在ID[]中查找确定可能需要的子列表(二分查找或顺序查找均可) 在ID[k]中查找只能用顺序查找 二叉查找树二叉查找树（Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(logn). 中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以透过建构一棵二叉查找树变成一个有序序列，建构树的过程即为对无序序列进行查找的过程。 每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。 搜索、插入、删除的复杂度等于树高，期望O(logn)，最坏O(n)（数列有序，树退化成线性表）。 查找算法在二叉查找树b中要查找一个值x的过程为: 如果b是空树，则查找失败，否则: 若是x等于b的根节点的数据域的值，则查找成功；否则： 若是x小于b的根节点的数据域的值，则在左子树中查找；否则在右子树中查找 Status SearchBST(BiTree T, KeyType key, BiTree f, BiTree &amp;p) { /*在根指针T所指二叉查找树中递归地查找其关键字等于key的数据元素，若查找成功，则指针p指向该数据元素结点，并返回TRUE，否則指针指向查找路径上访问的最后一个节点并返回FALSE，指针f指向T的双亲，其初始调用值为NULL*/ if (!T) { // 查找不成功 p = f; return false; } else if (key == T-&gt;data.key) { // 查找成功 p = T; return true; } else if (key &lt; T-&gt;data.key) // 在左子树中继续查找 return SearchBST(T-&gt;lchild, key, T, p); else // 在右子樹中继续查找 return SearchBST(T-&gt;rchild, key, T, p); } 插入算法向一个二叉查找树b中插入一个节点s的算法，过程为： 若b是空树，则将s所指节点作为根节点插入，否则： 若s-&gt;data等于b的根节点的数据域之值，则返回，否则： 若s-&gt;data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则把s所指节点插入到右子树中。（新插入节点总是叶子节点） /* 当二叉查找树T中不存在关键字等于e.key的数据元素时，插入e并返回TRUE，否则返回 FALSE */ Status InsertBST(BiTree *&amp;T, ElemType e) { if (!T) { s = new BiTNode; s-&gt;data = e; s-&gt;lchild = s-&gt;rchild = NULL; T = s; // 被插节点*s为新的根结点 } else if (e.key == T-&gt;data.key) return false;// 关键字等于e.key的数据元素，返回错误 if (e.key &lt; T-&gt;data.key) InsertBST(T-&gt;lchild, e); // 将e插入左子树 else InsertBST(T-&gt;rchild, e); // 将e插入右子树 return true; } 删除算法在二叉查找树删去一个结点，分三种情况讨论： 若*p结点为叶子结点，即PL（左子树）和PR（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。 若p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点f的左子树（当p是左子树）或右子树（当p是右子树）即可，作此修改也不破坏二叉查找树的特性。 若p结点的左子树和右子树均不空。在删去p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整，可以有两种做法：其一是令p的左子树为f的左/右（依p是f的左子树还是右子树而定）子树，s为p左子树的最右下的结点，而p的右子树为s的右子树；其二是令p的直接前驱（in-order predecessor）或直接后继（in-order successor）替代p，然后再从二叉查找树中删去它的直接前驱（或直接后继）。 //第一种算法删除元素 void deleteNode1(BSTree &amp;p){ BSTree q,s; if(!p-&gt;lchild){ //如果左子树为空，则只需重接其右子树 //这里包含了左右子树均为空的情况 q=p; p=p-&gt;rchild; free(q); } else if(!p-&gt;rchild){ //如果右子树为空，则只需重接其左子树 q = p; p=p-&gt;lchild; free(q); } else{ //如果左右子树均不为空，我们采用第一种方法来重接 //我们修改左子树，也可以修改右子树，效果类似 s=p-&gt;lchild; //取待删结点的左节点 //一直向右，直到s为待删结点的前驱节点 //如果将各个元素按从小到大的顺序排列 //如果将各节点元素按从小到大顺序排列成一个序列， //则某节点的前驱节点即为序列中该节点的前面一个节点 while(s-&gt;rchild) s = s-&gt;rchild; s-&gt;rchild = p-&gt;rchild; //将p的右子树接为s的右子树 q = p; p = p-&gt;lchild; //将p的左子树直接接到其父节点的左子树上 free(q); } } //第二种算法删除元素 void deleteNode2(BSTree &amp;p) { BSTree q,s; if(!p-&gt;lchild) { //如果左子树为空，则只需重接其右子树 //这里包含了左右子树均为空的情况 q = p; p = p-&gt;rchild ; free(q); } else if(!p-&gt;rchild) { //如果右子树为空，则只需重接其左子树 q = p; p = p-&gt;lchild; free(q); } else { //如果左右子树都不为空，我们采取第二种方法来重接左右子树， //我们这里采取修改左子树的方法，也可以修改右子树，方法类似 q = p; s = p-&gt;lchild; //取待删节点的左节点 while(s-&gt;rchild) { //一直向右，最终s为待删节点的前驱节点。 //如果将各节点元素按从小到大顺序排列成一个序列， //则某节点的前驱节点即为序列中该节点的前面一个节点 q = s; s = s-&gt;rchild; } //用s来替换待删节点p p-&gt;data = s-&gt;data; //根据情况，将s的左子树重接到q上 if(p != q) q-&gt;rchild = s-&gt;lchild; else q-&gt;lchild = s-&gt;lchild; free(s); } } /* 若pTree所指向的二叉排序树中查找到关键字为key的数据元素， 则删除该元素对应的节点，并返回true，否则返回false 如果要删除的恰好是根节点，则会改变根节点的值，因此要传入引用 */ bool deleteBSTree(BSTree &amp;pTree,int key) { //不存在关键字为key的节点 if(!pTree) return false; else { if(key == pTree-&gt;data) //查找到关键字为key的节点 { deleteNode1(pTree); // deleteNode2(pTree); return true; } else if(key &lt; pTree-&gt;data) //继续查找左子树 return deleteBSTree(pTree-&gt;lchild,key); else //继续查找右子树 return deleteBSTree(pTree-&gt;rchild,key); } 二叉判定树的画法思路分析：由于在计算mid值的时候，使用的mid=(low+high)/2。这里因为mid为int类型，所以向下取整。因此对一个长度为n的序列进行划分之后的序列为(0,1,2,……,mid-1) mid (mid+1,mid+2,……n-1)。这时候会发生两种情况： 左边长度=右边长度(n=2m+1,m∈Z) 左边长度=右边长度-1(n=2m,m∈Z) 所以由此得知，折半查找的二叉判定树对于所有结点，左子树的结点个数&lt;=右子树的结点的个数.即： 若某个序列总长度n为奇数,左右子树结点的个数相等 若某个序列总长度n为偶数，左子树个数=右子树结点的个数-1 所以对于一个给定的序列，构建折半查找的判定树一共有以下几步： 按照二叉树每层最大结点数为2^（h-1）依次由上至下构建满二叉树至最底层不够形成满二叉树为止。 根据上述规律再将剩下的结点逐个插入最底层 按照中序遍历的顺序依次填入各结点值 具体的例子如下： 画出对长度为10的有序表进行折半查找的判定树，并求其等概率时查找成功的平均查找长度。表的关键字序列为 1,2,3,4,5,6,7,8,9,10 (1) 序列总长度为10&gt;2^3-1，二叉判定树为4层，但是第四层不满 (2) 剩余三个结点。当第四层有一个叶结点时，结点总数n=8为偶数，因此对于a来说，应加在a的右子树，即c的子树中；对于c来说，结点总数n=4为偶数，应加在c的右子树中，即g的子树中；对于g来说，结点总数n=2为偶数，应加在g的右子树，即 （3）在第四层加入第二个结点时，结点总数n=9为奇数，因此对于a来说，应加在a的左子树使左右子树结点个数相等，即加在b的子树中；对于b来说，结点总数n=4为偶数，应加在b的右子树，即e的子树中；对于e来说，结点总数n=2为偶数，应加在e的右子树，即 (4) 同理分析，第三个结点应加在a的右孩子的左孩子的右子树，即 结束啦！ AVL树平衡二叉树平衡二叉树又被称为AVL树，具有以下性质：它是一棵空的树或它的左右两个子树的高度差的绝对值不超过1，并且两个子树均是一棵平衡二叉树 上图为一个AVL树 AVL树的平衡因子：节点x的平衡因子是x的左子树的高度减去它的右子树的高度。 AVL树中的每个节点的平衡因子为0,1或是-1 当往AVL树中插入一个节点之后，AVL树可能会不平衡，所以需要重新平衡 LL(右旋)LL的意思是向左子树（L）的左孩子（L）中插入新节点后导致不平衡，这种情况下需要右旋操作，而不是说LL的意思是右旋，后面的也是一样。 RR(左旋) LR(左右旋) RL(右左旋) 例子： 哈希表概念：来自于维基百科 散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表 根据上文得知，实际上哈希表的本质是一个数组。 一个通俗易懂的例子用于解释哈希表：我们假定你有一个电话簿，它的样子是下面这样的： 显然目前你要找到郭七，李八，王二这些人都是非常容易的，因为你的电话簿的页数不够多，所以你用顺序查找很快啊，就能够找着了。但是，问题来了，如果你社交广泛，人气出众。你的电话簿越来越厚，这时候你再想随便查找一个人名，若还是用顺序查找，未免也太累。 所以我们有一个办法，那就是把按照人名按照首字母顺序排列再创建一个表，如果这时候你再想查找“郭”姓的电话号码，你可以在首字母为G的表中找到它，显然比顺序查找不知道高到哪里去了。 这里我们将人名作为关键字，“取首字母”是这个例子中的散列函数的函数法则F()，存放首字母的表对应的是散列表。关键字与函数的法则理论上你想咋定就咋定。 如果一个关键字为k,那么它的值存放在f(k)的存储位置上。因此，不需要比较也能能够直接取得所查的记录。称这个对应关系f为散列(哈希)函数，根据这个函数建立成的表叫做散列(哈希)表 散列冲突：对于不同的关键字能够得到同一个散列地址，即k1≠k2,但是f(k1)=f(k2)。这种现象叫做冲突。怎么理解冲突呢？比方说上述电话簿已经存储了一个叫做王二的人，但是若我们要再向电话簿中插入一个叫做王三的人，那么由于W已经被王二占据，所以这时候王三进不去了，出现了冲突。具有相同函数值的关键字对该散列函数来说称作同义词。 散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快定位。 构造散列函数方法： 直接定址法：取关键字或关键字的某个线性函数值为散列地址。即hash(k)=k或hash(k)=ak+b，其中a,b为常数（这种散列函数叫做自身函数） 数字分析法：假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。 平方取中法：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。 折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。 随机数法:纯看运气 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即hash(k)=k mod p,p&lt;=m。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。 哈希冲突的解决方案：无论hash函数设计得再怎么巧妙，也永远避不开哈希冲突，解决冲突的方法以下几个比较常用。 开放定址法(open addressing):hash(i)=(hash(key)+d(i)) mod m, i = 1,2,…k(k≤m-1)。其中hash(key)为散列函数，m为散列表长，d(i)为增量序列，i为已经发生冲突的次数。增量序列可以如下取： d(i)=1,2,3,4…(m-1)称之为线性探测，即d(i)=i，或是其它的线性函数。相当于逐个探测存放地址的表，直到查找到一个空的单元，然后插入 d(i)=±1²,±2²,±3²,…±k²(k≤m/2)称之为平方探测。和线性探测差不多 d(i)=伪随机数序列，称为伪随机探测 链地址法 产生哈希冲突之后在存储数据之后加一个指针，指向后面冲突的数据，类似于链表","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"OS文件系统","slug":"OS文件系统","date":"2020-12-01T08:38:04.000Z","updated":"2020-12-01T13:45:35.715Z","comments":true,"path":"posts/129f2172.html","link":"","permalink":"https://fallensue.cc/posts/129f2172.html","excerpt":"","text":"文件概念：操作系统对存储设备的物理属性加以抽象，从而定义逻辑存储单位，即文件(file)，用户创建的数据集，连续的逻辑地址空间 对于用户来说，文件系统是操作系统中最重要的部分之一。 希望文件的属性： 长期存在(Long-term existence):文件存储在磁盘或其他辅助存储器上，并且在用户注销时不会消失 进程间共享(Sharable between processes):文件具有名称，并且可以具有允许受控共享的关联访问权限 结构(Structure):文件可以组织成层次结构或更复杂的结构，以反映文件之间的关系 文件类型： 数据：数字，字符，二进制 程序 文件信息由创建者定义，文件可以存储多种不同类型的信息，如源程序或者是可执行程序、数字或文本数据、照片balabala…… 文件管理系统提供服务给用户和应用程序使用的文件 用户或应用程序访问文件的方式 程序员不需要开发文件管理软件 目标: 满足用户的数据管理需求 确保文件中的数据都是有效的 性能优化 为各种存储设备类型提供I/O支持 尽量减少丢失或破坏数据 为用户进程提供一套标准化的I/O接口例程 为多个用户提供I/O支持(如果需要) 通用系统的要求： 每个用户都应该能够创建、删除、读、写和修改文件 每个用户都可以控制对其他用户文件的访问 每个用户可以控制对用户文件允许的访问类型 每个用户都应该能够以适合问题的形式重新构造用户文件 每个用户都应该能够在文件之间移动数据 每个用户都应该能够备份和恢复用户的文件，以防损坏 每个用户都应该能够通过使用符号化名称来访问用户的文件 文件属性基本信息文件名： 仅以人类可读形式保存的信息 由创建者(用户或程序)选择的名称。 在特定目录中必须是唯一的 标识： 唯一的标签(数字)识别文件系统中的文件 文件类型： 支持不同类型的系统需要 位置： 指向设备上文件位置的指针 尺寸： 当前文件的大小 文件组织： 用于支持不同组织的系统 保护： 控制谁能读，写，执行 时间、日期和用户标识： 数据保护、安全,和使用监控 关于文件的信息保存在目录结构中，它是在磁盘上维护的 地址信息Volume(卷组):指示存储文件的设备 起始地址 使用大小:文件的当前大小(以字节、字或块为单位) 分配内存大小:文件的最大大小 使用信息 创建日期 创造者的身份 最后一次读存取 最后一位读者的身份 最后修改日期 最后一个修饰符的标识 最后一次备份日期 当前使用情况 目录元素:访问控制信息雇主(Owner) 雇主可以批准/拒绝访问其他用户和改变这些特权 访问信息 可能包括每个授权用户的用户名称和密码 允许的行为 控制读，写，执行，传输通过网络 文件操作文件是一种抽象数据类型，所以为了正确定义文件，需要考虑可以对文件执行的操作。 创建文件： 首先，必须在文件系统中为该文件找到空间 其次，必须在目录中为新文件创建一个条目 写文件： 通过系统调用指定要写入的文件名和信息 搜索该目录以查找文件的位置 读文件： 在读指针位置读取 重新定位文件： 搜索目录以寻找适当的条目， 并且将当前文件位置指针重新定位到给定值 删除文件 截断文件 open(F):在磁盘上的目录结构中搜索条目F，并将条目的内容移动到内存中 close(F):将内存中入口F的内容移动到磁盘上的目录结构中 打开文件一些数据需要用于管理需要打开的文件 打开文件表：跟踪所有需要打开的文件 文件指针：指向打开文件的每个进程最后读/写位置的指针 文件打开计数：一个文件打开次数的计数器，当最后一个进程关闭它时，允许从打开的文件表中删除数据 文件的磁盘位置：在磁盘上找到文件所需的信息保存在内存中，以便系统不必在每次操作时都从磁盘读取它。 访问权限：每个进程采用访问模式打开文件。这种信息保存在进程的打开文件表中，因此操作系统可以允许或拒绝后续的I/O请求。 文件锁和读-写锁差不多，共享锁类似于读者锁，以便多个进程可以并发获取它。独占锁类似于写者锁；一次只有一个进程可以获得这样的锁 另外， 操作系统可以提供强制(mandatory) 或建议(advisory) 文件锁定机制。如果锁是强制性的， 则一旦进程获取独占锁， 操作系统就阻止任何其他进程访问锁定的文件。或者， 如果锁是建议性的， 则操作系统不会阻止访问。 Windows系统采用强制锁定,UNIX系统采用建议锁定 文件类型一般使用扩展名来确定文件类型和可用于文件操作的类型 文件结构无结构-字，字节的序列 简单的记录结构： 行 固定长度 可变长度 复杂结构： 格式化的文档 浮动加载文件 可以模拟最后两种与第一种方法插入适当的控制字符 文件结构由操作系统和程序决定 文件组织类型Pile(堆积) 最简单的文件组织类型 数据是按照它们到达的顺序被收集的 每条记录由一组数据组成 目的是简单地积累大量的数据并保存它 记录访问是通过穷举搜索 The Sequential File(顺序文件) 最常见的文件结构形式 记录使用固定格式 键字段唯一地标识记录 通常用于批处理应用程序 只有易于存储在磁带和磁盘上的组织 Indexed Sequential File(索引顺序文件) 向文件添加索引以支持随机访问 添加溢出文件 大大减少了访问单个记录所需的时间 可以使用多级索引来提高访问效率 索引文件(Indexed File) 只能通过索引访问记录 可以使用可变长度的记录 穷举索引为主文件中的每个记录包含一个条目 部分索引包含有关字段存在的记录条目 主要用于信息及时性至关重要的应用程序 例如航空公司预订系统和库存控制系统 直接或散列文件 直接访问已知地址的任意块 在键值上使用哈希 经常使用地点:快速访问是必需的,使用固定长度的记录,记录总是一次访问 文件组织标准重要的标准包括： 访问时间短 易于更新 经济的存储 维护简单 可靠 优先级会根据使用情况而有所不同(例如只读CD和硬盘) 有些甚至会产生冲突 访问文件的方法顺序访问(sequential access)最简单的访问方法，文件信息按照顺序(一个记录接一个记录进行处理)目前最常见，编辑器和编译器通常用这种方式访问文件 直接访问(direct access)另一种方法是直接访问(direct access) 或相对访问(relative access) 。这里，文件由固定长度的逻辑记录(logical records) 组成，以允许程序按任意顺序进行快速读取和写入记录。直接访问方法基于文件的磁盘模型， 因为磁盘允许对任何文件块的随机访问. 基于内容的访问(Content based access)根据字节的内容约束访问内容 文件使用模式大多数文件都很小，大多数引用也是针对小文件的 大文件会占用大部分的磁盘空间 大文件占用了内存和磁盘之间传输的大部分字节 对于文件系统设计人员来说，这是个坏消息 文件系统设计限制高性能的： 高效访问小文件：因为小文件经常使用而且还多 高效访问大文件：因为大文件占用大部分的磁盘空间，而且占数据移动的大部分 目录包含关于文件的信息： 属性 位置 所有权 目录本身是操作系统拥有的文件 提供文件名和文件本身之间的映射 目录结构包含所有文件信息的节点集合 目录结构和文件都驻留在磁盘上 目录上执行的操作一个目录系统应该支持许多操作，包括： 搜索文件 创建文件 删除文件 遍历目录 重命名文件 遍历文件系统 目录的简单结构存储以前信息的方法在不同的系统之间差别很大，最简单的是一个条目列表，每个文件一个 以文件名作为键的顺序文件 不提供组织文件的帮助 强制用户注意不要对两个不同的文件使用相同的名称 平面命名空间所有文件都存储在一个目录中 优点：易于实现 缺点：不能扩展到大型目录 命名冲突：多个文件使用相同的名字 单级目录为所有用户提供一个目录，所有文件包含于同一目录中 然而， 当文件数量增加或系统有多个用户时， 单级目录有重要的限制。因为所有文件位于同一目录中， 它们必须具有唯一的名称。 会导致分组问题和命名冲突 分层命名 使用多层目录 最流行的名称空间组织+概念模型映射到人类模型组织的事情，文件柜包含了许多文件 可扩展性：减少了名称冲突的概率 空间局部性：将所有文件存储在一个圆筒内的一个目录下，以避免磁盘查找 目录结构图： 更多关于分层命名： 绝对路径:包含从根目录‘/‘到文件的路径 例如:/pets/cat.jpg 路径解析： 读取根目录的文件头‘/’(存储在磁盘上的固定位置) 读取根目录的第一个数据块(查找宠物的目录条目) 读取宠物的文件头 读取宠物目录的第一个数据块(查找cat.jpg的目录条目) 读取cat.jpg的文件头 读取cat.jpg的数据块 工作目录声明完整的路径名和文件名是笨拙而乏味的 通常，交互式用户或进程与当前目录或工作目录相关联 除非使用显式的完整路径名，否则所有的文件名都是相对于工作目录引用的 文件系统挂载必须先挂载文件系统，然后才能访问它 卸载文件系统安装在一个挂载点(挂接点 文件共享共享可以通过保护计划来实现 在分布式系统上，文件可以在网络上共享 网络文件系统(NFS)是一种常见的分布式文件共享方法 在多用户系统中，允许文件在用户之间共享 有两个问题： 访问权限 同时访问的管理 多用户系统： 用户id标识用户，允许为每个用户提供权限和保护 组id允许用户分组，允许组访问权限 文件/目录的所有者 文件/目录的组 各种系统都使用了各种各样的访问权限 通常作为一个层次结构，其中一个右表示前面 不知道 用户也不知道文件是否存在 知道： 用户只能确定文件的存在及其所有者是谁 执行： 用户可以加载和执行一个程序，但不能复制它 读： 用户可以出于任何目的读取文件，包括复制和执行 附加： 用户可以向文件添加数据，但不能修改或删除文件的任何内容 更新： 用户可以修改、删除和添加文件的数据。 更改权限： 用户可以更改授予其他用户的访问权限 删除： 用户可以删除该文件 用户的结构所有者：通常是文件创建者，通常拥有完全的权利 特定用户：权利可以明确授予特定用户 用户组：标识为一个组的一组用户 全部：每个人 同时存取用户可以锁定整个文件时，它是更新 用户可以在更新期间锁定单个记录 互斥和死锁是共享访问的问题","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://fallensue.cc/tags/OS/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"OS大容量存储结构","slug":"OS大容量存储结构","date":"2020-12-01T07:32:26.000Z","updated":"2020-12-01T08:34:20.732Z","comments":true,"path":"posts/1b7af1c2.html","link":"","permalink":"https://fallensue.cc/posts/1b7af1c2.html","excerpt":"","text":"大容量存储结构磁盘为现代计算机系统提供大量外存，涂有可磁化材料，但是非磁性 数据通过读写磁头记录到磁盘，存储器可以直接存取 一个磁盘可以有多个盘片，盘片的两面均涂着磁性材料，可以保存信息 磁盘示意图如下： 性能参数磁盘的I/O操作取决于很多因素，下图为一般传输的时序图。 Seek time(寻道时间):移动磁臂到所需柱面的时间 Rotational Delay(旋转延迟):旋转磁臂到所要扇区的所需时间 假设一分钟7200转(RPM)，则一秒钟7200/60=120转。一转1/120 = 8ms，平均旋转延迟为4ms. Transfer time(传输时间):传输数据的时间，假设一个4Kb的磁盘,传输58Mbyte每毫秒,则传输一个块的时间为0.07毫秒 Disk access time(磁盘存取时间):Seek time(寻道时间) + rotational delay(旋转延迟) + transfer time(传输时间) 性能指标: 延迟:寻道时间+旋转延迟 带宽:字节传输/磁盘存取时间 磁盘调度先来先服务(FCFS)算法 优点:比较公平 缺点:不一定快，随机磁盘访问时效率极低 如果一个请求块的柱面顺序如下: 98,183,37,122,14,124,65,67 假设一开始磁头位于柱面53,则先移至98,再移至183,依次往下，磁头移动柱面总数为640 从122移到14再到124，说明这种调度有时不好用 调度如下图所示： 最短寻道时间优先(SSTF)算法选择处理距离当前磁头位置的最短寻道时间请求(最接近磁头位置的待处理请求) 优点:减少了寻道时间 缺点:可能导致饥饿 同上，给出调度示意图 本质上是一种最短作业优先调度，当等待时间长的时候就会出现饥饿，同样不是最优的算法 SCAN(扫描算法)调度对于扫描算法(SCAN algorithm)，磁臂从磁盘的一端开始，向另一端移动；在移过每个柱面时， 处理请求。当到达磁盘的另一端时， 磁头移动方向反转， 并继续处理。磁头连续来回扫描磁盘。SCAN算法有时称为电梯算法(elevator algorithm)， 因为磁头的行为就像大楼里面的电梯， 先处理所有向上的请求， 然后再处理相反方向的请求。 如果请求刚好在磁头前方加入队列， 则它几乎马上就会得到服务；如果请求刚好在磁头后方加入队列，则它必须等待，直到磁头移到磁盘的另一端，反转方向，并返回。 优点:没有饥饿 缺点:一个新的请求可能需要等待几乎两次完整的磁盘扫描 C-SCAN调度循环扫描(Circular SCAN, C-SCAN) 调度是SCAN 的一个变种， 以提供更均匀的等待时间。 像SCAN 一样， C-SCAN 移动磁头从磁盘一端到磁盘另一端， 并且处理行程上的请求。然而，当磁头到达另一端时， 它立即返回到磁盘的开头， 而并不处理任何回程上的请Q求。C-SCAN 调度算法基本上将这些柱面作为一个环链， 将最后柱面连到首个柱面。 LOOK调度正如以上所述， SCAN 和C-SCAN在磁盘的整个宽度内移动磁臂。实际上，这两种算法通常都不是按这种方式实施的。更常见的是，磁臂只需移到一个方向的最远请求为止。遵循这种模式的SCAN 算法和C-SCAN 算法分别称为LOOK 和C-LOOK 调度， 因为它们在向特定方向移动时查看是否会有请求。 磁盘调度算法的选择怎么选择最佳的磁盘调度算法？ SSTF:最常见,并且拥有自然的吸引力，因为它比FCFS有更好的性能。 对于磁盘负荷较大的系统,SCAN与C-SCAN表现更好，因为它们不太可能导致饥饿问题 对于任何调度算法，性能很大程度上取决于请求的数量以及类型。 文件分配方式可以大大的影响磁盘服务的请求 由于这些复杂因素，磁盘调度算法应该作为操作系统的一个单独模块，这样如果需要，可以用不同的算法来替换。SSTF或者是LOOK是默认算法的合理选择","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://fallensue.cc/tags/OS/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"OS同步死锁","slug":"OS同步死锁","date":"2020-12-01T07:06:00.000Z","updated":"2020-12-01T07:11:06.199Z","comments":true,"path":"posts/4141860d.html","link":"","permalink":"https://fallensue.cc/posts/4141860d.html","excerpt":"","text":"进程/线程同步抽象同步问题为解决: 竞争条件race condition:多个进程并发访问且要求修改同一个变量的情况 解决方法：保护临界区 临界区critical section:进程在执行某一段代码时可能涉及修改公共变量、读写内存表和文件的操作，则该代码段被称为临界区 因此，进程和线程代码必须通过设计来保护临界区，由此可以定义: 进入区entry section:进程在执行临界区代码前请求权限的代码段 退出区exit section:进程在结束临界区代码执行后释放权限的代码段 剩余区remainder section:进程在结束区后还要执行的其他代码 临界区问题解决原则: 互斥(mutual exclusion) :一旦有进程在临界区执行代码，那么任何进程不得进入临界区 进步(progress) :如果临界区没有进程在执行，则在执行完剩余区的进程中选择一个进程下一次进入临界区 有限等待(bound waiting) :不能使某个进程在进入区的请求无限被拒绝 在操作系统内核中即存在临界区问题，主要分为: 非抢占式内核non-preemptive kernel:内核模式的进程不允许被抢占，几乎没有竞争条件发生，但不适用于实时编程 抢占式内核preemptive kernel:内核模式的进程允许被抢占，内核响应更快，但需要更精密的策略来防止临界区问题 临界区问题解决方案：锁🔒(locking)方案一:软件锁为临界区设置布尔变量(锁)，并且每个进程都要有一个waiting变量, 只有这些所有变量都正确时进程才能进入临界区，进程退出时修改锁的布尔变量和自己的waiting变量 缺点:复杂，浪费时间和空间，无法封装为函数复用 总结：太傻了没人用系列 方案二：互斥锁(mutex)包括一个布尔变量available， 两个函数acquire()和release(): acquire(){ while (!available); /* busy wait */ available = false; } release(){ available= true; } /*临界区代码*/ do { acquire(lock) /*critical section*/ release(lock) /*remainder section*/ }while (true); 优点:进程等待时，无需上下文切换;简单容易实现 缺点:进程在进入区时要不断地调用acquire()请求权限， 这会导致忙碌等待(busy waiting): 忙碌等待: CPU一直在循环调用无用的函数，浪费其有效的处理周期 总结:可以适用于锁的使用时间较短，不会长时间等待时;适用于多核系统(一个核上在等待不会影响其他核 方案三:信号量(semaphore)为了防止忙碌等待,信号量策略会调度进程，让等待的进程进入中断 结构:一个整形变量s，一个参数链表，用来存放进程(的PCB) ; typedef struct{ int value; struct process *list; }semaphore, sem; //两个函数wait() [又称为P操作]、signa() [又称为v操作] wait(semaphore *S) { S-&gt;value-; if (S-&gt;value &lt; 0) { /*add this process to S-&gt;list*/ block(); } } signal(semaphore *S){ S-&gt;value++; if(S-&gt;value&lt;=0){ /*remove a process P from S-&gt;list*/ wakeup(P); } } //临界段代码 semaphore s =初始化值 do{ wait(S) /*critical section*/ signal(S) /*remainder section*/ }while (true); s可以是任意整数，此时称信号量为计数信号量 s只能为0或1,此时称信号量为二进制信号量，此时S类似于互斥锁 注意:因为wait和signal必须 原子进行，即在运行这两个函数时CPU不能中断，否则就可能有多个进程同时执行它们(换句话说，信号量的两个函数本身就是一个临界区问题) 在单核系统中，可以简单的不允许在执行它们时中断 但在多核系统(SMP) 中，这是做不到的，因此多核系统中执行wait和signal也要加锁,比如加上一个互斥锁 优点:基本避免了忙碌等待，可以适用于非互斥的情况(比如生产者消费者问题的仓库) 缺点:不能完全消除忙碌等待(在临界区执行时可能还要等待) ;如果用户错误的使用了wait和signal (或是因为不能确定的函数执行顺序(时序) )，那么会导致死锁和饥饿 怎么解决问题:将互斥锁的功能(S) 和调度队列链表的功能(wait函数等)分开 方案四:管程(monitor) :管程可以视为一种数据结构,有一个自己的ADT (抽象数据类型) 管程 = 一个互斥锁+ n个条件变量 互斥锁拥有acquire(cond)和release(cond)两个函数,不同的是函数会有参数,用于确定是调用哪一个条件的调度函数 注意:有的管程还可以加入broadcast()函数, 作用是唤醒所有wait的进程( 唤醒以后的进程再由cpu调度) 用户定义一系列条件变量condition ,每个条件变量相当于一个sem,有wait()和signal()两个函数 调用x.wait()操作的进程会被中断，直到有其他进程调用x.signal()唤醒它 假设P进程调用x.signal()唤醒了Q进程，那么此时只能由一个进程继续运行，所以: P自己变为等待，直到Q运行完-&gt; signal and wait Q等待P运行完然后运行自己-&gt; signal and continue 可以让P立刻结束，那么Q就不需要等待了 wait()也可以有参数，参数是一个整形数,用于确定有很多进程挂起在一个条件变量时唤醒哪一个进程: 在进程挂起时x.wait(c)，则该进程赋予了一个优先级c 在x.signal()时唤醒优先级c的值最小的进程 管程最大限度的防止了错位调用调度函数导致的同步失败问题 但程序员依旧要小心在程序中不能胡乱调用管程，否则依然有可能调度失败 解决死锁问题：死锁deadlock : 在系统的某一部分中， 所有进程都在等待其他进程释放资源而陷入的无尽循环的等待过程 形成死锁的四个条件: 互斥(mutual exclusion) :至少有一个资源是被互斥控制的 占有并等待(hold and wait):每个进程都至少占有了一个资源， 并在等待其他资源 非抢占(no preemption) :资源不能被抢占，即不能从等待的进程中夺走释放 循环等待(circular wait) :在一组有序进程中,每一个进程都在等待上一个进程的一个被占用的资源 其中第4条成立意味着第2条也成立，所以如果满足134，那么状态就能被称为死锁 判断死锁：通过系统资源分配图system resource- allocation graph: 定理：如果资源分配图中没有环，则一定不会产生死锁 如果有环： 如果每种类型的资源只有一个实例，则系统已经产生了死锁 如果有类型的资源不止一个实例，则系统不一定死锁 判断资源图是否死锁的方法(待验证) : 找到图中所有的环(如找到n个环) 做n次去除，每次单独去除一 一个环，步骤是: 去掉不属于公共环的申请边和分配边 去掉这些边连接的实例 每次去除后判断，剩下的图中是否有死锁的情况 有子图的话递归判断 如果在某次去除情况下发现只剩下一个环符合上述加粗的条件，则该图是死锁的 如果所有去除后的图都不会死锁(不成环或子图不死锁)， 则该图不死锁 如何防止死锁从死锁发生的条件来看： 防止互斥：不使用互斥锁，则一定不会死锁。但是得不偿失 防止持有并等待(hold and wait)：每个进程必须一次申请完自己所需的所有资源 缺点：资源利用率低(占用大量资源的程序可能有很多时间用不上部分的资源，那还不如释放给别人)，而且容易导致其它进程饥饿。 允许抢占：进程可以抢占别的进程的资源 问题：别的进程怎么办呢？这要求资源必须可以存储被使用的状态，才能被别的进程恢复使用。对于CPU寄存器与内存来说，这是可行的，但是其他的资源就不一定了。 防止循环等待：通过规划申请资源的顺序，尽可能的防止死锁 定义：安全状态(safe sequence) 定义一个进程的资源申请顺序&lt;p1,p2,….,pn&gt; 此顺序对于每个pi,其 仍然可以申请的资源&lt;当前可用资源+所有在pi之前的进程占用的资源 此时pi获得其所需的所有资源并运行，终止后释放所有资源，然后pi+1也可以满足以上不等式的要求得到所需资源 如果这样的序列存在，则称系统是安全状态，否则为不安全状态 注意：安全状态一定不会死锁，但不安全状态可能会死锁，也可能不会死锁 银行家算法避免死锁：绘制资源分配矩阵: Available:每种资源可用的实例数量 Max:每个进程对每种资源的最大需求实例数量 Allocation:每个进程现在被分配的每种资源的实例数量 Need:每个进程还需要的每种资源的剩余数量 公式:Need=Max-Allocation","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://fallensue.cc/tags/OS/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"OS绪论","slug":"OS绪论","date":"2020-11-25T13:55:01.000Z","updated":"2020-11-25T14:04:24.734Z","comments":true,"path":"posts/75e35db1.html","link":"","permalink":"https://fallensue.cc/posts/75e35db1.html","excerpt":"","text":"导论操作系统的功能操作系统控制硬件，并协调各个用户应用程序的硬件使用。 当计算机系统运行时，操作系统提供正确手段以便使用这些资源。操作系统类似于政府，其本身不能实现任何有用功能， 而是提供一个方便其他程序执行有用工作的环境。 用户视角 PC：让单个用户使用资源，目的是更好的使用体验，次要是性能，不在乎资源利用。 大型机与小型机相连的终端：其他用户通过其他终端一同访问计算机，目的是优化资源利用率；确保所有的CPU时间、内存、I/O均能够得到有效的使用，并且没有用户使用超过限额以外的资源。 工作站与服务器相连：兼顾使用方便性以及资源利用率。 系统视角可把操作系统看成资源分配器或是控制程序。 操作系统的定义一般来说没有广泛接受的定义，比较公认的定义是，操作系统是一个一直运行在计算机上的程序（内核） 操作系统的形成以及发展手工操作阶段操作员手动将纸带放入输入机，运行完后手动取走纸带以及结果 特点：具有用户独占计算机资源、资源利用率低及CPU等待人工操作的特点。 随着CPU速度提高，已经被淘汰。 脱机输入/输出技术外围机将数据输入磁带 批处理技术对一批作业自动进行处理，将一批作业输入到磁带上，并在系统中配置监督程序(管理作业的运行，完成作业的自动过渡，常驻于内存)。计算机按此一个一个自动的处理作业。 多道程序设计技术在早期的批处理系统中，内存中仅有一道程序，每当程序发出I/O 请求时，CPU 便处于等待I/O 完成的状态，致使CPU 空闲。为进一步改善CPU 的利用率引入了多道程序设计技术。 多道程序设计技术是指同时把多个作业放入内存并允许它交替执行，共享系统中的各类资源，当一道程序因某种原因（如I/O 请求）而暂停执行时，CPU 立即转去执行另一道程序。 在操作系统中引入多道程序设计技术，会使系统具有多道、宏观上并行、微观上串行的特点。 多道程序设计技术能有效提高系统的吞吐量和改善资源利用率。 操作系统基本类型三种基本类型：批处理操作系统，分时操作系统和实时操作系统。 批处理操作系统一次运行一批作业，不足之处是没有交互性。 分时操作系统在分时操作系统中，采用了分时技术，即把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各终端作业使用。 分时操作系统具有以下特征：（1）多路性。同时有多个用户使用一台计算机。宏观上看有多个用户同时使用计算机，微观上各用户轮流使用计算机。 （2）交互性。用户采用人-机会话的方式直接控制程序运行，即用户通过终端向系统提出服务要求，系统完成用户的请求并将结果返回给用户，用户再根据系统的结果信息向系统提出下一个服务请求。 （3）独占性。每个用户各占一个终端，彼此独立操作互不干扰。用户感觉不到别人也在使用这台计算机，好像只有自己独占计算机。 （4）及时性。用户的请求能在很短时间内获得响应，一般为2～3 秒。 实时操作系统响应及时，可靠性高","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://fallensue.cc/tags/OS/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"OS结构","slug":"OS结构","date":"2020-11-25T12:55:01.000Z","updated":"2020-11-25T14:04:24.722Z","comments":true,"path":"posts/ec79ecc8.html","link":"","permalink":"https://fallensue.cc/posts/ec79ecc8.html","excerpt":"","text":"操作系统结构操作系统服务 用户界面：UI 命令行界面(CLI) 图形用户界面(GUI) 程序执行 I/O操作 文件系统操作 通信 错误检测 内部功能： 资源分配 记账 保护与安全 系统调用提供操作系统服务接口，这些调用通常以C或者C++编写。 通常，应用开发人员根据应用编程接口(API)来设计程序(可以看成是一系列包装好的系统调用函数) 系统调用接口获得API中要进行的系统调用，然后统筹安排调用的顺序(建立一个索引表以找到对应的系统调用) 系统调用的类型 进程控制 文件管理 设备管理 信息维护 通信 保护 系统程序操作系统自带的应用程序，又称系统工具，主要分类有： 文件管理(资源管理器) 状态信息(任务管理器) 文件修改(vim和记事本) 程序语言支持(gcc) 程序加载和运行(如gdb) 通信(网络连接程序与远程连接程序) 后台服务 其他软件(网页浏览器、文字处理器、游戏软件、绘图软件) 操作系统的设计与实现设计目标基本两个大类：用户目标与系统目标 机制与策略策略与机制需要相分离，机制决定如何做，策略决定做什么。 对于灵活性，策略与机制的分离至关重要(微内核成功做到了机制与策略的分离) 实现采用高级语言编写操作系统的缺点：降低os处理的速度和增加存储需求。但对现在的硬件水平来说，这些缺点可以忽略不计。 操作系统的结构简单结构：用户-系统调用-硬件 早期的操作系统采用这种方法 优点：内核通信和系统调用的开销非常小 缺点：用户程序崩溃可能导致系统崩溃 分层方法：用户接口-层n-1-层n-2-层1-层0(硬件) 每一层实现的内容：接受上一层的数据，并使用下一层的操作处理，再返回数据。 优点：快速定义错误，可以从低层向高层调试:如果程序在这一层出错，则证明是这一层的问题 缺点：效率较其它方法更差 微内核尽量删除内核模式中不必要的功能，把它们封装到用户程序里，需要使用的时候再将二者结合起来 微内核里一般都有CPU调度和内存管理，其他系统调用通过进程间通信模块和外部用户程序进行消息传递实现 优点：内核小，可扩展性强 缺点：系统需要的功能越多，微内核性能越差 可加载的内核模块内核只提供核心服务，其他服务通过”动态链接”外部服务模块 优点：灵活，不需要在每次添加功能时重新编译内核程序 目前的最优方法之一 混合以上结构的操作系统MacOS,Windows,Linux","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://fallensue.cc/tags/OS/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"OS进程","slug":"OS进程","date":"2020-11-25T11:55:01.000Z","updated":"2020-11-25T14:04:24.740Z","comments":true,"path":"posts/357a36e1.html","link":"","permalink":"https://fallensue.cc/posts/357a36e1.html","excerpt":"","text":"进程进程：一系列CPU活动的总称 进程是活动的程序实体 进程可以套娃：进程是用于执行其他程序的程序活动(JVM) 进程状态定义进程的状态： new 创建中 running 运行中 waiting 等待(运行暂停中) ready 就绪(等待分配处理器) terminated 执行完成 进程控制块在操作系统中如何表示进程： PCB= 进程状态：(同上) 程序计数器：存储下一个要执行的指令地址 CPU寄存器：获取的硬件CPU中的寄存器数据 CPU调度信息：进程优先级、调度队列指针和其他参数 内存管理信息：各种进程所使用的内存地址以及寄存器值 记帐信息：CPU时间、实际使用的CPU时间等记录数据 I/O状态信息：分配给进程的I/O设备、文件等信息 注意：PCB可以被用来支持以线程为核心替代进程的系统，只需要增加一些信息 按照进程的功能给进程分类： I/O密集型进程(I/O-bound process):以执行I/O操作为主 CPU密集型进程(CPU-bound process):以执行CPU计算操作为主 进程调度调度队列进程在进入系统时，会被加到作业队列(包括系统内的所有进程)。 驻留在内存中的、就绪的、等待运行的进程保存在就绪队列上。 等待特定I/O设备的进程列表，称为设备队列。 调度程序操作系统通过调度器/调度程序来从调度队列中选择进程 调度程序的区分： 长期调度程序/作业调度程序 中期调度程序 短期调度程序/CPU调度程序 怎么调度： 进程加入磁盘缓冲区(进程池) 选择进程加入内存(作业和就绪队列)-&gt;长期调度 从就绪队列中选择进程，分配CPU-&gt;短期调度 进程开始运行 根据需要中断进程，从内存或者是CPU中移出-&gt;中期调度 一个指标：多道程序程度表示内存中的进程数量，长期调度必须保证该值稳定，即进程的进出速度几乎一致。 上下文切换CPU进行进程换出或者是中断时都需要进行上下文切换： CPU状态保存(内核/用户模式) 保存该进程PCB-&gt;读入新进程PCB-&gt;转换进程 CPU状态恢复 CPU调度发生的情况： 进程running-&gt;waiting 进程结束terminate 进程由running-&gt;ready(中断时) 进程由waiting-&gt;ready(I/O完成时) 以上情况均发生时都进行调度的调度方案：抢占式调度 只有1和2发生时进行调度的调度方案：非抢占式调度 非抢占式意味着一旦一个进程进入CPU运行，它一定会占用CPU，直到终止才退出。 换入，换出。 调度算法先到先服务(FIFO/FCFS)调度 非抢占式 先到的进程先执行 优点：算法简单 缺点：短运行时间的任务需要长时间的等待 最短时间优先(SJF) 非抢占式 运行时间短的进程优先执行 优点：效率最优 缺点：系统难以预测后到达的进程的运行时间 一个预测的方法：$$Tn+1=a(Tn)+(1-a)Qn$$预计下一次进程的运行时间=a*(本次运行时间)+(1-a)预计的本次运行时间 最短剩余时间优先(SRTF) 抢占机制的SJF 每当进程进入/进程运行结束的时候，计算所有队列的进程的剩余运行时间 剩余运行时间最短的进程可以抢占当前进程开始运行 SRTF的缺点：如果不停的有短时间进程到达，则长时间任务会陷入饥饿 饥饿：进程超级长时间在等待而得不到运行 优先级调度 SJF是优先级调度的特例 非抢占式或抢占式 为每个进程设置优先级，优先级高的进程先运行 优缺点与SJF相似 轮转调度(RR) 抢占式，分时系统 设定一个时间量单元(又称时间片) 每个进程的执行时间都不能长于时间片 当进程执行时间超过时间片时，队列里的下一个进程抢占该进程运行，重新开始时间片计时 就绪队列里的进程遵循FCFS,即被抢占的进程回到队尾 优点：短时间进程多的情况效率高 缺点：长时间进程多时，频繁切换上下文会使效率降低，且RR调度的效率取决于时间片的大小，时间片越大时，其效率越接近FCFS 多级队列/多级反馈队列调度 将就绪队列分成不同的n个队列，每个队列按照特定的规则调度进程(比如一个用FCFS，一个用SJF) 队列之间可以进行反馈，使得进程在不同队列之间迁移 如长时间占用CPU的进程可能会被移到优先级更低的队列 优点：优化短时间进程和I/O密集型进程的运行效率 缺点：仍然难以解决长时间进程的饥饿(又被称为老化，aging的问题) 彩票调度 在RR或多级队列的基础上进行优化 给每个进程发一些彩票，在每个时间片开始之前，抽奖选出幸运进程 为了防止饥饿，每个进程至少有一张彩票 幸运进程的优先级会被提高，然后再开始确定调度 发彩票的规则可以按照需求确定： 如果要接近像SJF的短时效率，那么给短时间的进程多发彩票 如果想解决长时间进程的饥饿问题，则给等待时间很长的进程增加其持有的彩票数，即增加其被抽中的概率 CPU调度(多核处理器)注意：现在使用的多核处理器架构并不是物理上的放置多个处理器，而是将多个处理器核放在一个物理芯片上 方法一：非对称多处理 一个处理器负责调度，称为主服务器 其他处理器负责执行程序 方法二：对称多处理 每个处理器都独立地进行自我调度和执行程序 每个处理器可以有一个自己的就绪队列 或者共享一个就绪队列 使用对称多处理的调度方案需要考虑的问题： 处理器亲和性 软亲和性：尽量让同一进程一直运行在同一处理器上 硬亲和性：通过系统调用支持，使进程可以指定一个处理器或一个处理器子集运行该进程 二者可以兼得 负载平衡 保障不会发生“—些处理器高负载，而其他处理一直空闲”的情况 对于有公共队列的调度系统，无需考虑负载平衡 一旦处理器空闲，它可以立刻从公共队列里取进程，自动就平衡了 负载平衡只对独立就绪队列的调度系统有必要 负载平衡的方法 推迁移push migration:将进程从超载处理器”推”到空闲处理器 拉迁移pull migration:空闲处理器从超载处理器上”拉”下进程(ps:有点像git的感觉） 注意:负载平衡的实现会降低处理器亲和性，换句话说，二者不能共存 内存停顿：多核处理器访问内存时，可能因为cache未命中等多个原因导致访问数据的时间变长很多，也可以称为长延迟事件 解决办法:给每个核分配多线程，如果某个线程在等待内存，处理器核就切换到其他线程工作 实现多核多线程的两种办法: 粗粒度coars-grained:当遇到长延迟事件时才切换线程，切换线程的成本比较高 细粒度fine-grained:在每个CPU指令周期结束/开始时切换线程，成本比较小，但切换频繁 注意:多核多线程处理器实际需要两层调度:一是操作系统分配一系列用户进程的线程到处理器，这可以遵循单核的CPU调度方案;二是多核处理器决定哪些线程分配到哪些核上，需要另外—套方案 CPU调度(实时操作系统)注意:实时操作系统要求优先级高的任务/进程必须以最快速度执行完毕，处理必须在固定时间内完成。Windows、Liunx、mac os都不是实时操作系统 软实时系统:不会调度关键的实时进程，只保证它们的优先级更高 硬实时系统:任务必须在时限内完成，否则不管是什么进程都会被中止 实时系统必须要求尽可能低的事件延迟event latency:事件发生到得到服务的时间 可以优化的延迟有:(不是简单的最小化，而是优化到尽可能符合时限的要求) 中断延迟interrupt latency:从CPU收到中断到中断处理程序开始的时间 调度延迟dispatch latency:调度程序从停止一个进程到启动另一个进程的时间 因此，实时系统的调度一般采用抢占式调度 调度延迟分为两个部分: 冲突:调度程序在抢占优先级不够高内核进程并且释放其对要调度的进程有用的资源 调度:切换到要调度的高优先级进程 实时系统的三种抢占式调度: —些概念:(任务=进程) p:周期，任务多长时间需要CPU执行一次 d:时限（截止期限,ddl)，周期开始后最多要在该时间内完成 d ≤p但很多情况下也会令d = p t:处理时间，CPU只处理该任务需要的时间 前提:所有任务的g即CPU利用率之和不超过1，否则会有任务超过时限因此系统会使用准入控制算法，拒绝会超过ddl的任务进入 单调速率调度rate-monotonic: 周期p小的进程优先级高 优先级高的任务在其周期开始时可以抢占优先级低的任务开始执行 优先级低的任务必须等待优先级高的任务执行后继续执行自己 最早截止日期优先Earliest-Deadline-First，EDF:(byr调度方法(bushi):( 每个进程在运行开始时告诉操作系统其ddl 系统计算(DDL-当前时间）越小的进程优先级越高 系统判断是否要抢占调度进程，抢占规则与上相同 理论上i该方案是最佳的，CPU利用率能接近100% 比例分享调度proportional share: 处理器定义一个总分配值T 给每个进程分配N的时间 据此，每个进程可以使用*100%的CPU时间 如果分配完后剩下的T值不够新进程的请求，准入算法会拒绝新的进程加入 进程间通信不影响其他进程，也不受其他进程影响的进程：独立进程与其他进程进行数据共享的进程：协作进程 协作进程的好处： 信息共享information sharing 计算加速computeration speedup 模块化modularity 便捷convenience 进程间通信的两种方法:1、共享内存: 建立一块内存区域，可以供所有进程共享，进程从内存中读写数据，要保证不会由多个进程同时读写数据(进程同步会解决这个问题) 建立共享内存时需要系统调用，但使用时无需 优点:速度快(单核系统） 缺点:在多核系统中有高速缓存一致性等问题，会使性能下降 2、消息传递:操作系统提供机制:进程可以进行两种操作:send(mes)发送消息，receive(mes)接受消息，进程可以通过一种方式互相发送消息，称为通信链路communication link不断进行系统调用才能实现 优点:无需避免冲突(同步问题)，多核系统中效率高 缺点:某些情况下系统调用要更慢 实现通信链路的三个问题： 如何找到对方:直接/间接通信: 直接通信： 对称的寻址: P发给Q, Q接受P 非对称的寻址: P发给Q, Q接受任何消息 间接通信： 定义邮箱/端口，用来作为收发消息函数的参数 两个进程之间只扫要有一个邮箱才能通信 但一个邮箱可以服务与很多对进程 两个进程间可以由多个邮箱组成多条通信链路 邮箱的拥有者可以是os或者进程 如何收发消息:同步/异步通信: 同步←→阻塞blocking 异步→非阻塞nonblocking 发送 接收 阻塞 发送消息的进程进入阻塞，直到消息被接收 接收消息的进程进入阻塞，直到收到有效的发送者消息 非阻塞 发送消息的进程发送消息后继续运行 不管接收者收到什么消息，都继续接收并继续运行 如果发送和接受消息都以阻塞的方式，那么称发送者和接收者一定会有交会(rendzvous) 发送的的消息存在哪里:缓存: 消息存在临时队列中，临时队列的实现方法有: 零容量:不允许暂存消息，所以必须以阻塞方式收发消息 有限容量:队列长度有限，只有当队列满的时候，收发消息才必须以阻塞的方式 无限容量:队列长度可以无限扩增，因此发送者一直使用非阻塞的方式发送消息","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://fallensue.cc/tags/OS/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"OS线程","slug":"OS线程","date":"2020-11-25T10:55:01.000Z","updated":"2020-11-25T14:04:24.728Z","comments":true,"path":"posts/239c332d.html","link":"","permalink":"https://fallensue.cc/posts/239c332d.html","excerpt":"","text":"多线程线程是什么: 一个进程内的多个独立工作的任务流 操作系统能进行运算调度的最小单位 线程共享进程的代码、数据和文件,但有自己独立的 堆栈和使用的CPU寄存器 线程也有自己的TCB(thread control block) 线程的状态: 切换(spawn)：准备切换到另一个进程 阻塞(block)：等待其他线程结束 解除阻塞(unblock) 完成(finish)：重新分配寄存器和堆栈 线程的分类: 用户线程user level thread, ULT： 由用户编写的程序来管理，用户不会考虑操作系统怎么处理这些线程 内核线程kernel level thread，KLT: 由操作系统直接支持和管理 多线程编程的三个模型: 多对一： 多个用户及线程-&gt;一个内核线程 无法利用多核，所以几乎已经被淘汰 一对一： 一个用户线程，有一个内核线程对接管理 内核负责调度这一系列线程 多对多： 多个内核线程负责多个用户线程 内核一次只能调度一个线程，所以并发性和一对一一样，但可以灵活调度的线程更多，更适合多核处理器 结合一对一和多对多的模型 线程池：在os开始运行时创立一系列空的线程，等待为用户线程而工作，这些线程统称为线程池 优点： 当用户需要线程时，一般取一个空线程即用比再创建新的线程快 允许用户程序支持的最大线程数增长到线程池的容量 多线程的优点： 响应性 资源共享 经济 可伸缩性 并行和并发的概念： 并行：同一个时间段在执行多个进程 并发：同一时刻在执行多个进程","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://fallensue.cc/tags/OS/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-图的关键路径分析","slug":"数据结构-图关键路径分析","date":"2020-11-19T12:16:21.000Z","updated":"2020-11-19T13:17:49.754Z","comments":true,"path":"posts/bfa3aab2.html","link":"","permalink":"https://fallensue.cc/posts/bfa3aab2.html","excerpt":"","text":"关键路径问题关键路径问题具体是要分析什么呢？其实是要分析类似下面的图(AOE)的相关问题。 边：表示一个活动，一个边(v,w)表示着事件v必须在w开始之前完成 权重：一个活动的持续时间 顶点：表示一个状态 只有一个顶点的出度为0，也只有一个顶点的入度为0 没有环 有向图中，用顶点表示事件，用有向边表示活动之间开始的先后顺序，则称这种有向图为AOV（Activity On Vertex）网络；AOV网络可以反应任务完成的先后顺序（拓扑排序）。 在AOV网的边上加上权值表示完成该活动所需的时间，则称这样的AOV网为AOE（Activity On Edge）网，如图： 如何求AOE网中各事件（节点）和各活动（边）的最早开始时间和最迟开始时间以及工程的关键路径？ 整个活动的完成时间是AOE图中从始点到终点的最长路径的长度，这条路径称为关键路径。关键路径上的活动称作关键活动。 注意：关键路径不一定只有一条。 1.最早发生时间：从前往后，前驱结点到当前结点所需时间，取最大值。 如上图中的节点4有两个前驱结点（节点2和3），节点2到节点4的最早发生时间是a1+a3也就是8，节点3到节点4的最早发生时间是a2+a4也就是12，因为12&gt;8，所以节点4的最早发生时间是12. 结束节点（10）的最早发生时间和最迟发生时间相同。 2.最迟发生时间：从后往前，后继结点的最迟发生时间-边权值，取最小值。 如上图中的节点9的最迟发生时间为其后继节点10（只有一个）的最迟发生时间减去a14即24-2=22. 事件 1 2 3 4 5 6 7 8 9 10 最早发生时间 0 5 6 12 15 16 17 19 22 24 最迟发生时间 0 9 6 12 16 20 17 20 22 24 3.关键路径：最早发生时间和最迟发生时间相同的结点即为关键路径上的节点。 4.最早开始时间：等于当前边起始结点的最早发生时间。 5.最晚开始时间：等于当前边指向结点的最迟发生时间-当前边的权值。 6.最早完工时间：等于当前边指向结点的最早发生时间。 7.最晚完工时间：等于当前边指向结点的最迟发生时间。 活动 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 最早开工 0 0 5 6 6 12 12 12 15 15 17 19 16 22 最迟开工 4 0 9 6 13 16 13 12 16 16 17 20 20 22 最早完工 5 6 12 12 15 16 15 17 17 19 22 22 24 24 最迟完工 9 6 12 12 16 20 16 17 17 20 22 22 24 24","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-图的拓扑排序","slug":"数据结构-图的拓扑排序","date":"2020-11-19T12:16:21.000Z","updated":"2020-11-19T13:17:36.175Z","comments":true,"path":"posts/c3ce505e.html","link":"","permalink":"https://fallensue.cc/posts/c3ce505e.html","excerpt":"","text":"拓扑排序定义在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它前面的节点。 先统计所有节点的入度，对于入度为0的节点就可以分离出来，然后把这个节点指向的节点的入度–。 重复如上操作，直到所有的节点都被分离出来。 如果最后不存在入度为0的节点，那就说明有环，不存在拓扑排序，也就是很多题目的无解的情况。 有向图内不能够出现环 算法图示如下 算法实现 将所有入度为0的顶点保存在一个队列中 当队列非空的时候 从队列中删除一个顶点 所有与删除顶点相邻的顶点的入度减一 如果一个相邻顶点的入度为0，则入队 这样的话拓扑排序顺序就是出队的顺序，时间复杂度为O(|E|+|V|) 伪代码实现： void Topsort(Graph G){ Queue Q; int Counter = 0; Vertex V, W; Q = CreateQueue (NumVertex); MakeEmpty (Q); for each vertex V if (Indegree [V] == 0) Enqueue (V, Q); while (!IsEmpty (Q)) { V = Dequeue (Q); TopNum [V] = ++Counter; /* Next No. */ for each W adjacent to V if(--Indegree [W] == 0) Enqueue (W, Q); } if (Counter != NumVertex) Error (&quot;Graph has a cycle&quot;); DisposeQueue (Q); /* Free the memory */ } C++代码实现 bool Topsort() { cout &lt;&lt; &quot;图的拓扑序列为：&quot; &lt;&lt; endl; //栈s用于保存栈为空的顶点下标 stack&lt;int&gt; s; int i; ArcNode * temp; //计算每个顶点的入度，保存在indgree数组中 for (i = 0; i != this-&gt;vexnum; i++) { temp = this-&gt;arc[i].firstarc; while (temp) { ++this-&gt;indegree[temp-&gt;adjvex]; temp = temp-&gt;next; } } //把入度为0的顶点入栈 for (i = 0; i != this-&gt;vexnum; i++) { if (!indegree[i]) { s.push(i); } } //count用于计算输出的顶点个数 int count=0; while (!s.empty()) {//如果栈为空，则结束循环 i = s.top(); s.pop();//保存栈顶元素，并且栈顶元素出栈 cout &lt;&lt; this-&gt;arc[i].data&lt;&lt;&quot; &quot;;//输出拓扑序列 temp = this-&gt;arc[i].firstarc; while (temp) { if (!(--this-&gt;indegree[temp-&gt;adjvex])) {//如果入度减少到为0，则入栈 s.push(temp-&gt;adjvex); } temp = temp-&gt;next; } ++count; } if (count == this-&gt;vexnum) { cout &lt;&lt; endl; return true; } cout &lt;&lt; &quot;此图有环，无拓扑序列&quot; &lt;&lt; endl; return false;//说明这个图有环 }","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-树","slug":"数据结构树","date":"2020-11-18T11:33:01.000Z","updated":"2020-11-19T13:16:38.704Z","comments":true,"path":"posts/f30c2ae3.html","link":"","permalink":"https://fallensue.cc/posts/f30c2ae3.html","excerpt":"","text":"树树是n个结点的有限集。 其余的树叫做根的子树 结点包含一个数据元素及指向其子树的分支。 结点的子树数为结点的度，度为0的结点称之为叶子或终端结点，度不为0的结点称之为非终端结点或是分支结点。 子树的根称为孩子，（双亲，兄弟，子孙，祖先） 结点的层次，根为第一层。树中结点的最大层次称之为深度 各子树看成从左至右有次序，则该树为有序树，否则为无序树 二叉树的定义特点：每个结点至多有只有两棵子树，子树有左右之分 特性：在二叉树的第i 层上至多有(2^i-1)个结点(i&gt;=1) 深度为k的二叉树至多有(2^k)-1个结点(k&gt;=1) 对任意一棵二叉树T，如果其终端结点为n，度为2的结点为m，则n=m+1 满二叉树一棵深度为k且有(2^k)-1个结点的树称为满二叉树 特点：每一层上的结点数都是最大结点数 完全二叉树完全二叉树：深度为k,有n个结点，每一个结点与满二叉树一一对应 特点：叶子节点只可能在层次最大的两层上出现，对任一结点，其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+1 具有n个结点的完全二叉树的深度为[log2n]+1 如果对一棵有n个结点的完全二叉树的结点按层序编号，则对任一结点，有 (1) 如果i=1，则结点i是二叉树的根，无双亲；若i&gt;1，其双亲PARENT(i)是结点[i/2] (2)如果2i&gt;n,则结点i无左孩子，否则其左孩子为结点2i’ (3)如果2i+1&gt;n，则结点i无右孩子；否则其右孩子为结点2i+1 二叉树的存储结构顺序存储结构用一组地址连续的存储单元依次自上而下，自左而右的存储。 仅适用于完全二叉树，否则浪费空间 #define MAX_TREE_SIZE 100//二叉树最大结点数 typedef TElemType SqBiTree[MAX_TREE_SIZE];//0号单元存储根结点 SqBiTree bt; 链式存储结构结点由一个数据元素和分别指向其左、右子树的两个分支构成。（数据域，左右指针域） 有时可以增加指向其双亲的指针域（分别称为二叉链表和三叉链表） n个结点的二叉链表中有n+1个空链域 typedef struct BiTNode{ TElemType data; struct BiTNode *lchild,*rchild;//左右孩子指针 }BiTNode,*BiTree; 遍历二叉树先序遍历：若是二叉树空，则空操作。否则先访问根节点，再先序遍历左子树，最后先序遍历右子树 中序遍历：若是二叉树空，则空操作。否则先中序遍历左子树，再访问根节点，最后先序遍历右子树 后序遍历：若是二叉树空，则空操作。否则先后序遍历左子树，再后序遍历右子树，最后访问根节点 时间复杂度均为O(n) 线索二叉树若结点有左子树，则其lchild域指向其左孩子，否则令其lchild域指向其前驱；若结点有右子树，则令其rchild域指向其右孩子，否则指向其后继。增加两个标志域。 lchild LTag data RTag rchild 这样的二叉链表叫做线索链表，二叉树叫做线索二叉树。 typedef enum PointerTag{Link,Thread}; //Link==0:指针，Thread ==1:线索 typedef struct BiThrNode{ TElemType data; struct BiThrNode *lchild,*rchild; //左右孩子指针 PointerTag LTag,RTag;//左右标志 }BiThrNode,*BiThTree; 哈夫曼树从树中一个结点到另一个结点之间的分支构成此两个结点之间的路径，路径上的分支数目叫做路径长度。路径长度是从树根到每一个结点的路径长度之和。 树的带权路径长度：所有叶子结点的带权路径长度之和WPL WPL最小的树被称为赫夫曼树 typedef char** HuffmanCode;//动态分配数组存储哈夫曼编码表 /*储存字符权值*/ typedef struct { char a; int weight; }ElementType; ElementType element[Max_n]; /*HuffmanTree的存储表示*/ typedef struct { ElementType data; int parent, lchild, rchild; }HTNode, * HuffmanTree; /*创建Huffman树*/ if (n &lt;= 1) { cout &lt;&lt; &quot;输入字符太少，无法创建哈夫曼树&quot; &lt;&lt; endl; exit(0); } HT = new HTNode[2 * n];//0号单元未使用 int m = 2 * n - 1; //初始化结点 for (int i = 1; i &lt;= m; i++) { HT[i].parent = 0; HT[i].lchild = 0; HT[i].rchild = 0; HT[i].data.a = element[i - 1].a; HT[i].data.weight = element[i - 1].weight;//Data从0开始存入信息 } for (int i = n + 1; i &lt;= m; i++) { int s1 = 0, s2 = 0;//下标 Select(HT, i - 1, s1, s2); HT[s1].parent = i; HT[s2].parent = i;//标记双亲为i,表示这两个值已经处理过 HT[i].lchild = s1; HT[i].rchild = s2;//s1,s2分别为双亲的左右孩子 HT[i].data.weight = HT[s1].data.weight + HT[s2].data.weight;//双亲权值是左右孩子权值之和 } cout &lt;&lt; &quot;哈夫曼树创建成功！&quot; &lt;&lt; endl; //从叶子到根逆向求每个字符的哈夫曼编码,存储在编码表HC中 HC = new char* [n + 1];//0号位置不用 char* cd = new char[n]; cd[n - 1] = &#39;\\0&#39;;//编码结束符 for (int i = 1; i &lt;= n; i++) {//求编码 int start = n - 1;//记录编码在cd中存放的位置,初始时指向最后 int c = i; int f = HT[i].parent;//c记录从叶子结点向上回溯至根节点的下标,f记录i的双亲的下标 while (f != 0) {//向上没有双亲 start--;//向上走一次,start前移一次 if (HT[f].lchild == c) cd[start] = &#39;0&#39;; //左孩子编码为0 else cd[start] = &#39;1&#39;; //右孩子编码为1 c = f; f = HT[f].parent; //继续向上找 } HC[i] = new char[n - start];//第i个编码字符分配空间 strcpy(HC[i], &amp;cd[start]); } delete[]cd; cout &lt;&lt; &quot;成功求出哈夫曼编码！&quot; &lt;&lt; endl; //从叶子到根逆向求每个字符的哈夫曼编码,存储在编码表HC中 HC = new char* [n + 1];//0号位置不用 char* cd = new char[n]; cd[n - 1] = &#39;\\0&#39;;//编码结束符 for (int i = 1; i &lt;= n; i++) {//求编码 int start = n - 1;//记录编码在cd中存放的位置,初始时指向最后 int c = i; int f = HT[i].parent;//c记录从叶子结点向上回溯至根节点的下标,f记录i的双亲的下标 while (f != 0) {//向上没有双亲 start--;//向上走一次,start前移一次 if (HT[f].lchild == c) cd[start] = &#39;0&#39;; //左孩子编码为0 else cd[start] = &#39;1&#39;; //右孩子编码为1 c = f; f = HT[f].parent; //继续向上找 } HC[i] = new char[n - start];//第i个编码字符分配空间 strcpy(HC[i], &amp;cd[start]); } delete[]cd; cout &lt;&lt; &quot;成功求出哈夫曼编码！&quot; &lt;&lt; endl;","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-串","slug":"数据结构串","date":"2020-11-18T10:33:01.000Z","updated":"2020-12-14T02:38:19.609Z","comments":true,"path":"posts/d0f417a6.html","link":"","permalink":"https://fallensue.cc/posts/d0f417a6.html","excerpt":"","text":"串由零个或者是多个字符组成的有限序列 零个字符为空串，长度为零。 字符在串中的位置（在序列中的序号） 任意个字符组成的子序列称之为子串，包含子串的串称之为主串 两个串相等，说明两个串的值相等。 由一个或多个空格组成的串叫做空格串（不是空串！） 串和线性表很像（但是串的数据对象约束为字符集），线性表通常 以单个元素作为操作对象，但是串以整体作为对象。 串的定位函数Index(S,T,pos) 基本思想：在主串S中取从第pos个字符起，长度与T相等的子串与串T进行比较，若相等则函数值为pos，否则不断增加持续比对 int Index(String S,String T, int pos){ if(pos&gt;0){ n = S.length; m = T.length; i = pos; while(i&lt;=n-m+1){ SubString(sub,S,i,m); if(StrCompare(sub,T)!=0) i++; else return i //返回子串在主串中的位置 } } return 0;//不存在 } 串的三种表示方法定长顺序存储表示类似于线性表的顺序存储结构，按照预定义的大小，分配一个固定长度的存储区，可以用定长数组表示之。 #define MAXSTRLEN 255 typedef unsigned char SString[MAXSTRLEN+1]; 串长两种表示方法：1.数组0号单元存放 2.串后面加一个‘\\0’符号（结束符号） 串的连接Status Concat(SString &amp;T, SString S1,SString S2){ //用T返回由S1与S2连接成的新串 if(S1[0]+S2[0]&lt;=MAXSTRLEN){//未截断 T[1...S1[0]]=S1[1...s1[0]]; T[S1[0]+1...S1[0]+S2[0]]=S2[1...S2[0]]; T[0]=S1[0]+S2[0]; } else if(S1[0]&lt;MAXSTRLEN){//截断 T[1...S1[0]]=S1[1...S1[0]]; T[S1[0]+1...MAXSTRLEN] = S2[1...MAXSTRLEN-S1[0]]; T[0]= MAXSTRLEN; uncut = FALSE; } else{ T[0...MAXSTRLEN] = S1[0...MAXSTRLEN]; uncut = FALSE; } return uncut; } 求子串Status SubString(SString &amp;Sub,SString S, int pos,int len){ if(pos&lt;1||pos&gt;S[0]||len&lt;0||len&gt;S[0]-pos+1){ return ERROR; } sub[1...len]=S[pos...pos+len-1]; sub[0]=len; return OK; } 这个结构弊端：串的最大长度受限，操作起来不易，如插入，置换。 堆分配存储表示特点：仍以一组连续的存储单元存放串值字符序列，但是存储空间为程序执行过程中动态分配得到 typedef struct{ char *ch; int length; }HString; 串的插入Status StrInsert(HString &amp;S,int pos,HString T){ //在串的第pos个字符之前插入串T if(pos&lt;1||pos&gt;S.length+1) return ERROR; if(T.length){//T非空，则重新分配空间，插入T if(!(S.ch=(char*)realloc(S.ch,(S.length+T.length)*sizeof(char)))) exit(OVERFLOW); for(i=S.length-1;i&gt;=pos-1;i--){ S.ch[i+T.length]=S.ch[i]; S.ch[pos-1...pos+T.length-2]=T.ch[0...T.length-1]; S.length += T.length; } } return OK; } 串的块链存储表示特点：与线性表的链式存储结构相似，用链表方式存储 #define CHUNKSIZE 80 //可由用户定义的块大小 typedef struct Chunk{ char ch[CHUNKSIZE]; struct Chunk *next; }Chunk; typedef struct{ Chunk *head,*tail; //串的头和尾指针 int curlen; //串的当前长度 } 串的模式匹配算法子串的定位操作称之为串的模式匹配 暴力匹配算法分别用计数指针i与j指示主串S和模式串T中当前正要比较的位置 基本思想：从主串S的第pos个字符起与模式串的第一个字符比较，相等则继续逐个比较，否则从主串的下一个字符起再重新和模式串的字符进行比较。 算法时间复杂度最坏的情况下为O(n*m)(n和m分别为主串与模式串的长度) int Index( SString S, SString T, int pos ) // 返回子串T在主串S中第pos个字符之后的位置。若不存在，则返回0 { i = pos ; j = 1; while ( i &lt;= S[0] &amp;&amp; j &lt;= T[0] ) // S[0]是串的长度 { if ( S[i] == T[j] ) { ++i ; ++j ; } // 继续比较 else { i = i - j + 2; j = 1; } // 指针后退重新匹配 } if ( j &gt; T[0] ) return i-T[0]; else return 0; } KMP匹配算法时间复杂度为O(m) int Index_KMP (SString S,SString T, int pos) { i=pos;j=1; while(i&lt;=S[0] &amp;&amp; j &lt;= T[0]) if(j==0||S[i]==T[j]){i++;j++;} else j=next[j];/*i 不变 ,j 后退*/ } if(j&gt;T[0])return i-T[0];//匹配成功 else return 0; //返回不匹配标志 } void Get_next( SString T, int &amp;next[] // Get Next[] value { j = 1 ; k = 0; next[1]=0; while ( j &lt;= T[0] ) { if ( k == 0 || T[j] == T[k] ) { ++j ; ++k ; next[j]=k; } else k = next[k]; } }","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-栈和队列","slug":"数据结构栈和队列","date":"2020-11-18T09:33:01.000Z","updated":"2020-11-19T13:19:22.413Z","comments":true,"path":"posts/57ad5ad7.html","link":"","permalink":"https://fallensue.cc/posts/57ad5ad7.html","excerpt":"","text":"栈和队列栈限定只在表尾进行删除操作的线性表（表尾栈顶，表头栈底） 后进先出（插入元素叫做入栈，删除元素叫做出栈） 栈的表示与实现一组连续的存储单元表示 typedef struct{ SElemType *base; SElemType *top; int stacksize; }SqStack; top为栈顶指针，base为栈底指针 top == base表示栈空了，每插入一个元素,top++;每删除一个元素，top–。 插入删除算法插入：先将元素插入当前栈顶指针所指向的位置，再移动栈顶指针。 删除：先取得栈顶指针减一位置的值，栈顶指针再自减一。 Status Push(SqStack &amp;S,SElemType e){ if(S.top-S.base&gt;=S.stacksize){//栈满了，追加存储空间 S.base=(SElemType *)realloc(S.base,(S.stacksize + STACKINCREMENT)*sizeof(SElemType)); if(!S.base) exit(OVERFLOW); S.top = S.base+S.stacksize; S.stacksize+=STACKINCREMENT; } *S.top=e; S.top++; return OK; } Status Pop(SqStack &amp;S,SElemType &amp;e){ if(S.top == S.base) return ERROR; e = *(--(S.top)); } 队列与栈相反，先进先出（只允许在表的一端插入，在另一端删除） 允许插入的一端叫做队尾，允许删除的一端叫做队头。 双端队列插入与删除操作在表的两端的线性表，两个端点分别称之为端点1与端点2. 输出受限的双端队列：一个端点允许插入与删除，一个端点只允许插入 输出受限的双端队列：一个端点允许插入与删除，一个端点只允许删除 限定从某个端插入的结点只能在该端删除：两个栈底相接的栈 链队列链表表示的队列 给链队列添加一个头结点，并令头指针指向它（空的链队列即是头指针与尾指针均指向头结点） 循环队列有两个指针front和rear来分别指示队列头元素以及队列尾元素 插入元素，尾指针++；删除元素，头指针– 非空的循环队列中，头指针始终指向队列头元素，尾指针始终指向队列尾元素的下一个位置 #define MAXQSIZE 100//最大队列长度 typedef struct{ QElemType *base; //初始化的动态分配存储空间 int front; //头指针，若队列不空，指向队头元素 int rear; //尾指针，若队列不空，指向队列尾元素的下一个位置 }SqQueue; Status InitQueue(SqQueue &amp;Q){ Q.base = (QElemType *)malloc(MAXQSIZE*sizeof(QElemType)); if(!Q.base)exit(OVERFLOW);//分配失败 Q.front = Q.rear=0; return OK; } int QueueLength(SqQueue Q){ //返回Q的元素个数，即队列的长度 return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE; } Status EnQueue(SqQueue &amp;Q,QElemType e){ //插入元素e为Q的新的队尾元素 if((Q.rear+1)%MAXQSIZE==Q.front) return ERROR;//队列满了 Q.base[Q.rear]=e; Q.rear = (Q.rear+1)%MAXQSIZE; return OK; } Status DeQueue(SqQueue &amp;Q,QElemType &amp;e){ //若队列不空，则删除Q的队头元素，用e返回其值，并返回OK //否则返回ERROR if(Q.front == Q.rear) return ERROR; e = Q.base[Q.front]; Q.front = (Q.front + 1)%MAXQSIZE; return OK; } 循环队列满不满的判定 我们可以发现，当循环队列属于上图的d1情况时，是无法判断当前状态是队空还是队满。为了达到判断队列状态的目的，可以通过牺牲一个存储空间来实现。 如上图d2所示， 队头指针在队尾指针的下一位置时，队满。 Q.front == (Q.rear + 1) % MAXSIZE 因为队头指针可能又重新从0位置开始，而此时队尾指针是MAXSIZE - 1，所以需要求余。 当队头和队尾指针在同一位置时，队空。 Q.front == Q.rear;","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-线性表","slug":"数据结构线性表","date":"2020-11-18T08:33:01.000Z","updated":"2020-11-19T13:19:22.413Z","comments":true,"path":"posts/5b12b8a1.html","link":"","permalink":"https://fallensue.cc/posts/5b12b8a1.html","excerpt":"","text":"线性表结构：n个元素的有限序列 表中元素的个数n(n&gt;=0)为线性表的长度，n=0时为一个空表 a1为第一个数据元素，an为最后一个数据元素。 特点：灵活，便于插入，删除，访问 合并线性表LA和LB，求A=AUB 解法：扩大LA，若LB中有不存在于LA的元素就插入LA中。 void union(List &amp;La,List Lb){ //将所有在线性表Lb中但不在La中的数据元素插入到La中。 La_len=ListLength(La); Lb_len=ListLength(Lb);//求线性表的长度 for(i=1;i&lt;=Lb_len;i++){ GetElem(Lb,i,e); //取Lb中第i个数据元素赋给e if(!LocateElem(La,e,equal)) ListInsert(La,++La_len,e); //La中不存在和e相同的数据元素，则插入之 } }//union //合并两个无序线性表 void union(List&amp; La,List Lb){ int i,j = 0; int m = La.length; int n = Lb.length; for(i = 0; i &lt; n; i++){ while(La.data[j] != Lb.data[i] &amp;&amp; j &lt; m){//遍历La，直到找到等于Lb.data[i]的元素或者没找到才退出 j++; } if(j &gt;= m){ La.data[m] = Lb.data[i]; La.length++; m++; } j=0; } } 时间复杂度：T(n)=O(ListLength(LA)*ListLength(LB)) C语言代码实现： //合并两个无序线性表 void MergeList(SqList &amp;A,SqList &amp;B){ int i,j=0; int m = A.length; int n = B.length; for(i=0;i&lt;n;i++){ while(A.data[j] != B.data[i] &amp;&amp; j&lt;m){ j++; } if(j&gt;=m){ A.data[m] = B.data[i]; A.length++; m++; } j=0; } } 合并两个有序排列的线性表LA,LB均为非递减有序排列，合并为LC仍为非递减有序排列。 解法：设LC为空，将LA与LB元素逐个插入，设两个指针i,j分别指向LA，LB中某个元素，对比两个元素大小决定插入谁，再逐个后移。 void MergeList(List La,List Lb,List &amp;Lc){ //已知线性表La和Lb中的数据元素按非值递减排列。 //归并La和Lb得到新的线性表Lc，Lc的数据元素也可按值非递减排列。 InitList(Lc); i=j=1;k=0; La_len=ListLength(La); Lb_len=ListLength(Lb); while((i&lt;=La_len)&amp;&amp;(j&lt;=Lb_len)) {//La和Lb均非空 GetElem(La,i,ai);GetElem(Lb,j,bj); if(ai&lt;=bj) {ListInsert(Lc,++k,ai);++i;} else {ListInsert(Lc,++k,bj);++j}; } while(i&lt;=La_len) { GetElem(La,++i,ai);ListInsert(Lc,++k,ai); } while(i&lt;=Lb_len) { GetElem(Lb,++j,bj);ListInsert(Lc,++k,bj); } 时间复杂度：O(ListLength(LA)+ListLength(LB)) 线性表的顺序表示以及实现顺序表示：指用一组连续的存储单元依次存储线性表的数据元素。 Location(ai+1)=Location(ai)+(i-1)l 线性表中第i个元素存储位置 表中相邻的元素有相邻的存储位置，因此只要确定起始位置就能随机存取任一表中数据元素。 所以线性表的顺序存储结构为一种随机存取的存储结构 /*线性表的动态分配存储结构*/ typedef struct{ ElemType *elem; //存储空间基址 int length; //当前长度 int listsize; //当前分配的存储容量(以sizeof(ElemType)为单位) }SqList; Status InitList_Sq(SqList &amp;L){ //构造一个空的线性表L L.elem = (ElemType *)malloc(LIST_INIT_SIZE*sizeof(ElemType)); if(!L.elem) exit(OVERFLOW);//存储分配失败 L.length = 0; //空表长度为0 L.listsize = LIST_INIT_SIZE; //初始存储容量 return OK; } 顺序表示下线性表的插入，删除插入在第i-1个数据元素与第i个数据元素之间插入一个新的数据元素,长度为n变为n+1 于是，在第i(1&lt;=i&lt;=n)个元素之前插入一个元素，要将n至第i个元素均后移一位。 /*初始条件:顺序线性表L已经存在，1&lt;=i&lt;=ListLength(L)*/ /*操作结果:在L中第i(1&lt;=i&lt;=n)个位置之前插入新的数据元素e,L的长度++*/ Status ListInsert(SqList *L,int i,ElemType e){ int k; if(L-&gt;length==MAXSIZE)/*顺序表已满*/ return ERROR; if(i&lt;1||i&gt;L-&gt;length+1)/*如果i不在范围内*/ return ERROR; if(i&lt;=L-&gt;length){ for(k=L-&gt;length+1;k&gt;=i-1;k--)/*将要插入位置后数据元素向后移一位*/ L-&gt;data[k+1]=L-&gt;data[k]; } L-&gt;data[i-1]=e;/*插入新元素*/ L-&gt;length++;/*表长++*/ return OK; } 删除使长度为n的线性表变成长度n-1的线性表，删除第i个元素需要将从i+1至n个元素(共n-i)个元素依次前移一个位置 /*初始条件:顺序线性表L已经存在，1&lt;=i&lt;=ListLength(L)*/ /*操作结果:删除L的第i个数据元素,L的长度--*/ Status ListDelete(SqList *L,int i,ElemType *e){ int k; if(L-&gt;length==0)//线性表为空 return ERROR; if(i&lt;1||i&gt;L-&gt;length+1)/*如果i不在范围内*/ return ERROR; *e=L-&gt;data[i-1]; if(i&lt;L-&gt;length)//如果删除不是最后位置 { for(k=i;k&lt;L-&gt;length;k++) L-&gt;data[k-1]=L-&gt;data[k]; } L-&gt;length--; return OK; } 插入或者删除，时间主要耗费在移动元素上，即与要插入/删除的位置相关。设pi为在第i个元素之前插入一个元素的概率，则移动元素次数期望值*（表长为n） Σpi(n-i+1) 设si为删除第i个元素的概率，则移动元素次数期望值（表长为n） Σsi(n-i) 则有： 插入移动个数：n/2 删除移动个数：(n-1)/2 平均要移动表中一半元素，时间复杂度为O(n),n为表长 最好情况： 如果插入到最后一个位置，或者删除最后一个位置，则时间复杂度为 O(1); 最坏情况： 如果插入到第一个位置或者删除第一个元素，则意味着需要移动所有元素，故时间复杂度为O(n); 平均情况： 由于元素插入到第i个位置，或删除第i个元素，需要移动n-i个元素。根据概率原理，每个位置插入或删除元素的可能性是相同的。 最终平均移动次数和最中间的那个元素的移动次数相等，为n-1/2 实现LA=LAULB，执行时间取决于查找函数，比较次数，则为O(L.length)。union算法复杂度O(La.Length * Lb.Length) bool compare(ElemType c1, ElemType c2) { if(c1 == c2) return 1; else return 0; } int LocateElem_Sq(SqList L,ElemType e)//在顺序线性表L中查找第1个值与e相同的元素的位序 //若找到，则返回其在L中的位序，否则返回0 { int i = 1;//i的初值为第1个元素的位序 ElemType *p = L.elem;//i的初值为第1个元素的位序 while((i&lt;=L.length) &amp;&amp; !(compare(*p++,e))) ++i; if(i&lt;=L.length) return i; else return 0; }//LocateElem_Sq 合并有序顺序表： 复杂度O(La.length+Lb.length) void MergeList_Sq(SqList La,SqList Lb,SqList &amp;Lc)//已知顺序线性表La和Lb的元素按值非递减排列 //归并La和Lb得到新的顺序线性表Lc,Lc的元素也按值非递减排列 { ElemType *pa = La.elem; ElemType *pb = Lb.elem; Lc.listsize = Lc.length = La.length+Lb.length; ElemType* pc = Lc.elem = (ElemType *)malloc(Lc.listsize*sizeof(ElemType)); if(!Lc.elem) exit(1);//存储分配失败 ElemType* pa_last = La.elem + La.length - 1; ElemType* pb_last = Lb.elem + Lb.length - 1; while(pa&lt;=pa_last &amp;&amp; pb&lt;=pb_last)//归并 { if(*pa &lt;= *pb) *pc++ = *pa++; else *pc++ = *pb++; } while(pa&lt;=pa_last) *pc++ = *pa++;//插入La的剩余元素 while(pb&lt;=pb_last) *pc++ = *pb++;//插入Lb的剩余元素 *pc = &#39;\\0&#39;;//添加以截断 } 线性表的链式表示与实现typedef struct LNode{ ElemType data; struct LNode *next; }LNode,*LinkList; 特点：不要求逻辑相邻的元素物理位置上相邻，但是失去了可以随机存取的优点。 线性链表：一组任意的存储单元存储数据元素。 一个结点包括数据域和指针域，n个结点链接为链表。 每个结点只包含一个指针域的话称之为线性链表或单链表 存取必须从头指针（指向链表中第一个结点的位置）开始，最后一个结点指针为空。 typedef struct LNode{ ElemType data; struct LNode *next; }LNode,*LinkList; 有时候，第一个结点之前可以设置一个头结点，指针域指向第一个结点。若为空表则头指针指针域为空 则获取元素的算法实现： /*获取线性表的第i个元素的值*/ Status Getlem(LinkList *L, int i, ElemType &amp;e) { p = L-&gt;next;j=1; while(p&amp;&amp;j&lt;i){ p=p-&gt;next; j++; } if(!p||j&gt;i) return ERROR; e = p-&gt;data; return OK; } 时间复杂度为O(n) 单链表中的插入与删除： 插入操作： 先生成一个结点s,再修改相应的指针域 s-&gt;next=p-&gt;next;p-&gt;next=s; 删除操作： 直接修改a的指针域 a-&gt;next=a-&gt;next-&gt;next 因此插入删除均只需要修改指针域就可以实现 插入代码： Status ListInsert(LinkList *L;int i;ElemType e){ int j; LinkList p,s; &amp;p = L; j = 1; while(p&amp;&amp;j&lt;i){ p = p-&gt;next; j++; } if(!p||j&gt;i){ return ERROR; } s =(LinkList)malloc(sizeof(Node)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return OK; } 删除代码： Status ListDelete(LinkList *L;int i;ElemType e){ int j; LinkList p,q; &amp;p = L; j=1; while(p-&gt;next&amp;&amp;j&lt;i){ p=p-&gt;next; j++; } if(!(p-&gt;next)||j&gt;i){ return ERROR; } q = p-&gt;next; p-&gt;next = q-&gt;next; *e = q-&gt;data; free(q); return Ok } 算法复杂度为O(n) 建立单链表算法复杂度也为O(n) void CreatList_L(LinkList &amp;L,int n){ L = (LinkList)malloc(sizeof(LNode)); L-&gt;next = NULL; for(i=n;i&gt;0;i--){ p=(LinkList)malloc(sizeof(LNode)); scanf(&amp;p-&gt;data); p-&gt;next = L-&gt;next; L-&gt;next = p; } } 两个链表合并： 三个指针pa,pb,pc pc指向Lc表中最后一个结点，pa,pb分别指向La,Lb中第一个结点。当pa-&gt;data &lt;= pb-&gt;data,则将pa所指结点链接到pc所指结点之后,否则就是pb. void MergeList_L(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc){ pa=La-&gt;next; pb=Lb-&gt;next; Lc=pc=La;//La的头结点作为Lc的头结点 while(pa&amp;&amp;pb){ if(pa-&gt;data&lt;=pb-&gt;data){ pc-&gt;next =pa; pc=pa; pa=pa-&gt;next; } else{ pc-&gt;next = pb; pc = pb; pb = pb-&gt;next; } } pc-&gt;next = pa?pa:pb;//插入剩余段 free(Lb); } 两个链表归并只需要重新链接结点就好。 静态链表#define MAXSIZE 1000 typedef struct{ ElemType data; int cur; } 一维数组描述的链表称之为静态链表 定位函数 int LocateElem_SL(SLinkList S,ElemType e){ i=S[0].cur; while(i&amp;&amp;s[i].data!=e) i=S[i].cur; return i; } 循环链表表中最后一个结点的指针指向头结点，整个链表形成一个环。 合并的话，只需要将表尾与表头相连接，运算时间为O(1) 双向链表指针域中存放前驱和后继两个指针 typedef struct DuLNode{ ElemType data; struct DuLNode *prior; struct DuLNode *next; }DuLNode,*DuLinkList; 插入或者删除均需要修改两个方向上的指针，于是时间复杂度为O(n) Status ListInsert_DuL(DuLinkList &amp;L,int i,ElemType e){ if(!(p=GetElemP_DuL(L,i)))//在L中确定插入位置 return ERROR; //P=NULL,插入位置不合法 if(!(s=(DuLinkList)malloc(sizeof(DuLNode)))) return ERROR; s-&gt;data=e; s-&gt;prior = p-&gt;prior; p-&gt;prior-&gt;next = s; s-&gt;next = p; p-&gt;prior = s; return OK; } Status ListDelete_DuL(DuLinkList &amp;L,int i;ElemType &amp;e){ if(!(p=GetElemP_DuL(L,i))) return ERROR; e=p-&gt;data; p-&gt;prior-&gt;next=p-&gt;next; p-&gt;next-&gt;prior=p-&gt;prior; free(p); return OK; }","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"OS虚拟内存管理","slug":"OS虚拟内存管理","date":"2020-11-18T07:33:01.000Z","updated":"2020-11-19T13:15:51.144Z","comments":true,"path":"posts/8c7e9ffb.html","link":"","permalink":"https://fallensue.cc/posts/8c7e9ffb.html","excerpt":"","text":"OS虚拟内存管理背景将整个程序置于内存中，其实不是必要的： 程序处理异常错误条件的代码几乎不怎么执行 数组、链表、表所分配的内存量多于实际的值 程序的某些功能和选项几乎不用 即使在需要整个程序的情况下， 也可能并不同时需要整个程序，分段能够执行只有部分处于内存的程序，可以带来许多好处。 程序不再受物理内存的可用量所限制，用户能够给一个巨大的虚拟地址空间编写程序，简化了编程的任务。 由于每个程序占用较少的物理内存，可以同时运行更多的程序，增加了CPU的利用率以及吞吐量，但没有增加响应时间或者周转时间。 由于加载或交换每个用户程序到内存所需的I/O会更少， 用户程序会运行得更快。因此， 运行不完全处于内存的程序将使系统和用户都受益。 虚拟内存将用户逻辑与物理内存分开。进程的虚拟地址空间就是进程如何在内存中存放的逻辑视图。 除了将逻辑内存与物理内存分开外，虚拟内存允许文件和内存通过共享页而为多个进程所共享。这带来了以下好处： 通过将共享对象映射到虚拟地址空间中， 系统库可以为多个进程所共享。 类似地， 虚拟内存允许进程共享内存。 当通过系统调用fork()创建进程时， 可以共享页面， 从而加快进程创建。 请求调页如何从磁盘加载可执行程序到内存？一种选择是，在程序执行时将整个程序加载到物理内存。(但是这种方法的一个问题是，最初可能不需要整个程序都处于内存) 另一种策略是，仅在需要时才加载页面。这种技术被称作请求调页，常常用于虚拟内存系统。不过， 不是将整个进程交换到内存中， 而是采用惰性交换器(lazy swapper), 惰性交换器除非需要某个页面， 否则从不将它交换到内存中。 基本概念调页程序不是调入整个进程， 而是把那些要使用的页调入内存。这样， 调页程序就避免了读入那些不使用的页， 也减少了交换时间和所需的物理内存空间。 使用这种方案需要一定形式的硬件支持， 以区分内存的页面和磁盘的页面。 请注意， 如果进程从不试图访问标记为无效的页面， 那么并没有什么影响。因此， 如果猜测正确并且只调入所有实际需要的页面， 那么进程就如同所有页面都已调入内存一样正常运行。当进程执行和访问那些内存驻留(memory resident)的页面时，执行会正常进行。 对标记为无效的页面访问会产生缺页错误(page fault)。分页硬件在通过页表转换地址时会注意到无效位被设置， 从而陷入操作系统。这种陷阱是由于操作系统未能将所需的页面调入内存引起的。 纯请求调页：当操作系统将指令指针设置为进程的第一条指令时， 由于它所在的页面并不在内存中， 进程立即出现缺页错误。当该页面调入内存后， 进程继续执行；根据需要发生缺页错误， 直到所需每个页面都在内存中。这时， 它可以在没有更多缺页错误的情况下执行。 程序具有局部引用，这使得请求调页具有较为合理的性能。 请求调页的性能请求调页可以显著影响计算机系统的性能。为了说明起见， 下面计一下请求调页内存的有效访问时间。 设p为缺页错误的概率(0&lt;=p&lt;=1) 。希望p接近于0, 即缺页错误很少。那么有效访问时间为：有效访问时间＝（1-p) x ma+ p x缺页错误时间。 总之， 对于请求调页， 降低缺页错误率是极为重要的。否则， 会增加有效访问时间， 从而极大地减缓了进程的执行速度。请求调页的另一个方面是交换空间的处理和整体使用。 写时复制它通过允许父进程和子进程最初共享相同的页面来工作。这些共享页面标记为写时复制， 这意味着如果任何一个进程写入共享页面， 那么就创建共享页面的副本。 显然， 当使用写时复制技术时， 仅复制任何一进程修改的页面， 所有未修改的页面可以由父进程和子进程共享。还要注意， 只有可以修改的页面才需要标记为写时复制。不能修改的页面（包含可执行代码的页面）可以由父进程和子进程共享。 页面置换基本页面置换页面置换采用以下方法。如果没有空闲帧， 那么就查找当前不在使用的一个帧， 并释放它。可以这样来释放一个帧：将其内容写到交换空间， 并修改页表（和所有其他表）， 以表示该页不在内存中。现在可使用空闲帧， 来保存进程出错的页面。 采用修改位(modify bit)（或脏位(dirty bit）） 可减少这种开销。当采用这种方案时， 每个页面或帧都有一个修改位， 两者之间的关联采用硬件。当要选择一个页面进行置换时， 就检查它的修改位。如果该位已被设置， 那么该页面从磁盘读入以后已被修改。 页面置换是请求调页的基础。它完成了逻辑内存和物理内存之间的分离。采用这种机制， 较小的物理内存能为程序员提供巨大的虚拟内存。 为实现请求调页， 必须解决两个主要问题：应设计帧分配算法和页面置换算法。 FIFO页面置换最简单的页面置换算法是FIFO算法。FIFO页面置换算法为每个页面记录了调到内存的时间。当必须置换页面时， 将选择最旧的页面。请注意， 并不需要记录调入页面的确切时间。可以创建一个FIFO队列， 来管理所有的内存页面。置换的是队列的首个页面。当需要调入页面到内存时， 就将它加到队列的尾部。 FIFO页面置换算法易于理解和编程。然而， 它的性能并不总是十分理想。一方面， 所置换的页面可以是很久以前使用过但现已不再使用的初始化模块。另一方面， 所置换的页面可以包含一个被大量使用的变量，它早就初始化了， 但仍在不断使用。 采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。这个最意想不到的结果被称为Belady异常。 最优页面置换(OPT或者MIN)具有所有算法最低的缺页错误率，并且不会遭受Belady异常，简单地说就是置换最长时间不会使用的页面。 但是，最优置换算法难以实现，因为它需要引用串的未来知识，所以主要用于比较研究。 LRU页面置换置换最长时间没有使用的页，这种方法被称为最近最少使用算法。 LRU置换将每个页面与它的上次使用的时间关联起来，这种策略可当作在时间上向后看而不是向前看的最优页面置换算法。 如何实现LRU呢？主要问题是确定由上次使用时间定义的帧的顺序。 计数器：在最简单的情况下，为每个页表条目关联一个使用时间域，并为CPU 添加一个逻辑时钟或计数器。这种方案需要搜索页表以查找LRU 页面，而且每次内存访问都要写到内存（到页表的使用时间域）。当页表更改时（由于CPU 调度）， 还必须保留时间。时钟溢出也要考虑。 堆栈：采用页码堆栈，每当页面被引用是，他就从堆栈中移除并放在顶部。这样，最近使用的页面总是在栈的顶部，最近最少使用的页面总是在底部。 这个置换同样没有Belady异常。 近似LRU页面置换很少有计算机系统能够提供足够的硬件来支持真正的LRU页面置换算法。许多系统都通过引用位的形式提供一定的支持。 最初， 所有引用位由操作系统清零（至0)。当用户进程执行时， 每个引用到的页面引用位由硬件设置（至1）。一段时间后， 我们可以通过检查引用位来确定哪些页面已被使用，哪些页面尚未使用， 虽说我们不知道使用的顺序。 额外引用位算法通过定期记录引用位，我们可以获得额外的排序信息。可以为内存中发的页表的每个页面保留一个8位的字节。在极端情况下， 位数可降为0, 即只有引用位本身。这种算法称为第二次机会页面置换算法。 第二次机会算法第二次机会置换的基本算法是一种FIFO置换算法。然而， 当选择了一个页面时， 需要检查其引用位。如果值为0, 那么就直接置换此页面；如果引用位设置为1，那么就给此页面第二次机会， 并继续选择下一个FIFO页面。 实现第二次机会算法（有时称为时钟算法(clock algorithm)) 的一种方式是采用循环队列。指针（即时钟指针）指示接下来要置换哪个页面。当需要一个帧时， 指针向前移动直到找到一个引用位为0的页面。在向前移动时， 它会清除引用位。一旦找到牺牲页面， 就置换该页面， 并且在循环队列的这个位置上插入新页面。注意， 在最坏的情况下，当所有位都巳设置， 指针会循环遍历整个队列， 给每个页面第二次机会。在选择下一个页面进行置换之前， 它将清除所有引用位。 如果所有位都为1，第二次机会置换退化为FIFO置换。 增强型第二次机会算法通过将引用位和修改位作为有序对， 可以改进二次机会算法。有了这两个位， 就有下面四种可能的类型： (0,0) 最近没有使用且没有修改的页面，最佳的页面置换。 (0,1) 最近没有使用但修改过的页面，不太好的置换，因为在置换前需要将页面写出。 (1,0) 最近使用过但没有修改的页面，可能很快再次使用。 (1,1) 最近使用过且修改过，可能很快再次使用，并且在置换前需要将页面写出到磁盘。 这种算法与更为简单的时钟算法的主要区别在于：这里为那些已修改页面赋予更高级别， 从而降低了所需I/O数量。 基于计数的页面置换页面置换还有许多其他算法。例如， 可以为每个页面的引用次数保存一个计数器， 并且开发以下两个方案。 最不经常使用(LFU) 最经常使用(MFU) 页面缓冲算法除了特定页面置换算法之外， 还经常采用其他措施。例如， 系统通常保留一个空闲帧缓冲池。当出现缺页错误时， 会像以前一样选择一个牺牲帧。 这种方法的扩展之一是， 维护一个修改页面的列表。每当调页设备空闲时， 就选择一个修改页面以写到磁盘上， 然后重置它的修改位。 另一种修改是， 保留一个空闲帧池， 并且记住哪些页面在哪些帧内。 应用程序与页面置换在某些情况下， 通过操作系统的虚拟内存访问数据的应用程序比操作系统根本没有提供缓冲区更差。 另一个例子是数据仓库， 它频繁地执行大址的、顺序的磁盘读取， 随后计算并写入。LRU 算法会删除旧的页面并保留新的页面， 而应用程序将更可能读取较旧的页面而不是较新的页面（因为它再次开始顺序读取）。 系统抖动事实上， 需要研究一下没有“ 足够＂ 帧的进程。如果进程没有需要支待活动使用页面的帧数， 那么它会很快产生缺页错误。此时， 必须置换某个页面。然而， 由于它的所有页面都在使用中， 所以必须立即置换需要再次使用的页面。因此， 它会再次快速产生缺页错误， 再一次置换必须立即返回的页面， 如此快速进行。 这种高度的页面调度活动称为抖动(thrashing)。如果一个进程的调页时间多于它的执行时间，那么这个进程就是在抖动。 通过局部置换算法(localreplacement algorithm)或优先权置换算法(priority replacement al gorithm),可以限制系统抖动。如果一个进程开始抖动， 那么由于采用局部置换， 它不能从另一个进程中获取帧， 而且也不能导致后者抖动。这种方法定义了进程执行的局部性模型(locality model)。 工作集模型如上所述， 工作集模型(working-set model)是基于局部性假设的。这个模型采用参数▲定义工作集窗口(working-setwindow)。它的思想是检查最近▲个页面引用。这最近▲个页面引用的页面集合称为工作集(working-set)（如图9-20所示）。如果一个页面处于活动使用状态， 那么它处在工作集中。如果它不再使用， 那么它在最后一次引用的▲ 时间单位后， 会从工作集中删除。 例如， 给定如图所示的内存引用序列， 如果▲为10个内存引用， 那么t1时的工作集为{1, 2, 5, 6, 7}。 工作集的精度取决于▲ 的选择。如果▲太小， 那么它不能包含整个局部；如果▲太大， 那么它可能包含多个局部。在极端情况下， 如果▲为无穷大， 那么工作集为进程执行所需的所有页面的集合。因此， 最重要的工作集属性是它的大小。如果系统内的每个工作集通过计算为wss,,那么就得到D=IWSS;这里D为帧的总需求量。每个进程都使用其工作集内的页面。因此， 进程l需要WSS;帧。如果总需求大千可用帧的总数(D&gt;m)， 则将发生抖动， 因此有些进程得不到足够的帧数。","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://fallensue.cc/tags/OS/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-绪论","slug":"数据结构绪论","date":"2020-11-18T07:33:01.000Z","updated":"2020-11-19T13:23:57.037Z","comments":true,"path":"posts/75bf7760.html","link":"","permalink":"https://fallensue.cc/posts/75bf7760.html","excerpt":"","text":"什么是数据结构图书馆书目检索自动化：文件管理的数学模型，对象之间存在简单的线性关系，线性的数据结构 计算机与人对弈：格局，结果构成一棵“树”，一个数学模型，同为数据结构 十字路口交通灯的管理：“图”，同样为数据结构 基本概念以及术语数据：符号 数据元素：数据基本单位，可由若干个数据项构成 数据项：最小单位，不可分割 数据对象：数据的一个子集 数据结构：相互之间存在一种或多种关系的数据元素的集合 相互的关系称为结构 4类基本结构： （1）集合：数据元素仅同属于一个集合，无他关系 （2）线性结构：元素之间一对一关系 （3）树形结构：元素之间一对多关系 （4）图形结构或者网状结构：元素之间多对多关系 数据结构（D，S）二元组表示 D：数据元素有限集 S: D上关系有限集 结构中的“关系”为逻辑关系也可称之为逻辑结构 数据结构在计算机中表示（映像）可称为数据的物理结构（存储结构） 两种不同表示：顺序映像，非顺序映像 存储结构：链式（借助指针），顺序（相对位置） 数据类型：原子类型（整型、实型、字符型、枚举型……），结构类型 抽象数据类型（ADT）：数学模型以及定义在此模型上的一组操作 ADT构成：原子类型，固定聚合类型，可变聚合类型 算法与算法分析算法：问题求解步骤的一种描述 重要特性：（1）有穷性（2）确定性（3）可行性（4）输入（5）输出 好算法：正确，可读，健壮，效率 效率度量 两种办法：（1）事后统计（2）事前分析 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++){ c[i][j]=0; for(k=1;k&lt;=n;k++) c[i][j]+=a[i][k]*b[k][j]; } 上述代码整个算法执行时间与基本操作（乘法执行次数n^3成正比，则记作T(n)=O(n^3)）。 算法的时间量度：T(n)=O(f(n)) f(n):问题规模n的某个函数 T(n):算法时间复杂度 a){x++;s=0;} b)for(i=1;i&lt;=n;i++){x++;s+=x;} c)for(j=1;j&lt;=n;j++) for(k=1;k&lt;=n;k++){++x;s+=x;} X++语句频度分别为1，n和n^2，时间复杂度分别为O(1),O(n),O(n^2)（常量阶，对数阶，平方阶）尽量让复杂度小。 求复杂度一般考虑最坏情况，及关于n的表达式增长最快的项。 void bubble_sort(int a[],int n){ //将 a中整数序列重新排列成自大到小有序的整数序列。 for(i=n-1,change=TRUE;i&gt;=1&amp;&amp;change;i--){ change=FALSE; for(j=0;j&lt;i;j++) if(a[j]&gt;a[j+1]){a[j]←→a[j+1];change=TRUE;} } } 如上冒泡排序，最坏情况为a中序列自大到小，时间复杂度为T(n)=O(n^2) 空间复杂度：算法存储空间的量度 S(n)=O(f(n))","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-图最小生成树","slug":"数据结构-图最小生成树","date":"2020-11-18T07:30:01.000Z","updated":"2020-11-19T13:19:22.413Z","comments":true,"path":"posts/cededa76.html","link":"","permalink":"https://fallensue.cc/posts/cededa76.html","excerpt":"","text":"最小生成树定义在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。 构造网的最小生成树必须解决下面两个问题： 1、尽可能选取权值小的边，但不能构成回路； 2、选取n－1条恰当的边以连通n个顶点； 普里姆(prim)算法1.prim算法 基本思想：假设G＝(V，E)是连通的，TE是G上最小生成树中边的集合。算法从U＝{u0}（u0∈V）、TE＝{}开始。重复执行下列操作： 在所有u∈U，v∈V－U的边(u，v)∈E中找一条权值最小的边(u0,v0)并入集合TE中，同时v0并入U，直到V＝U为止。 此时，TE中必有n-1条边，T=(V，TE)为G的最小生成树。 Prim算法的核心:始终保持TE中的边集构成一棵生成树。 注意：prim算法适合稠密图，其时间复杂度为O(n^2)，其时间复杂度与边得数目无关，而kruskal算法的时间复杂度为O(eloge)跟边的数目有关，适合稀疏图。 例子如图 算法设计设最小生成树为T={U,TE}; U={u0};/*起始点*/ TE={}/*一开始没有边*/ while ( T 包含少于n-1条边) {(u,v)是一个花费最少的边，u∈U且v∉U if (没有这样的边) break; 将v添加到U; 将(u,v)添加到TE; } if ( T包含少于n-1条边) printf(&quot;No spanning tree \\n&quot;); C++代码实现: 1.邻接矩阵 #define _CRT_SECURE_NO_WARNINGS #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;vector&gt; using namespace std; //首先是使用邻接矩阵完成Prim算法 struct Graph { int vexnum; //顶点个数 int edge; //边的条数 int** arc; //邻接矩阵 string* information; //记录每个顶点名称 }; //作为记录边的信息，这些边都是达到end的所有边中，权重最小的那个 struct Assis_array { int start; //边的终点 int end; //边的起点 int weight; //边的权重 }; void CreateGraph(Graph &amp;g){ cout &lt;&lt; &quot;请输入边的条数，顶点个数&quot; &lt;&lt; endl; cin &gt;&gt; g.edge; cin &gt;&gt; g.vexnum; g.information = new string[g.vexnum]; g.arc = new int* [g.vexnum]; /*初始化矩阵*/ for (int i = 0; i &lt; g.vexnum;i++) { g.arc[i] = new int[g.vexnum]; g.information[i] = &quot;v&quot; + to_string(i + 1);//每个顶点进行命名 for (int k = 0; k &lt; g.vexnum; k++) { g.arc[i][k] = INT_MAX; } } cout &lt;&lt; &quot;请输入每条边之间的顶点编号(顶点编号从1开始),以及该边的权重：&quot; &lt;&lt; endl; for (int i = 0; i &lt; g.edge; i++) { int start; int end; cin &gt;&gt; start; //输入每条边的起点 cin &gt;&gt; end; //输入每条边的终点 int weight; cin &gt;&gt; weight; g.arc[start - 1][end - 1] = weight;//无向图的边是相反的 g.arc[end - 1][start - 1] = weight; } } //打印图 void print(Graph g) { int i; for (i = 0; i &lt; g.vexnum; i++) { //cout &lt;&lt; g.information[i] &lt;&lt; &quot; &quot;; for (int j = 0; j &lt; g.vexnum; j++) { if (g.arc[i][j] == INT_MAX) cout &lt;&lt; &quot;∞&quot; &lt;&lt; &quot; &quot;; else cout &lt;&lt; g.arc[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } } void Prim(Graph g, int begin) { //close_edge这个数组记录到达某个顶点的各个边中的权重最大的那个边 Assis_array* close_edge = new Assis_array[g.vexnum]; int j; //进行close_edge的初始化，更加开始起点进行初始化 for (j = 0; j &lt; g.vexnum; j++) { if (j != begin - 1) { close_edge[j].start = begin - 1; close_edge[j].end = j; close_edge[j].weight = g.arc[begin - 1][j]; } } //把起点的close_edge中的值设置为-1，代表已经加入到集合U了 close_edge[begin - 1].weight = -1; //访问剩下的顶点，并依次加入到集合U for (j = 1; j &lt; g.vexnum; j++) { int min = INT_MAX; int k; int index; for (k = 0; k &lt; g.vexnum; k++) { if (close_edge[k].weight != -1) { if (close_edge[k].weight &lt; min) { min = close_edge[k].weight; index = k; } } } //将权重最小的那条边的终点也加入到集合U close_edge[index].weight = -1; //输出对应的边的信息 cout &lt;&lt; g.information[close_edge[index].start] &lt;&lt; &quot;-----&quot; &lt;&lt; g.information[close_edge[index].end] &lt;&lt; &quot;=&quot; &lt;&lt; g.arc[close_edge[index].start][close_edge[index].end] &lt;&lt; endl; //更新我们的close_edge数组。 for (k = 0; k &lt; g.vexnum; k++) { if (g.arc[close_edge[index].end][k] &lt; close_edge[k].weight) { close_edge[k].weight = g.arc[close_edge[index].end][k]; close_edge[k].start = close_edge[index].end; close_edge[k].end = k; } } } } 2.邻接表 #define _CRT_SECURE_NO_WARNINGS #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; //表结点 struct ArcNode { int adjvex; //某条边指向的那个顶点的位置（一般是数组的下标）。 ArcNode* next; //指向下一个表结点 int weight; //边的权重 }; //头结点 struct Vnode { ArcNode* firstarc; //第一个和该顶点依附的边 的信息 string data; //记录该顶点的信息。 }; struct Graph_List { int vexnum; //顶点个数 int edge; //边的条数 Vnode* node; //顶点表 }; //创建图，是一个重载函数 void createGraph(Graph_List&amp; g) { cout &lt;&lt; &quot;请输入顶点数：输入顶点边的个数：&quot; &lt;&lt; endl; cin &gt;&gt; g.vexnum; cin &gt;&gt; g.edge; g.node = new Vnode[g.vexnum]; int i; for (i = 0; i &lt; g.vexnum; i++) { g.node[i].data = &quot;v&quot; + std::to_string(i + 1); //对每个顶点进行命名 g.node[i].firstarc = NULL;//初始化每个顶点的依附表结点 } cout &lt;&lt; &quot;请输入每条边之间的顶点编号(顶点编号从1开始),以及该边的权重：&quot; &lt;&lt; endl; for (i = 0; i &lt; g.edge; i++) { int start; int end; cin &gt;&gt; start; //输入每条边的起点 cin &gt;&gt; end; //输入每条边的终点 int weight; cin &gt;&gt; weight; ArcNode* next = new ArcNode; next-&gt;adjvex = end - 1; next-&gt;next = NULL; next-&gt;weight = weight; //如果第一个依附的边为空 if (g.node[start - 1].firstarc == NULL) { g.node[start - 1].firstarc = next; } else { ArcNode* temp; //临时表结点 temp = g.node[start - 1].firstarc; while (temp-&gt;next) {//找到表结点中start-1这个结点的链表的最后一个顶点 temp = temp-&gt;next; } temp-&gt;next = next; //在该链表的尾部插入一个结点 } //因为无向图边是双向的 ArcNode* next_2 = new ArcNode; next_2-&gt;adjvex = start - 1; next_2-&gt;weight = weight; next_2-&gt;next = NULL; //如果第一个依附的边为空 if (g.node[end - 1].firstarc == NULL) { g.node[end - 1].firstarc = next_2; } else { ArcNode* temp; //临时表结点 temp = g.node[end - 1].firstarc; while (temp-&gt;next) {//找到表结点中start-1这个结点的链表的最后一个顶点 temp = temp-&gt;next; } temp-&gt;next = next_2; //在该链表的尾部插入一个结点 } } } void print(Graph_List g) { cout &lt;&lt; &quot;图的邻接表：&quot; &lt;&lt; endl; for (int i = 0; i &lt; g.vexnum; i++) { cout &lt;&lt; g.node[i].data &lt;&lt; &quot; &quot;; ArcNode* next; next = g.node[i].firstarc; while (next) { cout &lt;&lt; &quot;(&quot; &lt;&lt; g.node[i].data &lt;&lt; &quot;,&quot; &lt;&lt; g.node[next-&gt;adjvex].data &lt;&lt; &quot;)=&quot; &lt;&lt; next-&gt;weight &lt;&lt; &quot; &quot;; next = next-&gt;next; } cout &lt;&lt; &quot;^&quot; &lt;&lt; endl; } } //作为记录边的信息，这些边都是达到end的所有边中，权重最小的那个 struct Assis_array { int start; //边的终点 int end; //边的起点 int weight; //边的权重 }; void Prim(Graph_List g, int begin) { cout &lt;&lt; &quot;图的最小生成树：&quot; &lt;&lt; endl; //close_edge这个数组记录到达某个顶点的各个边中的权重最大的那个边 Assis_array* close_edge = new Assis_array[g.vexnum]; int j; for (j = 0; j &lt; g.vexnum; j++) { close_edge[j].weight = INT_MAX; } ArcNode* arc = g.node[begin - 1].firstarc; while (arc) { close_edge[arc-&gt;adjvex].end = arc-&gt;adjvex; close_edge[arc-&gt;adjvex].start = begin - 1; close_edge[arc-&gt;adjvex].weight = arc-&gt;weight; arc = arc-&gt;next; } //把起点的close_edge中的值设置为-1，代表已经加入到集合U了 close_edge[begin - 1].weight = -1; //访问剩下的顶点，并加入依次加入到集合U for (j = 1; j &lt; g.vexnum; j++) { int min = INT_MAX; int k; int index; //寻找数组close_edge中权重最小的那个边 for (k = 0; k &lt; g.vexnum; k++) { if (close_edge[k].weight != -1) { if (close_edge[k].weight &lt; min) { min = close_edge[k].weight; index = k; } } } //输出对应的边的信息 cout &lt;&lt; g.node[close_edge[index].start].data &lt;&lt; &quot;-----&quot; &lt;&lt; g.node[close_edge[index].end].data &lt;&lt; &quot;=&quot; &lt;&lt; close_edge[index].weight &lt;&lt; endl; //将权重最小的那条边的终点也加入到集合U close_edge[index].weight = -1; //更新我们的close_edge数组. ArcNode* temp = g.node[close_edge[index].end].firstarc; while (temp) { if (close_edge[temp-&gt;adjvex].weight &gt; temp-&gt;weight) { close_edge[temp-&gt;adjvex].weight = temp-&gt;weight; close_edge[temp-&gt;adjvex].start = index; close_edge[temp-&gt;adjvex].end = temp-&gt;adjvex; } temp = temp-&gt;next; } } } 克鲁斯卡尔(Kruskal)算法基本思想： （1）将图中的所有边都去掉。（2）将边按权值从小到大的顺序添加到图中，保证添加的过程中不会形成环（3）重复上一步直到连接所有顶点，此时就生成了最小生成树。这是一种贪心策略。 算法设计T= { }; while ( T contains less than n-1 edges &amp;&amp; E is not empty) { choose a least cost edge (v,w) from E delete (v,w) from E; If ((v,w) does not create a cycle in T) add (v,w) to T else discard (v,w); } if (T contains fewer than n-1 edges) printf(&quot;No spanning tree\\n&quot;) 代码实现： 边集数组表示图 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; //检验输入边数和顶点数的值是否有效，可以自己推算为啥： //顶点数和边数的关系是：((Vexnum*(Vexnum - 1)) / 2) &lt; edge bool check(int Vexnum,int edge) { if (Vexnum &lt;= 0 || edge &lt;= 0 || ((Vexnum*(Vexnum - 1)) / 2) &lt; edge) return false; return true; } //判断我们每次输入的的边的信息是否合法 //顶点从1开始编号 bool check_edge(int Vexnum, int start ,int end, int weight) { if (start&lt;1 || end&lt;1 || start&gt;Vexnum || end&gt;Vexnum || weight &lt; 0) { return false; } return true; } //边集结构，用于保存每条边的信息 typedef struct edge_tag { bool visit; //判断这条边是否加入到了最小生成树中 int start; //该边的起点 int end; //该边的终点 int weight; //该边的权重 }Edge; //创建一个图，但是图是使用边集结构来保存 void createGraph(Edge * &amp;e,int Vexnum, int edge) { e = new Edge[edge];//为每条边集开辟空间 int start = 0; int end = 0; int weight = 0; int i = 0; cout &lt;&lt; &quot;输入每条边的起点、终点和权重：&quot; &lt;&lt; endl; while (i != edge) { cin &gt;&gt; start &gt;&gt; end &gt;&gt; weight; while (!check_edge(Vexnum, start, end, weight)) { cout &lt;&lt; &quot;输入的值不合法，请重新输入每条边的起点、终点和权重：&quot; &lt;&lt; endl; cin &gt;&gt; start &gt;&gt; end &gt;&gt; weight; } e[i].start = start; e[i].end = end; e[i].weight = weight; e[i].visit = false; //每条边都还没被初始化 ++i; } } //我们需要对边集进行排序，排序是按照每条边的权重，从小到大排序。 int cmp(const void* first, const void * second) { return ((Edge *)first)-&gt;weight - ((Edge *)second)-&gt;weight; } //好了，我们现在需要做的是通过一定的方式来判断 //如果我们把当前的边加入到生成树中是否会有环出现。 //通过我们之前学习树的知识，我们可以知道如果很多棵树就组成一个森林，而且 //如果同一颗树的两个结点在连上一条边，那么就会出现环， //所以我们就通过这个方式来判断加入了一个新的边后，是否会产生环， //开始我们让我们的图的每个顶点都是一颗独立的树，通过不断的组合，把这个森林变 //成来源于同一颗顶点的树 //如果不理解，画个图就明白了， //首先是找根节点的函数, //其中parent代表顶点所在子树的根结点 //child代表每个顶点孩子结点的个数 int find_root(int child, int * parent) { //此时已经找到了该顶点所在树的根节点了 if (parent[child] == child) { return child; } //往前递归，寻找它父亲的所在子树的根结点 parent[child] = find_root(parent[child], parent); return parent[child]; } //合并两个子树 bool union_tree(Edge e, int * parent, int * child) { //先找出改边所在子树的根节点 int root1; int root2; //记住我们顶点从1开始的，所以要减1 root1 = find_root(e.start-1, parent); root2 = find_root(e.end-1, parent); //只有两个顶点不在同一颗子树上，才可以把两棵树并未一颗树 if (root1 != root2) { //小树合并到大树中，看他们的孩子个数 if (child[root1] &gt; child[root2]) { parent[root2] = root1; //大树的孩子数量是小树的孩子数量加上 //大树的孩子数量在加上小树根节点自己 child[root1] += child[root2] + 1; } else { parent[root1] = root2; child[root2] += child[root1] + 1; } return true; } return false; } //克鲁斯卡算法的实现 void Kruskal() { int Vexnum = 0; int edge = 0; cout &lt;&lt; &quot;请输入图的顶点数和边数：&quot; &lt;&lt; endl; cin &gt;&gt; Vexnum &gt;&gt; edge; while (!check(Vexnum, edge)) { cout &lt;&lt; &quot;你输入的图的顶点数和边数不合法，请重新输入：&quot; &lt;&lt; endl; cin &gt;&gt; Vexnum &gt;&gt; edge; } //声明一个边集数组 Edge * edge_tag; //输入每条边的信息 createGraph(edge_tag, Vexnum, edge); int * parent = new int[Vexnum]; //记录每个顶点所在子树的根节点下标 int * child = new int[Vexnum]; //记录每个顶点为根节点时，其有的孩子节点的个数 int i; for (i = 0; i &lt; Vexnum; i++) { parent[i] = i; child[i] = 0; } //对边集数组进行排序，按照权重从小到达排序 qsort(edge_tag, edge, sizeof(Edge), cmp); int count_vex; //记录输出的边的条数 count_vex = i = 0; while (i != edge) { //如果两颗树可以组合在一起，说明该边是生成树的一条边 if (union_tree(edge_tag[i], parent, child)) { cout &lt;&lt; (&quot;v&quot; + std::to_string(edge_tag[i].start)) &lt;&lt; &quot;-----&quot; &lt;&lt; (&quot;v&quot; + std::to_string(edge_tag[i].end)) &lt;&lt;&quot;=&quot; &lt;&lt; edge_tag[i].weight &lt;&lt; endl; edge_tag[i].visit = true; ++count_vex; //生成树的边加1 } //这里表示所有的边都已经加入成功 if (count_vex == Vexnum - 1) { break; } ++i; } if (count_vex != Vexnum - 1) { cout &lt;&lt; &quot;此图为非连通图！无法构成最小生成树。&quot; &lt;&lt; endl; } delete [] edge_tag; delete [] parent; delete [] child; }","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-图的遍历","slug":"数据结构-图的遍历","date":"2020-11-15T12:00:01.000Z","updated":"2020-11-19T13:16:58.608Z","comments":true,"path":"posts/2b6326c7.html","link":"","permalink":"https://fallensue.cc/posts/2b6326c7.html","excerpt":"","text":"图的遍历深度优先遍历步骤 从一个给定的顶点v开始遍历 访问v的第一个邻居w，然后访问w的第一个还没有被访问过的邻居，以此类推。 如果某个结点没有没被访问过的邻居，那么就回溯到上一个访问的结点，并检查它的邻居是否被访问过 重复上边过程直到所有顶点均被访问 结果为V1,V2,V4,V8,V5,V6,V3,V7 算法的难点： 如何判断是否已经访问过某个顶点？ 如何搜索顶点的邻居？ 解决方案： 设置一个数组Visit[n],当第i个顶点已经被访问时, 设置Visit[i]=1. 根据不同的数据结构改变算法设计 代码分析：DFS需要回溯，那么使用递归。 算法： //访问标志的数组,为1表示访问过，为0表示未被访问 int visted[100]; //邻接表的深度优先遍历算法 void AdjacencyList::DFS(GraphAdjList *G, int i) { EdgeNode *p; visted[i] = 1; cout &lt;&lt; G-&gt;adjList[i].data &lt;&lt; &quot;--&quot;; p = G-&gt;adjList[i].firstedge; while (p) { if (!visted[p-&gt;adjvex]) { //递归访问 DFS(G, p-&gt;adjvex); } p = p-&gt;next; } } //邻接表的深度遍历操作 void AdjacencyList::DFSTraverse(GraphAdjList *G) { //初始化所有顶点都没有访问过 cout&lt;&lt;&quot;深度优先遍历结果为：&quot;&lt;&lt;endl; for (int i = 0; i &lt; G-&gt;numVertexes; i++) { visted[i] = 0; } for (int i = 0; i &lt; G-&gt;numVertexes; i++) { if (visted[i] == 0) { DFS(G, i); } } } 广度优先遍历步骤： 从一个顶点v开始访问 访问v的所有邻居 再访问v的第一个邻居w的所有邻居 再访问v的第二个邻居x的所有邻居 结果为V1,V2,V3,V4,V5,V6,V7,V8 BFS逐层访问结点(类似于层级遍历)，当访问每个结点的时候把它存起来，然后在遍历完这一层的结点之后可以溯回访问它相邻的节点，采用队列存储(给定层级上访问的第一个结点就是要返回的结点) 代码分析： 访问开始结点v 初始化一个队列，v入队 当队列不为空时，删除一个结点，将删除结点的所有邻居（如果没被访问），访问它们并将它们入队 重复以上直到队列为空 void BFSTraverse( Graph G ) { for ( v=1; v&lt;=G.vexnum; ++v ) visited[v] = FALSE; InitQueue(Q); for( v=1; v&lt;=G.vexnum; ++v ) if ( !visited[v] ) { visited[v]=TRUE; VISIT(v); EnQueue(Q, v); while (!EmptyQueue(Q)) { DeQueue(Q,u); for(w=FirstAdjVex(G, u); w&gt;0; w=NextAdjVex(G, u, w)) if( !visited[w] ) { visited[w]=TRUE; VISIT(w); EnQueue(Q, w); } } // end while } // end if }","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-图的存储结构","slug":"数据结构-图的存储结构","date":"2020-11-15T11:00:01.000Z","updated":"2020-11-19T13:17:24.553Z","comments":true,"path":"posts/5d8f99e.html","link":"","permalink":"https://fallensue.cc/posts/5d8f99e.html","excerpt":"","text":"图的存储结构邻接矩阵(Adjacency Matrix)定义设G=(V,E)是一个具有n个顶点的图。G的邻接矩阵是一个nxn的二维数组。A[n] [n]. 无向图的邻接矩阵一定是对称的，有向图的邻接矩阵不一定是对称的。 构造一个具有n个顶点与e条边的无向网G的时间复杂度为O(n^2+e*n)，初始化邻接矩阵化了O(n^2)的时间 代码实现邻接矩阵数据类型定义 #define MaxVertices 100 //定义最大容量 typedef struct{ //包含权的邻接矩阵的的定义 int Vertices[MaxVertices]; //顶点信息的数组 int Edge[MaxVertices][MaxVertices]; //边信息的数组 int numV; //顶点数 int numE; //边数 }AdjMatrix; 创建无向图的邻接矩阵 void CreateGraph(AdjMatrix *G) //图的生成函数 { int n,e,vi,vj,w,i,j; printf(&quot;请输入图的顶点数和边数（以空格分隔）：&quot;); scanf(&quot;%d%d&quot;,&amp;n,&amp;e); G-&gt;numV=n;G-&gt;numE=e; for(i=0;i&lt;n;i++) //图的初始化 for(j=0;j&lt;n;j++) { if(i==j) G-&gt;Edge[i][j]=0; else G-&gt;Edge[i][j]=32767; } for(i=0;i&lt;G-&gt;numV;i++) //将顶点存入数组中 { printf(&quot;请输入第%d个顶点的信息:&quot;,i+1); scanf(&quot;%d&quot;,&amp;G-&gt;Vertices[i]); } printf(&quot;\\n&quot;); for(i=0;i&lt;G-&gt;numE;i++) { printf(&quot;请输入边的信息i,j,w(以空格分隔):&quot;); scanf(&quot;%d%d%d&quot;,&amp;vi,&amp;vj,&amp;w); //若为不带权值的图，则w输入1 //若为带权值的图，则w输入对应权值 G-&gt;Edge[vi-1][vj-1]=w;//① G-&gt;Edge[vj-1][vi-1]=w;//② //无向图具有对称性的规律，通过①②实现 //有向图不具备此性质，所以只需要① } } 邻接表(Adjacency List)定义对于图来说，邻接矩阵是不错的一种图存储结构，但是我们也发现，对于边数相对顶点较少的图，这种结构是存在对存储空间的极大浪费的。因此我们考虑另外一种存储结构方式：邻接表（Adjacency List），即数组与链表相结合的存储方法。 每个结点由三个域组成，邻接点域(Adjvex)指示与顶点vi邻接的点在图中的位置，链域(nextarc)指示下一条边或弧的结点；数据域(info)存储和边或弧相关的信息，如权值等。 每个链表有一个表头结点，在表头结点中除了设有链域(firstarc)指向链表中第一个结点之外，还设有存储顶点vi的名或其他相关信息的数据域(data) 如图所示 代码实现#include&lt;iostream&gt; using namespace std; #define MAXVEX 100 /* 最大顶点数,应由用户定义 */ typedef char VertexType; /* 顶点类型应由用户定义 */ typedef int EdgeType; /* 边上的权值类型应由用户定义 */ typedef struct EdgeNode /* 边表结点 */ { int adjvex; /* 邻接点域,存储该顶点对应的下标 */ EdgeType weight; /* 用于存储权值,对于非网图可以不需要 */ struct EdgeNode *next; /* 链域,指向下一个邻接点 */ } EdgeNode; typedef struct VextexNode /* 顶点表结点 */ { VertexType data; /* 顶点域,存储顶点信息 */ EdgeNode *firstedge; /* 边表头指针 */ } VextexNode, AdjList[MAXVEX]; typedef struct { AdjList adjList; int numNodes, numEdges; /* 图中当前顶点数和边数 */ } GraphAdjList; void CreateALGraph(GraphAdjList *Gp) { int i, j, k; EdgeNode *pe; cout &lt;&lt; &quot;输入顶点数和边数(空格分隔）:&quot; &lt;&lt; endl; cin &gt;&gt; Gp-&gt;numNodes &gt;&gt; Gp-&gt;numEdges; for (i = 0 ; i &lt; Gp-&gt;numNodes; i++) { cout &lt;&lt; &quot;输入顶点信息：&quot; &lt;&lt; endl; cin &gt;&gt; Gp-&gt;adjList[i].data; Gp-&gt;adjList[i].firstedge = NULL; /* 将边表置为空表 */ } for (k = 0; k &lt; Gp-&gt;numEdges; k++) /* 建立边表 */ { cout &lt;&lt; &quot;输入边(vi,vj)的顶点序号i,j（空格分隔）:&quot; &lt;&lt; endl; cin &gt;&gt; i &gt;&gt; j; pe = (EdgeNode *)malloc( sizeof(EdgeNode)); pe-&gt;adjvex = j; /* 邻接序号为j */ /* 将pe的指针指向当前顶点上指向的结点 */ pe-&gt;next = Gp-&gt;adjList[i].firstedge; Gp-&gt;adjList[i].firstedge = pe; /* 将当前顶点的指针指向pe */ pe = (EdgeNode *)malloc( sizeof(EdgeNode)); pe-&gt;adjvex = i; pe-&gt;next = Gp-&gt;adjList[j].firstedge; Gp-&gt;adjList[j].firstedge = pe; } } int main( void) { GraphAdjList GL; CreateALGraph(&amp;GL); return 0; } 在建立邻接表以及逆邻接表时，若输入的顶点信息为顶点的编号，则建立邻接表的时间复杂度为O(n+e)，否则，需要通过查找才能得到顶点在图中位置，则时间复杂度为O(n*e)","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-图的基本定义","slug":"数据结构-图基本定义","date":"2020-11-14T13:30:01.000Z","updated":"2020-11-19T13:18:00.953Z","comments":true,"path":"posts/790212ce.html","link":"","permalink":"https://fallensue.cc/posts/790212ce.html","excerpt":"","text":"图的基本定义基本术语图（graph）图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中的顶点的集合，E是图G中边的集合。 顶点(Vertex)图中的数据元素。线性表中我们把数据元素叫元素，树中将数据元素叫结点。 边顶点之间的逻辑关系用边来表示，边集可以是空的。 无向边(Edge)若两个顶点之间的边没有方向，则称这条边为无向边。用(V1,V2)表示。(V1,V2) ≠ (V2,V1) 有向边(弧)(Arc)若两个顶点之间的边有方向，则称这条边为有向边。用&lt;V1,V2&gt;表示，V1为弧尾(Tail)(或终端点)，V2为弧头(Head)(或初始点)。&lt;V1,V2&gt; ≠ &lt;V2,V1&gt; 无向图(Undirected graphs)图中任意两个顶点之间的边都是无向边。 有向图(Directed graphs) 图中任意两个顶点之间的边都是有向边。 完全图(Completed graph) 有(1/2)*n(n-1)条边的无向图称为无向完全图，有n(n-1)条弧的有向图称为有向完全图。 稀疏图(Sparse graph)有很少条边或弧(如e&lt;nlogn)的图。 稠密图(Dense graph):不是稀疏图的图。 权（Weight）与图的边或弧相关的数。 网（Network）带权的图。 子图（Subgraph）假设G=（V,{E}）和G‘=（V’,{E’}），如果V’包含于V且E’包含于E，则称G’为G的子图。 邻接点(Adjacent)如果边(v,w)属于E，则称顶点v与w互为邻接点,v与w相邻接。边(v,w)依附于顶点v与w，或者说(v,w)和顶点v和w相关联。 度(Degree)是与v相关联的边的数目，记为TD(V).有向图中，入度表示指向自己的边的数目，出度表示指向其他边的数目，该顶点的度等于入度与出度的和. 路径(Path)从一个点到另一个的顶点序列，第一个顶点与最后一个顶点相同的路径称为回路或环(Cycle)。序列中顶点不重复的路径称为简单路径。 连通图(Connected graph)图中任意两个顶点都是连通的(从一个顶点到另一个顶点有路径)。 连通分量(Connected Component)无向图中的极大连通子图。 强连通图有向图中任意两个顶点之间都有路径。 生成树极小连通子图，含有图中全部顶点，但只有足以构成一棵树的n-1条边。","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"OS内存管理","slug":"OS内存管理","date":"2020-11-10T13:55:01.000Z","updated":"2020-11-19T13:15:51.144Z","comments":true,"path":"posts/48e0383b.html","link":"","permalink":"https://fallensue.cc/posts/48e0383b.html","excerpt":"","text":"内存管理为什么需要内存管理？原因： 内存越来越不值钱 需要高效的利用CPU的能力 背景CPU根据程序计数器的值从内存中提取指令，这些指令可能引起对特定内存地址的额外加载以及存储。 一个典型的指令执行周期， 首先从内存中读取指令。接着， 该指令会被解码， 也可能需要从内存中读取操作数。内存单元只看到地址流，而不知道这些地址从何产生。 基本硬件CPU可以直接访问的通用存储只有内存和处理器内置的寄存器。因此，执行指令以及指令使用的数据，应该处在这些可以直接访问的存础设备上。如果数据不在内存中， 那么在CPU 使用它们之前应先把数据移到内存。 CPU 内置寄存器通常可以在一个CPU 时钟周期内完成访问。完成内存的访问可能需要多个CPU 时钟周期。在这种情况下， 由于没有数据以便完成正在执行的指令， CPU 通常需要暂停(stall)。由于内存访问的频繁，这种情况是我们不想见到的。补救措施是在CPU 与内存之间， 通常是在CPU 芯片上， 增加更快的内存；这称为高速缓存(cache)。 为了确保操作的正确，首先，我们需要确保每个进程都有一个单独的内存空间。单独的进程内存空间可以保护进程而不互相影响，这对于将多个进程加到内存以便并发执行来说至关重要，通过两个寄存器，通常为基地址和界限地址，如图8所示，我们可以提供这种保护。基地址寄存器含有最小的合法的物理内存地址，而界限地址寄存器指定了范围的大小。 内存空间的保护是通过CPU对在用户模式下产生的地址与寄存器的地址进行比较而得成的。只有操作系统可以通过特殊的特权指令，才能加载基地址寄存器和界限地址寄存器。这个方案允许操作系统修改这两个寄存器的值，而不允许用户程序修改它们。 在内核模式下执行的操作系统可以无限制地访问操作系统及用户的内存。 地址绑定源程序中的地址通常是用符号表示，编译器会将这些符号地址绑定到可重定位的地址。链接程序或加载程序再将这些可重定位的地址绑定到绝对地址（如74014)。每次绑定都是从一个地址空间到另一个地址空间的映射。 通常，指令和数据绑定到存储器地址可在沿途的任何一步中进行： 编译时：如果在编译时就已知道进程将在内存中的驻留地址，那么就可以生成绝对代码。 加载时：如果在编译时并不知道进程将驻留在何处，那么编译器就应生成可重定位代码。 执行时：如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定应延迟到执行时才进行。 逻辑地址空间与物理地址空间CPU生成的地址叫做逻辑地址，内存单元看到的地址（即加载到内存地址寄存器的地址）通常称为物理地址。 编译时和加载时的地址绑定方法生成相同的逻辑地址和物理地址。然而， 执行时的地址绑定方案生成不同的逻辑地址和物理地址。在这种情况下， 我们通常称逻辑地址为虚拟地址。 从虚拟地址到物理地址的运行时映射是由内存管理单元（MMU）来完成。 动态加载为了获得更好的内存空间利用率，可以使用动态加载。采用动态加载时，一个程序只有在调用时才会加载。当一个程序需要调用另一个程序时，调用程序首先检查另一个程序是否加载。如果没有，则将其加载到内存中。 优点：只有一个程序被需要时才会加载，不需要操作系统提供特别支持。 交换进程必须在内存中以便执行。不过，进程可以暂时从内存交换到备份存储器，当再次执行时再调回内存中。 标准交换标准交换在内存与备份存储之间移动进程。备份存储通常是快速硬盘。系统维护一个可运行的所有进程的就绪队列，它们的映像在备份存储或者是内存中。 这种交换的上下文切换时间相当高。主要耗时是传输时间，为有效使用这种方法， 用户需要告诉系统它的内存需求情况。因此， 具有动态内存需求的进程需要通过系统调用来通知操作系统内存使用情况。 想换出一个进程必须保证它是空闲的。 现代操作系统现在并不使用标准交换。它的交换时间太多， 它提供的执行时间太少， 不是合理的内存管理的解决方案。 连续内存分配内存通常分为两个区域：一个用于驻留操作系统，另一个用于用户进程。 通常， 我们需要将多个进程同时放在内存中。因此我们需要考虑， 如何为输入队列中需要调入内存的进程分配内存空间。在采用连续内存分配时，每个进程位于一个连续的内存区域， 与包含下一个进程的内存相连。 内存保护防止进程访问不属于它的内存，可以采用重定位寄存器以及界限寄存器。每个逻辑地址应在界限寄存器规定的范围内。MMU通过动态地将逻辑地址加上重定位寄存器的值， 来进行映射。映射后的地址再发送到内存。 内存分配最简单：将内存分为多个固定大小的分区，每个分区可以只包含一个进程。（多分区方法）当一个分区空闲时，可以从输入队列中选择一个进程，来调入空闲分区。当该进程终止时，它的分区可以用于其他进程。 对于可变分区方案，操作系统有一个表，用于记录哪些内存可用和哪些内存已用。一大块的可用内存被称为孔 从一组可用孔中选择一个空闲孔的最常用方法包括：首次适应、最优适应、最差适应 首次适应：分配首个足够大的孔。 最优适应：分配最小的足够大的空。 最差适应：分配最大的孔。 碎片用于内存分配的首次适应和最优适应算法都有外部碎片的问题。 外部碎片问题：随着进程加载到内存和从内存退出， 空闲内存空间被分为小的片段。当总的可用内存之和可以满足请求但并不连续时， 这就出现了外部碎片问题：存储被分成了大量的小孔。这个问题可能很严重。最坏情况下，每两个进程之间就有空闲（或浪费的）块。 内部碎片：因此， 通常按固定大小的块为单位（而不是字节）来分配内存。采用这种方案， 进程所分配的内存可能比所需的要大。这两个数字之差称为内部碎片，这部分内存在分区内部，但又不能用。 外部碎片问题解决方法：紧缩，目的是移动内存内容以便将所有空闲空间合并成一整块。 外部碎片化问题的另一个可能的解决方案是：允许进程的逻辑地址空间是不连续的。 分段定义将内存看作一组不同长度的段，这些段之间并没有一定的顺序。逻辑地址空间是由一组段构成。每个段都有名称以及长度。地址指定了段名称以及段内偏移。用户通过两个量来指定地址：段名称和段偏移。 为了实现简单，段是编号的，是通过段号而不是段名称来引用。 逻辑地址由一个有序对&lt;段号，偏移&gt;组成。 允许进程的物理地址空间非连续。 分段硬件段表：将用户定义的二维地址映射到一维物理地址。 段表的每个条目都有段基地址和段界限，段基地址包含该段在内存中的开始物理地址，而段界限指定该段的长度。 每个逻辑地址由两部分组成：段号s和段偏移d，段号是段表的索引，逻辑地址偏移应该在0和段界限之间。如果不合法就由操作系统处理，如果合法，那么就与基地址相加而得到所需字节的物理内存地址。因此，段表实际上是基址寄存器值和界限寄存器值的数组。 每个段都在段表中有一个条目， 它包括段在物理内存内的开始地址（基地址）和该段的长度（界限）。 分页优势：避免了外部碎片以及紧缩，分段不可以。避免了将不同大小的内存块匹配到交换空间的麻烦问题。 基本方法将物理内存分为固定大小的块，称为帧或页帧；将逻辑内存也分为同样大小的块，称为页或页面。 逻辑地址空间要求的内存可以远远的大于实际的物理内存。 硬件支持由CPU生成的每个地址分为两个部分：页码(p)和页偏移(d)。页码作为页表的索引。页表包含每页所在物理内存单元的基地址。这个基地址与页偏移的组合就形成了物理内存地址，可发送到物理单元。如下图所示。 页大小（同帧大小一样）是由硬件来决定的。将页的大小选为2的幂可以方便地将逻辑地址转换为页码与页偏移。如果逻辑地址空间为2^m,且页的大小为2^n字节，那么逻辑地址的高m-n位表示页码，低n位表示页偏移。逻辑地址如下图所示 其中p作为页表的索引，而d作为页的偏移。 分页本身是一种动态的重定位。每个逻辑地址由分页硬件绑定位某个物理地址。采用分页类似于采用一组基址(重定位)寄存器，每个基址对应着一个内存帧。 分页不会产生外部碎片：每个空闲帧都可以分配给需要它的进程。 不过分页会有内部碎片，因为分配是以桢为单位来进行的，如果进程要求的内存并不是也的整数倍，那么最后一个帧可能会用不完。如果进程大小与页大小无关，那么每个进程的内部碎片的均值为半页。 分页内存系统的物理内存大小不同于进程的最大逻辑大小。分页允许我们使用的物理内存大于CPU地址指针可访问的空间。 分页的一个重要方面是，程序员视图的内存和实际的物理内存的清楚分离。帧同样有帧表用于保存。分页增加了上下文切换的时间。 页表结构分层分页两层分页算法：将页表再分页。 例如，再次假设一个系统，具有32位逻辑地址空间和4K大小的页。一个逻辑地址被分为20位的页码和12位的页偏移。因为要对页表进行再分页，所以此页码可分为10位的页码以及10位的页偏移。如下图所示。 其中p1是用来访问外部页表的索引， 而p2是内部页表的页偏移。采用这种结构的地址转换方法如图所示，这种方案称作向前映射页表。 但是如果外部页表实在太大，要分层分页就会很多，对于64位的架构，这个通常是不恰当的。 哈希页表通常用于处理大于32位地址空间，采用虚拟页码作为哈希值。 哈希页表的每一个条目都包括一个链表， 该链表的元素哈希到同一位置（该链表用来解决处理碰撞）。每个元素由三个字段组成： 1） 虚拟页码， 2 ) 映射的帧码， 3） 指向链表内下一个元素的指针。 该算法工作如下：虚拟地址的虚拟页码哈希到哈希表。用虚拟页码与链表内的第一个元素的第一个字段相比较。如果匹配， 那么相应的帧码（第二个字段）就用来形成物理地址；如果不匹配， 那么与链表内的后续节点的第一个字段进行比较， 以查找匹配的页码。如图所示。 倒置页表对千每个真正的内存页或帧， 倒置页表才有一个条目。每个条目包含保存在真正内存位置上的页的虚拟地址，以及拥有该页进程的信息。因此， 整个系统只有一个页表， 并且每个物理内存的页只有一条相应的条目。工作原理如图所示。","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://fallensue.cc/tags/OS/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"Hello Hexo","slug":"Hello Hexo","date":"2020-11-06T14:16:01.000Z","updated":"2020-11-19T13:15:51.144Z","comments":true,"path":"posts/a1751c09.html","link":"","permalink":"https://fallensue.cc/posts/a1751c09.html","excerpt":"","text":"序言过了这么久终于能够有一个自己的博客了，以后有什么想法就会往上面发。","categories":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://fallensue.cc/tags/Hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2020-11-18T14:22:43.472Z","comments":true,"path":"posts/186f70d4.html","link":"","permalink":"https://fallensue.cc/posts/186f70d4.html","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://fallensue.cc/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://fallensue.cc/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}]}]}