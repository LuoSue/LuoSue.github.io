{"meta":{"title":"LuoSue's Blog","subtitle":null,"description":"闲话苑","author":"LuoSue","url":"https://fallensue.cc"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-11-07T10:37:48.955Z","comments":false,"path":"about/index.html","permalink":"https://fallensue.cc/about/index.html","excerpt":"","text":"[天意城のLuoSue] 与&nbsp; LuoSue&nbsp; （ 茄子 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-11-02T13:57:46.174Z","comments":false,"path":"client/index.html","permalink":"https://fallensue.cc/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-11-02T13:58:00.756Z","comments":true,"path":"comment/index.html","permalink":"https://fallensue.cc/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"artitalk","date":"2020-11-08T14:16:01.000Z","updated":"2020-11-15T08:34:36.071Z","comments":false,"path":"artitalk/index.html","permalink":"https://fallensue.cc/artitalk/index.html","excerpt":"","text":"var img= “https://cdn.jsdelivr.net/gh/LuoSue/cdn/img/custom/avatar.jpg&quot;; var appID= ‘cJsUVOg7I9utk9hiYW4IU7KB-MdYXbMMI’; var appKEY= ‘mzyqLMOSjeVwxY0D09qW8O8z’; var per= “10”; var username= “luosue”; L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/shizuku.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"log\":false});"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-11-02T13:59:23.206Z","comments":false,"path":"donate/index.html","permalink":"https://fallensue.cc/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"books","date":"2020-10-27T06:39:26.000Z","updated":"2020-10-27T06:39:26.405Z","comments":true,"path":"books/index.html","permalink":"https://fallensue.cc/books/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-11-02T13:59:35.060Z","comments":false,"path":"lab/index.html","permalink":"https://fallensue.cc/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-11-08T04:17:33.609Z","comments":false,"path":"music/index.html","permalink":"https://fallensue.cc/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"photos","date":"2020-10-27T06:39:05.000Z","updated":"2020-10-27T06:39:05.034Z","comments":true,"path":"photos/index.html","permalink":"https://fallensue.cc/photos/index.html","excerpt":"","text":""},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://fallensue.cc/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-11-02T13:59:56.452Z","comments":true,"path":"links/index.html","permalink":"https://fallensue.cc/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"https://fallensue.cc/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"https://fallensue.cc/tags/index.html","excerpt":"","text":""},{"title":"movies","date":"2020-10-27T06:39:40.000Z","updated":"2020-10-27T06:39:40.381Z","comments":true,"path":"movies/index.html","permalink":"https://fallensue.cc/movies/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://fallensue.cc/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"https://fallensue.cc/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"数据结构-图的关键路径分析","slug":"数据结构-图关键路径分析","date":"2020-11-19T12:16:21.000Z","updated":"2020-11-19T13:17:49.754Z","comments":true,"path":"posts/bfa3aab2.html","link":"","permalink":"https://fallensue.cc/posts/bfa3aab2.html","excerpt":"","text":"关键路径问题关键路径问题具体是要分析什么呢？其实是要分析类似下面的图(AOE)的相关问题。 边：表示一个活动，一个边(v,w)表示着事件v必须在w开始之前完成 权重：一个活动的持续时间 顶点：表示一个状态 只有一个顶点的出度为0，也只有一个顶点的入度为0 没有环 有向图中，用顶点表示事件，用有向边表示活动之间开始的先后顺序，则称这种有向图为AOV（Activity On Vertex）网络；AOV网络可以反应任务完成的先后顺序（拓扑排序）。 在AOV网的边上加上权值表示完成该活动所需的时间，则称这样的AOV网为AOE（Activity On Edge）网，如图： 如何求AOE网中各事件（节点）和各活动（边）的最早开始时间和最迟开始时间以及工程的关键路径？ 整个活动的完成时间是AOE图中从始点到终点的最长路径的长度，这条路径称为关键路径。关键路径上的活动称作关键活动。 注意：关键路径不一定只有一条。 1.最早发生时间：从前往后，前驱结点到当前结点所需时间，取最大值。 如上图中的节点4有两个前驱结点（节点2和3），节点2到节点4的最早发生时间是a1+a3也就是8，节点3到节点4的最早发生时间是a2+a4也就是12，因为12&gt;8，所以节点4的最早发生时间是12. 结束节点（10）的最早发生时间和最迟发生时间相同。 2.最迟发生时间：从后往前，后继结点的最迟发生时间-边权值，取最小值。 如上图中的节点9的最迟发生时间为其后继节点10（只有一个）的最迟发生时间减去a14即24-2=22. 事件 1 2 3 4 5 6 7 8 9 10 最早发生时间 0 5 6 12 15 16 17 19 22 24 最迟发生时间 0 9 6 12 16 20 17 20 22 24 3.关键路径：最早发生时间和最迟发生时间相同的结点即为关键路径上的节点。 4.最早开始时间：等于当前边起始结点的最早发生时间。 5.最晚开始时间：等于当前边指向结点的最迟发生时间-当前边的权值。 6.最早完工时间：等于当前边指向结点的最早发生时间。 7.最晚完工时间：等于当前边指向结点的最迟发生时间。 活动 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 最早开工 0 0 5 6 6 12 12 12 15 15 17 19 16 22 最迟开工 4 0 9 6 13 16 13 12 16 16 17 20 20 22 最早完工 5 6 12 12 15 16 15 17 17 19 22 22 24 24 最迟完工 9 6 12 12 16 20 16 17 17 20 22 22 24 24","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-图的拓扑排序","slug":"数据结构-图的拓扑排序","date":"2020-11-19T12:16:21.000Z","updated":"2020-11-19T13:17:36.175Z","comments":true,"path":"posts/c3ce505e.html","link":"","permalink":"https://fallensue.cc/posts/c3ce505e.html","excerpt":"","text":"拓扑排序定义在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它前面的节点。 先统计所有节点的入度，对于入度为0的节点就可以分离出来，然后把这个节点指向的节点的入度–。 重复如上操作，直到所有的节点都被分离出来。 如果最后不存在入度为0的节点，那就说明有环，不存在拓扑排序，也就是很多题目的无解的情况。 有向图内不能够出现环 算法图示如下 算法实现 将所有入度为0的顶点保存在一个队列中 当队列非空的时候 从队列中删除一个顶点 所有与删除顶点相邻的顶点的入度减一 如果一个相邻顶点的入度为0，则入队 这样的话拓扑排序顺序就是出队的顺序，时间复杂度为O(|E|+|V|) 伪代码实现： void Topsort(Graph G){ Queue Q; int Counter = 0; Vertex V, W; Q = CreateQueue (NumVertex); MakeEmpty (Q); for each vertex V if (Indegree [V] == 0) Enqueue (V, Q); while (!IsEmpty (Q)) { V = Dequeue (Q); TopNum [V] = ++Counter; /* Next No. */ for each W adjacent to V if(--Indegree [W] == 0) Enqueue (W, Q); } if (Counter != NumVertex) Error (&quot;Graph has a cycle&quot;); DisposeQueue (Q); /* Free the memory */ } C++代码实现 bool Topsort() { cout &lt;&lt; &quot;图的拓扑序列为：&quot; &lt;&lt; endl; //栈s用于保存栈为空的顶点下标 stack&lt;int&gt; s; int i; ArcNode * temp; //计算每个顶点的入度，保存在indgree数组中 for (i = 0; i != this-&gt;vexnum; i++) { temp = this-&gt;arc[i].firstarc; while (temp) { ++this-&gt;indegree[temp-&gt;adjvex]; temp = temp-&gt;next; } } //把入度为0的顶点入栈 for (i = 0; i != this-&gt;vexnum; i++) { if (!indegree[i]) { s.push(i); } } //count用于计算输出的顶点个数 int count=0; while (!s.empty()) {//如果栈为空，则结束循环 i = s.top(); s.pop();//保存栈顶元素，并且栈顶元素出栈 cout &lt;&lt; this-&gt;arc[i].data&lt;&lt;&quot; &quot;;//输出拓扑序列 temp = this-&gt;arc[i].firstarc; while (temp) { if (!(--this-&gt;indegree[temp-&gt;adjvex])) {//如果入度减少到为0，则入栈 s.push(temp-&gt;adjvex); } temp = temp-&gt;next; } ++count; } if (count == this-&gt;vexnum) { cout &lt;&lt; endl; return true; } cout &lt;&lt; &quot;此图有环，无拓扑序列&quot; &lt;&lt; endl; return false;//说明这个图有环 }","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-树","slug":"数据结构树","date":"2020-11-18T11:33:01.000Z","updated":"2020-11-19T13:16:38.704Z","comments":true,"path":"posts/f30c2ae3.html","link":"","permalink":"https://fallensue.cc/posts/f30c2ae3.html","excerpt":"","text":"树树是n个结点的有限集。 其余的树叫做根的子树 结点包含一个数据元素及指向其子树的分支。 结点的子树数为结点的度，度为0的结点称之为叶子或终端结点，度不为0的结点称之为非终端结点或是分支结点。 子树的根称为孩子，（双亲，兄弟，子孙，祖先） 结点的层次，根为第一层。树中结点的最大层次称之为深度 各子树看成从左至右有次序，则该树为有序树，否则为无序树 二叉树的定义特点：每个结点至多有只有两棵子树，子树有左右之分 特性：在二叉树的第i 层上至多有(2^i-1)个结点(i&gt;=1) 深度为k的二叉树至多有(2^k)-1个结点(k&gt;=1) 对任意一棵二叉树T，如果其终端结点为n，度为2的结点为m，则n=m+1 满二叉树一棵深度为k且有(2^k)-1个结点的树称为满二叉树 特点：每一层上的结点数都是最大结点数 完全二叉树完全二叉树：深度为k,有n个结点，每一个结点与满二叉树一一对应 特点：叶子节点只可能在层次最大的两层上出现，对任一结点，其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+1 具有n个结点的完全二叉树的深度为[log2n]+1 如果对一棵有n个结点的完全二叉树的结点按层序编号，则对任一结点，有 (1) 如果i=1，则结点i是二叉树的根，无双亲；若i&gt;1，其双亲PARENT(i)是结点[i/2] (2)如果2i&gt;n,则结点i无左孩子，否则其左孩子为结点2i’ (3)如果2i+1&gt;n，则结点i无右孩子；否则其右孩子为结点2i+1 二叉树的存储结构顺序存储结构用一组地址连续的存储单元依次自上而下，自左而右的存储。 仅适用于完全二叉树，否则浪费空间 #define MAX_TREE_SIZE 100//二叉树最大结点数 typedef TElemType SqBiTree[MAX_TREE_SIZE];//0号单元存储根结点 SqBiTree bt; 链式存储结构结点由一个数据元素和分别指向其左、右子树的两个分支构成。（数据域，左右指针域） 有时可以增加指向其双亲的指针域（分别称为二叉链表和三叉链表） n个结点的二叉链表中有n+1个空链域 typedef struct BiTNode{ TElemType data; struct BiTNode *lchild,*rchild;//左右孩子指针 }BiTNode,*BiTree; 遍历二叉树先序遍历：若是二叉树空，则空操作。否则先访问根节点，再先序遍历左子树，最后先序遍历右子树 中序遍历：若是二叉树空，则空操作。否则先中序遍历左子树，再访问根节点，最后先序遍历右子树 后序遍历：若是二叉树空，则空操作。否则先后序遍历左子树，再后序遍历右子树，最后访问根节点 时间复杂度均为O(n) 线索二叉树若结点有左子树，则其lchild域指向其左孩子，否则令其lchild域指向其前驱；若结点有右子树，则令其rchild域指向其右孩子，否则指向其后继。增加两个标志域。 lchild LTag data RTag rchild 这样的二叉链表叫做线索链表，二叉树叫做线索二叉树。 typedef enum PointerTag{Link,Thread}; //Link==0:指针，Thread ==1:线索 typedef struct BiThrNode{ TElemType data; struct BiThrNode *lchild,*rchild; //左右孩子指针 PointerTag LTag,RTag;//左右标志 }BiThrNode,*BiThTree; 哈夫曼树从树中一个结点到另一个结点之间的分支构成此两个结点之间的路径，路径上的分支数目叫做路径长度。路径长度是从树根到每一个结点的路径长度之和。 树的带权路径长度：所有叶子结点的带权路径长度之和WPL WPL最小的树被称为赫夫曼树 typedef char** HuffmanCode;//动态分配数组存储哈夫曼编码表 /*储存字符权值*/ typedef struct { char a; int weight; }ElementType; ElementType element[Max_n]; /*HuffmanTree的存储表示*/ typedef struct { ElementType data; int parent, lchild, rchild; }HTNode, * HuffmanTree; /*创建Huffman树*/ if (n &lt;= 1) { cout &lt;&lt; &quot;输入字符太少，无法创建哈夫曼树&quot; &lt;&lt; endl; exit(0); } HT = new HTNode[2 * n];//0号单元未使用 int m = 2 * n - 1; //初始化结点 for (int i = 1; i &lt;= m; i++) { HT[i].parent = 0; HT[i].lchild = 0; HT[i].rchild = 0; HT[i].data.a = element[i - 1].a; HT[i].data.weight = element[i - 1].weight;//Data从0开始存入信息 } for (int i = n + 1; i &lt;= m; i++) { int s1 = 0, s2 = 0;//下标 Select(HT, i - 1, s1, s2); HT[s1].parent = i; HT[s2].parent = i;//标记双亲为i,表示这两个值已经处理过 HT[i].lchild = s1; HT[i].rchild = s2;//s1,s2分别为双亲的左右孩子 HT[i].data.weight = HT[s1].data.weight + HT[s2].data.weight;//双亲权值是左右孩子权值之和 } cout &lt;&lt; &quot;哈夫曼树创建成功！&quot; &lt;&lt; endl; //从叶子到根逆向求每个字符的哈夫曼编码,存储在编码表HC中 HC = new char* [n + 1];//0号位置不用 char* cd = new char[n]; cd[n - 1] = &#39;\\0&#39;;//编码结束符 for (int i = 1; i &lt;= n; i++) {//求编码 int start = n - 1;//记录编码在cd中存放的位置,初始时指向最后 int c = i; int f = HT[i].parent;//c记录从叶子结点向上回溯至根节点的下标,f记录i的双亲的下标 while (f != 0) {//向上没有双亲 start--;//向上走一次,start前移一次 if (HT[f].lchild == c) cd[start] = &#39;0&#39;; //左孩子编码为0 else cd[start] = &#39;1&#39;; //右孩子编码为1 c = f; f = HT[f].parent; //继续向上找 } HC[i] = new char[n - start];//第i个编码字符分配空间 strcpy(HC[i], &amp;cd[start]); } delete[]cd; cout &lt;&lt; &quot;成功求出哈夫曼编码！&quot; &lt;&lt; endl; //从叶子到根逆向求每个字符的哈夫曼编码,存储在编码表HC中 HC = new char* [n + 1];//0号位置不用 char* cd = new char[n]; cd[n - 1] = &#39;\\0&#39;;//编码结束符 for (int i = 1; i &lt;= n; i++) {//求编码 int start = n - 1;//记录编码在cd中存放的位置,初始时指向最后 int c = i; int f = HT[i].parent;//c记录从叶子结点向上回溯至根节点的下标,f记录i的双亲的下标 while (f != 0) {//向上没有双亲 start--;//向上走一次,start前移一次 if (HT[f].lchild == c) cd[start] = &#39;0&#39;; //左孩子编码为0 else cd[start] = &#39;1&#39;; //右孩子编码为1 c = f; f = HT[f].parent; //继续向上找 } HC[i] = new char[n - start];//第i个编码字符分配空间 strcpy(HC[i], &amp;cd[start]); } delete[]cd; cout &lt;&lt; &quot;成功求出哈夫曼编码！&quot; &lt;&lt; endl;","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-串","slug":"数据结构串","date":"2020-11-18T10:33:01.000Z","updated":"2020-11-19T13:16:18.827Z","comments":true,"path":"posts/d0f417a6.html","link":"","permalink":"https://fallensue.cc/posts/d0f417a6.html","excerpt":"","text":"串由零个或者是多个字符组成的有限序列 零个字符为空串，长度为零。 字符在串中的位置（在序列中的序号） 任意个字符组成的子序列称之为子串，包含子串的串称之为主串 两个串相等，说明两个串的值相等。 由一个或多个空格组成的串叫做空格串（不是空串！） 串和线性表很像（但是串的数据对象约束为字符集），线性表通常 以单个元素作为操作对象，但是串以整体作为对象。 串的定位函数Index(S,T,pos) 基本思想：在主串S中取从第pos个字符起，长度与T相等的子串与串T进行比较，若相等则函数值为pos，否则不断增加持续比对 int Index(String S,String T, int pos){ if(pos&gt;0){ n = S.length; m = T.length; i = pos; while(i&lt;=n-m+1){ SubString(sub,S,i,m); if(StrCompare(sub,T)!=0) i++; else return i //返回子串在主串中的位置 } } return 0;//不存在 } 串的三种表示方法定长顺序存储表示类似于线性表的顺序存储结构，按照预定义的大小，分配一个固定长度的存储区，可以用定长数组表示之。 #define MAXSTRLEN 255 typedef unsigned char SString[MAXSTRLEN+1]; 串长两种表示方法：1.数组0号单元存放 2.串后面加一个‘\\0’符号（结束符号） 串的连接Status Concat(SString &amp;T, SString S1,SString S2){ //用T返回由S1与S2连接成的新串 if(S1[0]+S2[0]&lt;=MAXSTRLEN){//未截断 T[1...S1[0]]=S1[1...s1[0]]; T[S1[0]+1...S1[0]+S2[0]]=S2[1...S2[0]]; T[0]=S1[0]+S2[0]; } else if(S1[0]&lt;MAXSTRLEN){//截断 T[1...S1[0]]=S1[1...S1[0]]; T[S1[0]+1...MAXSTRLEN] = S2[1...MAXSTRLEN-S1[0]]; T[0]= MAXSTRLEN; uncut = FALSE; } else{ T[0...MAXSTRLEN] = S1[0...MAXSTRLEN]; uncut = FALSE; } return uncut; } 求子串Status SubString(SString &amp;Sub,SString S, int pos,int len){ if(pos&lt;1||pos&gt;S[0]||len&lt;0||len&gt;S[0]-pos+1){ return ERROR; } sub[1...len]=S[pos...pos+len-1]; sub[0]=len; return OK; } 这个结构弊端：串的最大长度受限，操作起来不易，如插入，置换。 堆分配存储表示特点：仍以一组连续的存储单元存放串值字符序列，但是存储空间为程序执行过程中动态分配得到 typedef struct{ char *ch; int length; }HString; 串的插入Status StrInsert(HString &amp;S,int pos,HString T){ //在串的第pos个字符之前插入串T if(pos&lt;1||pos&gt;S.length+1) return ERROR; if(T.length){//T非空，则重新分配空间，插入T if(!(S.ch=(char*)realloc(S.ch,(S.length+T.length)*sizeof(char)))) exit(OVERFLOW); for(i=S.length-1;i&gt;=pos-1;i--){ S.ch[i+T.length]=S.ch[i]; S.ch[pos-1...pos+T.length-2]=T.ch[0...T.length-1]; S.length += T.length; } } return OK; } 串的块链存储表示特点：与线性表的链式存储结构相似，用链表方式存储 #define CHUNKSIZE 80 //可由用户定义的块大小 typedef struct Chunk{ char ch[CHUNKSIZE]; struct Chunk *next; }Chunk; typedef struct{ Chunk *head,*tail; //串的头和尾指针 int curlen; //串的当前长度 } 串的模式匹配算法子串的定位操作称之为串的模式匹配 暴力匹配算法分别用计数指针i与j指示主串S和模式串T中当前正要比较的位置 基本思想：从主串S的第pos个字符起与模式串的第一个字符比较，相等则继续逐个比较，否则从主串的下一个字符起再重新和模式串的字符进行比较。 算法时间复杂度最坏的情况下为O(n*m)(n和m分别为主串与模式串的长度) int Index( SString S, SString T, int pos ) // 返回子串T在主串S中第pos个字符之后的位置。若不存在，则返回0 { i = pos ; j = 1; while ( i &lt;= S[0] &amp;&amp; j &lt;= T[0] ) // S[0]是串的长度 { if ( S[i] == T[j] ) { ++i ; ++j ; } // 继续比较 else { i = i - j + 2; j = 1; } // 指针后退重新匹配 } if ( j &gt; T[0] ) return i-T[0]; else return 0; } KMP匹配算法时间复杂度为O(m) int Index_KMP (SString S,SString T, int pos) { i=pos;j=1; while(i&lt;=S[0] &amp;&amp; j &lt;= T[0]) if(j==0||S[i]==T[j]){i++;j++;} else j=next[j];/*i 不变 ,j 后退*/ } if(j&gt;T[0])return i-T[0];//匹配成功 else return 0; //返回不匹配标志 } void Get_next( SString T, int &amp;next[] // Get Next[] value { j = 1 ; k = 0; next[1]=0; while ( j &lt;= T[0] ) { if ( k == 0 || T[j] == T[k] ) { ++j ; ++k ; next[j]=k; } else k = next[k]; } }","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-栈和队列","slug":"数据结构栈和队列","date":"2020-11-18T09:33:01.000Z","updated":"2020-11-19T13:19:22.413Z","comments":true,"path":"posts/57ad5ad7.html","link":"","permalink":"https://fallensue.cc/posts/57ad5ad7.html","excerpt":"","text":"栈和队列栈限定只在表尾进行删除操作的线性表（表尾栈顶，表头栈底） 后进先出（插入元素叫做入栈，删除元素叫做出栈） 栈的表示与实现一组连续的存储单元表示 typedef struct{ SElemType *base; SElemType *top; int stacksize; }SqStack; top为栈顶指针，base为栈底指针 top == base表示栈空了，每插入一个元素,top++;每删除一个元素，top–。 插入删除算法插入：先将元素插入当前栈顶指针所指向的位置，再移动栈顶指针。 删除：先取得栈顶指针减一位置的值，栈顶指针再自减一。 Status Push(SqStack &amp;S,SElemType e){ if(S.top-S.base&gt;=S.stacksize){//栈满了，追加存储空间 S.base=(SElemType *)realloc(S.base,(S.stacksize + STACKINCREMENT)*sizeof(SElemType)); if(!S.base) exit(OVERFLOW); S.top = S.base+S.stacksize; S.stacksize+=STACKINCREMENT; } *S.top=e; S.top++; return OK; } Status Pop(SqStack &amp;S,SElemType &amp;e){ if(S.top == S.base) return ERROR; e = *(--(S.top)); } 队列与栈相反，先进先出（只允许在表的一端插入，在另一端删除） 允许插入的一端叫做队尾，允许删除的一端叫做队头。 双端队列插入与删除操作在表的两端的线性表，两个端点分别称之为端点1与端点2. 输出受限的双端队列：一个端点允许插入与删除，一个端点只允许插入 输出受限的双端队列：一个端点允许插入与删除，一个端点只允许删除 限定从某个端插入的结点只能在该端删除：两个栈底相接的栈 链队列链表表示的队列 给链队列添加一个头结点，并令头指针指向它（空的链队列即是头指针与尾指针均指向头结点） 循环队列有两个指针front和rear来分别指示队列头元素以及队列尾元素 插入元素，尾指针++；删除元素，头指针– 非空的循环队列中，头指针始终指向队列头元素，尾指针始终指向队列尾元素的下一个位置 #define MAXQSIZE 100//最大队列长度 typedef struct{ QElemType *base; //初始化的动态分配存储空间 int front; //头指针，若队列不空，指向队头元素 int rear; //尾指针，若队列不空，指向队列尾元素的下一个位置 }SqQueue; Status InitQueue(SqQueue &amp;Q){ Q.base = (QElemType *)malloc(MAXQSIZE*sizeof(QElemType)); if(!Q.base)exit(OVERFLOW);//分配失败 Q.front = Q.rear=0; return OK; } int QueueLength(SqQueue Q){ //返回Q的元素个数，即队列的长度 return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE; } Status EnQueue(SqQueue &amp;Q,QElemType e){ //插入元素e为Q的新的队尾元素 if((Q.rear+1)%MAXQSIZE==Q.front) return ERROR;//队列满了 Q.base[Q.rear]=e; Q.rear = (Q.rear+1)%MAXQSIZE; return OK; } Status DeQueue(SqQueue &amp;Q,QElemType &amp;e){ //若队列不空，则删除Q的队头元素，用e返回其值，并返回OK //否则返回ERROR if(Q.front == Q.rear) return ERROR; e = Q.base[Q.front]; Q.front = (Q.front + 1)%MAXQSIZE; return OK; } 循环队列满不满的判定 我们可以发现，当循环队列属于上图的d1情况时，是无法判断当前状态是队空还是队满。为了达到判断队列状态的目的，可以通过牺牲一个存储空间来实现。 如上图d2所示， 队头指针在队尾指针的下一位置时，队满。 Q.front == (Q.rear + 1) % MAXSIZE 因为队头指针可能又重新从0位置开始，而此时队尾指针是MAXSIZE - 1，所以需要求余。 当队头和队尾指针在同一位置时，队空。 Q.front == Q.rear;","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-线性表","slug":"数据结构线性表","date":"2020-11-18T08:33:01.000Z","updated":"2020-11-19T13:19:22.413Z","comments":true,"path":"posts/5b12b8a1.html","link":"","permalink":"https://fallensue.cc/posts/5b12b8a1.html","excerpt":"","text":"线性表结构：n个元素的有限序列 表中元素的个数n(n&gt;=0)为线性表的长度，n=0时为一个空表 a1为第一个数据元素，an为最后一个数据元素。 特点：灵活，便于插入，删除，访问 合并线性表LA和LB，求A=AUB 解法：扩大LA，若LB中有不存在于LA的元素就插入LA中。 void union(List &amp;La,List Lb){ //将所有在线性表Lb中但不在La中的数据元素插入到La中。 La_len=ListLength(La); Lb_len=ListLength(Lb);//求线性表的长度 for(i=1;i&lt;=Lb_len;i++){ GetElem(Lb,i,e); //取Lb中第i个数据元素赋给e if(!LocateElem(La,e,equal)) ListInsert(La,++La_len,e); //La中不存在和e相同的数据元素，则插入之 } }//union //合并两个无序线性表 void union(List&amp; La,List Lb){ int i,j = 0; int m = La.length; int n = Lb.length; for(i = 0; i &lt; n; i++){ while(La.data[j] != Lb.data[i] &amp;&amp; j &lt; m){//遍历La，直到找到等于Lb.data[i]的元素或者没找到才退出 j++; } if(j &gt;= m){ La.data[m] = Lb.data[i]; La.length++; m++; } j=0; } } 时间复杂度：T(n)=O(ListLength(LA)*ListLength(LB)) C语言代码实现： //合并两个无序线性表 void MergeList(SqList &amp;A,SqList &amp;B){ int i,j=0; int m = A.length; int n = B.length; for(i=0;i&lt;n;i++){ while(A.data[j] != B.data[i] &amp;&amp; j&lt;m){ j++; } if(j&gt;=m){ A.data[m] = B.data[i]; A.length++; m++; } j=0; } } 合并两个有序排列的线性表LA,LB均为非递减有序排列，合并为LC仍为非递减有序排列。 解法：设LC为空，将LA与LB元素逐个插入，设两个指针i,j分别指向LA，LB中某个元素，对比两个元素大小决定插入谁，再逐个后移。 void MergeList(List La,List Lb,List &amp;Lc){ //已知线性表La和Lb中的数据元素按非值递减排列。 //归并La和Lb得到新的线性表Lc，Lc的数据元素也可按值非递减排列。 InitList(Lc); i=j=1;k=0; La_len=ListLength(La); Lb_len=ListLength(Lb); while((i&lt;=La_len)&amp;&amp;(j&lt;=Lb_len)) {//La和Lb均非空 GetElem(La,i,ai);GetElem(Lb,j,bj); if(ai&lt;=bj) {ListInsert(Lc,++k,ai);++i;} else {ListInsert(Lc,++k,bj);++j}; } while(i&lt;=La_len) { GetElem(La,++i,ai);ListInsert(Lc,++k,ai); } while(i&lt;=Lb_len) { GetElem(Lb,++j,bj);ListInsert(Lc,++k,bj); } 时间复杂度：O(ListLength(LA)+ListLength(LB)) 线性表的顺序表示以及实现顺序表示：指用一组连续的存储单元依次存储线性表的数据元素。 Location(ai+1)=Location(ai)+(i-1)l 线性表中第i个元素存储位置 表中相邻的元素有相邻的存储位置，因此只要确定起始位置就能随机存取任一表中数据元素。 所以线性表的顺序存储结构为一种随机存取的存储结构 /*线性表的动态分配存储结构*/ typedef struct{ ElemType *elem; //存储空间基址 int length; //当前长度 int listsize; //当前分配的存储容量(以sizeof(ElemType)为单位) }SqList; Status InitList_Sq(SqList &amp;L){ //构造一个空的线性表L L.elem = (ElemType *)malloc(LIST_INIT_SIZE*sizeof(ElemType)); if(!L.elem) exit(OVERFLOW);//存储分配失败 L.length = 0; //空表长度为0 L.listsize = LIST_INIT_SIZE; //初始存储容量 return OK; } 顺序表示下线性表的插入，删除插入在第i-1个数据元素与第i个数据元素之间插入一个新的数据元素,长度为n变为n+1 于是，在第i(1&lt;=i&lt;=n)个元素之前插入一个元素，要将n至第i个元素均后移一位。 /*初始条件:顺序线性表L已经存在，1&lt;=i&lt;=ListLength(L)*/ /*操作结果:在L中第i(1&lt;=i&lt;=n)个位置之前插入新的数据元素e,L的长度++*/ Status ListInsert(SqList *L,int i,ElemType e){ int k; if(L-&gt;length==MAXSIZE)/*顺序表已满*/ return ERROR; if(i&lt;1||i&gt;L-&gt;length+1)/*如果i不在范围内*/ return ERROR; if(i&lt;=L-&gt;length){ for(k=L-&gt;length+1;k&gt;=i-1;k--)/*将要插入位置后数据元素向后移一位*/ L-&gt;data[k+1]=L-&gt;data[k]; } L-&gt;data[i-1]=e;/*插入新元素*/ L-&gt;length++;/*表长++*/ return OK; } 删除使长度为n的线性表变成长度n-1的线性表，删除第i个元素需要将从i+1至n个元素(共n-i)个元素依次前移一个位置 /*初始条件:顺序线性表L已经存在，1&lt;=i&lt;=ListLength(L)*/ /*操作结果:删除L的第i个数据元素,L的长度--*/ Status ListDelete(SqList *L,int i,ElemType *e){ int k; if(L-&gt;length==0)//线性表为空 return ERROR; if(i&lt;1||i&gt;L-&gt;length+1)/*如果i不在范围内*/ return ERROR; *e=L-&gt;data[i-1]; if(i&lt;L-&gt;length)//如果删除不是最后位置 { for(k=i;k&lt;L-&gt;length;k++) L-&gt;data[k-1]=L-&gt;data[k]; } L-&gt;length--; return OK; } 插入或者删除，时间主要耗费在移动元素上，即与要插入/删除的位置相关。设pi为在第i个元素之前插入一个元素的概率，则移动元素次数期望值*（表长为n） Σpi(n-i+1) 设si为删除第i个元素的概率，则移动元素次数期望值（表长为n） Σsi(n-i) 则有： 插入移动个数：n/2 删除移动个数：(n-1)/2 平均要移动表中一半元素，时间复杂度为O(n),n为表长 最好情况： 如果插入到最后一个位置，或者删除最后一个位置，则时间复杂度为 O(1); 最坏情况： 如果插入到第一个位置或者删除第一个元素，则意味着需要移动所有元素，故时间复杂度为O(n); 平均情况： 由于元素插入到第i个位置，或删除第i个元素，需要移动n-i个元素。根据概率原理，每个位置插入或删除元素的可能性是相同的。 最终平均移动次数和最中间的那个元素的移动次数相等，为n-1/2 实现LA=LAULB，执行时间取决于查找函数，比较次数，则为O(L.length)。union算法复杂度O(La.Length * Lb.Length) bool compare(ElemType c1, ElemType c2) { if(c1 == c2) return 1; else return 0; } int LocateElem_Sq(SqList L,ElemType e)//在顺序线性表L中查找第1个值与e相同的元素的位序 //若找到，则返回其在L中的位序，否则返回0 { int i = 1;//i的初值为第1个元素的位序 ElemType *p = L.elem;//i的初值为第1个元素的位序 while((i&lt;=L.length) &amp;&amp; !(compare(*p++,e))) ++i; if(i&lt;=L.length) return i; else return 0; }//LocateElem_Sq 合并有序顺序表： 复杂度O(La.length+Lb.length) void MergeList_Sq(SqList La,SqList Lb,SqList &amp;Lc)//已知顺序线性表La和Lb的元素按值非递减排列 //归并La和Lb得到新的顺序线性表Lc,Lc的元素也按值非递减排列 { ElemType *pa = La.elem; ElemType *pb = Lb.elem; Lc.listsize = Lc.length = La.length+Lb.length; ElemType* pc = Lc.elem = (ElemType *)malloc(Lc.listsize*sizeof(ElemType)); if(!Lc.elem) exit(1);//存储分配失败 ElemType* pa_last = La.elem + La.length - 1; ElemType* pb_last = Lb.elem + Lb.length - 1; while(pa&lt;=pa_last &amp;&amp; pb&lt;=pb_last)//归并 { if(*pa &lt;= *pb) *pc++ = *pa++; else *pc++ = *pb++; } while(pa&lt;=pa_last) *pc++ = *pa++;//插入La的剩余元素 while(pb&lt;=pb_last) *pc++ = *pb++;//插入Lb的剩余元素 *pc = &#39;\\0&#39;;//添加以截断 } 线性表的链式表示与实现typedef struct LNode{ ElemType data; struct LNode *next; }LNode,*LinkList; 特点：不要求逻辑相邻的元素物理位置上相邻，但是失去了可以随机存取的优点。 线性链表：一组任意的存储单元存储数据元素。 一个结点包括数据域和指针域，n个结点链接为链表。 每个结点只包含一个指针域的话称之为线性链表或单链表 存取必须从头指针（指向链表中第一个结点的位置）开始，最后一个结点指针为空。 typedef struct LNode{ ElemType data; struct LNode *next; }LNode,*LinkList; 有时候，第一个结点之前可以设置一个头结点，指针域指向第一个结点。若为空表则头指针指针域为空 则获取元素的算法实现： /*获取线性表的第i个元素的值*/ Status Getlem(LinkList *L, int i, ElemType &amp;e) { p = L-&gt;next;j=1; while(p&amp;&amp;j&lt;i){ p=p-&gt;next; j++; } if(!p||j&gt;i) return ERROR; e = p-&gt;data; return OK; } 时间复杂度为O(n) 单链表中的插入与删除： 插入操作： 先生成一个结点s,再修改相应的指针域 s-&gt;next=p-&gt;next;p-&gt;next=s; 删除操作： 直接修改a的指针域 a-&gt;next=a-&gt;next-&gt;next 因此插入删除均只需要修改指针域就可以实现 插入代码： Status ListInsert(LinkList *L;int i;ElemType e){ int j; LinkList p,s; &amp;p = L; j = 1; while(p&amp;&amp;j&lt;i){ p = p-&gt;next; j++; } if(!p||j&gt;i){ return ERROR; } s =(LinkList)malloc(sizeof(Node)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return OK; } 删除代码： Status ListDelete(LinkList *L;int i;ElemType e){ int j; LinkList p,q; &amp;p = L; j=1; while(p-&gt;next&amp;&amp;j&lt;i){ p=p-&gt;next; j++; } if(!(p-&gt;next)||j&gt;i){ return ERROR; } q = p-&gt;next; p-&gt;next = q-&gt;next; *e = q-&gt;data; free(q); return Ok } 算法复杂度为O(n) 建立单链表算法复杂度也为O(n) void CreatList_L(LinkList &amp;L,int n){ L = (LinkList)malloc(sizeof(LNode)); L-&gt;next = NULL; for(i=n;i&gt;0;i--){ p=(LinkList)malloc(sizeof(LNode)); scanf(&amp;p-&gt;data); p-&gt;next = L-&gt;next; L-&gt;next = p; } } 两个链表合并： 三个指针pa,pb,pc pc指向Lc表中最后一个结点，pa,pb分别指向La,Lb中第一个结点。当pa-&gt;data &lt;= pb-&gt;data,则将pa所指结点链接到pc所指结点之后,否则就是pb. void MergeList_L(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc){ pa=La-&gt;next; pb=Lb-&gt;next; Lc=pc=La;//La的头结点作为Lc的头结点 while(pa&amp;&amp;pb){ if(pa-&gt;data&lt;=pb-&gt;data){ pc-&gt;next =pa; pc=pa; pa=pa-&gt;next; } else{ pc-&gt;next = pb; pc = pb; pb = pb-&gt;next; } } pc-&gt;next = pa?pa:pb;//插入剩余段 free(Lb); } 两个链表归并只需要重新链接结点就好。 静态链表#define MAXSIZE 1000 typedef struct{ ElemType data; int cur; } 一维数组描述的链表称之为静态链表 定位函数 int LocateElem_SL(SLinkList S,ElemType e){ i=S[0].cur; while(i&amp;&amp;s[i].data!=e) i=S[i].cur; return i; } 循环链表表中最后一个结点的指针指向头结点，整个链表形成一个环。 合并的话，只需要将表尾与表头相连接，运算时间为O(1) 双向链表指针域中存放前驱和后继两个指针 typedef struct DuLNode{ ElemType data; struct DuLNode *prior; struct DuLNode *next; }DuLNode,*DuLinkList; 插入或者删除均需要修改两个方向上的指针，于是时间复杂度为O(n) Status ListInsert_DuL(DuLinkList &amp;L,int i,ElemType e){ if(!(p=GetElemP_DuL(L,i)))//在L中确定插入位置 return ERROR; //P=NULL,插入位置不合法 if(!(s=(DuLinkList)malloc(sizeof(DuLNode)))) return ERROR; s-&gt;data=e; s-&gt;prior = p-&gt;prior; p-&gt;prior-&gt;next = s; s-&gt;next = p; p-&gt;prior = s; return OK; } Status ListDelete_DuL(DuLinkList &amp;L,int i;ElemType &amp;e){ if(!(p=GetElemP_DuL(L,i))) return ERROR; e=p-&gt;data; p-&gt;prior-&gt;next=p-&gt;next; p-&gt;next-&gt;prior=p-&gt;prior; free(p); return OK; }","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"OS虚拟内存管理","slug":"OS虚拟内存管理","date":"2020-11-18T07:33:01.000Z","updated":"2020-11-19T13:15:51.144Z","comments":true,"path":"posts/8c7e9ffb.html","link":"","permalink":"https://fallensue.cc/posts/8c7e9ffb.html","excerpt":"","text":"OS虚拟内存管理背景将整个程序置于内存中，其实不是必要的： 程序处理异常错误条件的代码几乎不怎么执行 数组、链表、表所分配的内存量多于实际的值 程序的某些功能和选项几乎不用 即使在需要整个程序的情况下， 也可能并不同时需要整个程序，分段能够执行只有部分处于内存的程序，可以带来许多好处。 程序不再受物理内存的可用量所限制，用户能够给一个巨大的虚拟地址空间编写程序，简化了编程的任务。 由于每个程序占用较少的物理内存，可以同时运行更多的程序，增加了CPU的利用率以及吞吐量，但没有增加响应时间或者周转时间。 由于加载或交换每个用户程序到内存所需的I/O会更少， 用户程序会运行得更快。因此， 运行不完全处于内存的程序将使系统和用户都受益。 虚拟内存将用户逻辑与物理内存分开。进程的虚拟地址空间就是进程如何在内存中存放的逻辑视图。 除了将逻辑内存与物理内存分开外，虚拟内存允许文件和内存通过共享页而为多个进程所共享。这带来了以下好处： 通过将共享对象映射到虚拟地址空间中， 系统库可以为多个进程所共享。 类似地， 虚拟内存允许进程共享内存。 当通过系统调用fork()创建进程时， 可以共享页面， 从而加快进程创建。 请求调页如何从磁盘加载可执行程序到内存？一种选择是，在程序执行时将整个程序加载到物理内存。(但是这种方法的一个问题是，最初可能不需要整个程序都处于内存) 另一种策略是，仅在需要时才加载页面。这种技术被称作请求调页，常常用于虚拟内存系统。不过， 不是将整个进程交换到内存中， 而是采用惰性交换器(lazy swapper), 惰性交换器除非需要某个页面， 否则从不将它交换到内存中。 基本概念调页程序不是调入整个进程， 而是把那些要使用的页调入内存。这样， 调页程序就避免了读入那些不使用的页， 也减少了交换时间和所需的物理内存空间。 使用这种方案需要一定形式的硬件支持， 以区分内存的页面和磁盘的页面。 请注意， 如果进程从不试图访问标记为无效的页面， 那么并没有什么影响。因此， 如果猜测正确并且只调入所有实际需要的页面， 那么进程就如同所有页面都已调入内存一样正常运行。当进程执行和访问那些内存驻留(memory resident)的页面时，执行会正常进行。 对标记为无效的页面访问会产生缺页错误(page fault)。分页硬件在通过页表转换地址时会注意到无效位被设置， 从而陷入操作系统。这种陷阱是由于操作系统未能将所需的页面调入内存引起的。 纯请求调页：当操作系统将指令指针设置为进程的第一条指令时， 由于它所在的页面并不在内存中， 进程立即出现缺页错误。当该页面调入内存后， 进程继续执行；根据需要发生缺页错误， 直到所需每个页面都在内存中。这时， 它可以在没有更多缺页错误的情况下执行。 程序具有局部引用，这使得请求调页具有较为合理的性能。 请求调页的性能请求调页可以显著影响计算机系统的性能。为了说明起见， 下面计一下请求调页内存的有效访问时间。 设p为缺页错误的概率(0&lt;=p&lt;=1) 。希望p接近于0, 即缺页错误很少。那么有效访问时间为：有效访问时间＝（1-p) x ma+ p x缺页错误时间。 总之， 对于请求调页， 降低缺页错误率是极为重要的。否则， 会增加有效访问时间， 从而极大地减缓了进程的执行速度。请求调页的另一个方面是交换空间的处理和整体使用。 写时复制它通过允许父进程和子进程最初共享相同的页面来工作。这些共享页面标记为写时复制， 这意味着如果任何一个进程写入共享页面， 那么就创建共享页面的副本。 显然， 当使用写时复制技术时， 仅复制任何一进程修改的页面， 所有未修改的页面可以由父进程和子进程共享。还要注意， 只有可以修改的页面才需要标记为写时复制。不能修改的页面（包含可执行代码的页面）可以由父进程和子进程共享。 页面置换基本页面置换页面置换采用以下方法。如果没有空闲帧， 那么就查找当前不在使用的一个帧， 并释放它。可以这样来释放一个帧：将其内容写到交换空间， 并修改页表（和所有其他表）， 以表示该页不在内存中。现在可使用空闲帧， 来保存进程出错的页面。 采用修改位(modify bit)（或脏位(dirty bit）） 可减少这种开销。当采用这种方案时， 每个页面或帧都有一个修改位， 两者之间的关联采用硬件。当要选择一个页面进行置换时， 就检查它的修改位。如果该位已被设置， 那么该页面从磁盘读入以后已被修改。 页面置换是请求调页的基础。它完成了逻辑内存和物理内存之间的分离。采用这种机制， 较小的物理内存能为程序员提供巨大的虚拟内存。 为实现请求调页， 必须解决两个主要问题：应设计帧分配算法和页面置换算法。 FIFO页面置换最简单的页面置换算法是FIFO算法。FIFO页面置换算法为每个页面记录了调到内存的时间。当必须置换页面时， 将选择最旧的页面。请注意， 并不需要记录调入页面的确切时间。可以创建一个FIFO队列， 来管理所有的内存页面。置换的是队列的首个页面。当需要调入页面到内存时， 就将它加到队列的尾部。 FIFO页面置换算法易于理解和编程。然而， 它的性能并不总是十分理想。一方面， 所置换的页面可以是很久以前使用过但现已不再使用的初始化模块。另一方面， 所置换的页面可以包含一个被大量使用的变量，它早就初始化了， 但仍在不断使用。 采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。这个最意想不到的结果被称为Belady异常。 最优页面置换(OPT或者MIN)具有所有算法最低的缺页错误率，并且不会遭受Belady异常，简单地说就是置换最长时间不会使用的页面。 但是，最优置换算法难以实现，因为它需要引用串的未来知识，所以主要用于比较研究。 LRU页面置换置换最长时间没有使用的页，这种方法被称为最近最少使用算法。 LRU置换将每个页面与它的上次使用的时间关联起来，这种策略可当作在时间上向后看而不是向前看的最优页面置换算法。 如何实现LRU呢？主要问题是确定由上次使用时间定义的帧的顺序。 计数器：在最简单的情况下，为每个页表条目关联一个使用时间域，并为CPU 添加一个逻辑时钟或计数器。这种方案需要搜索页表以查找LRU 页面，而且每次内存访问都要写到内存（到页表的使用时间域）。当页表更改时（由于CPU 调度）， 还必须保留时间。时钟溢出也要考虑。 堆栈：采用页码堆栈，每当页面被引用是，他就从堆栈中移除并放在顶部。这样，最近使用的页面总是在栈的顶部，最近最少使用的页面总是在底部。 这个置换同样没有Belady异常。 近似LRU页面置换很少有计算机系统能够提供足够的硬件来支持真正的LRU页面置换算法。许多系统都通过引用位的形式提供一定的支持。 最初， 所有引用位由操作系统清零（至0)。当用户进程执行时， 每个引用到的页面引用位由硬件设置（至1）。一段时间后， 我们可以通过检查引用位来确定哪些页面已被使用，哪些页面尚未使用， 虽说我们不知道使用的顺序。 额外引用位算法通过定期记录引用位，我们可以获得额外的排序信息。可以为内存中发的页表的每个页面保留一个8位的字节。在极端情况下， 位数可降为0, 即只有引用位本身。这种算法称为第二次机会页面置换算法。 第二次机会算法第二次机会置换的基本算法是一种FIFO置换算法。然而， 当选择了一个页面时， 需要检查其引用位。如果值为0, 那么就直接置换此页面；如果引用位设置为1，那么就给此页面第二次机会， 并继续选择下一个FIFO页面。 实现第二次机会算法（有时称为时钟算法(clock algorithm)) 的一种方式是采用循环队列。指针（即时钟指针）指示接下来要置换哪个页面。当需要一个帧时， 指针向前移动直到找到一个引用位为0的页面。在向前移动时， 它会清除引用位。一旦找到牺牲页面， 就置换该页面， 并且在循环队列的这个位置上插入新页面。注意， 在最坏的情况下，当所有位都巳设置， 指针会循环遍历整个队列， 给每个页面第二次机会。在选择下一个页面进行置换之前， 它将清除所有引用位。 如果所有位都为1，第二次机会置换退化为FIFO置换。 增强型第二次机会算法通过将引用位和修改位作为有序对， 可以改进二次机会算法。有了这两个位， 就有下面四种可能的类型： (0,0) 最近没有使用且没有修改的页面，最佳的页面置换。 (0,1) 最近没有使用但修改过的页面，不太好的置换，因为在置换前需要将页面写出。 (1,0) 最近使用过但没有修改的页面，可能很快再次使用。 (1,1) 最近使用过且修改过，可能很快再次使用，并且在置换前需要将页面写出到磁盘。 这种算法与更为简单的时钟算法的主要区别在于：这里为那些已修改页面赋予更高级别， 从而降低了所需I/O数量。 基于计数的页面置换页面置换还有许多其他算法。例如， 可以为每个页面的引用次数保存一个计数器， 并且开发以下两个方案。 最不经常使用(LFU) 最经常使用(MFU) 页面缓冲算法除了特定页面置换算法之外， 还经常采用其他措施。例如， 系统通常保留一个空闲帧缓冲池。当出现缺页错误时， 会像以前一样选择一个牺牲帧。 这种方法的扩展之一是， 维护一个修改页面的列表。每当调页设备空闲时， 就选择一个修改页面以写到磁盘上， 然后重置它的修改位。 另一种修改是， 保留一个空闲帧池， 并且记住哪些页面在哪些帧内。 应用程序与页面置换在某些情况下， 通过操作系统的虚拟内存访问数据的应用程序比操作系统根本没有提供缓冲区更差。 另一个例子是数据仓库， 它频繁地执行大址的、顺序的磁盘读取， 随后计算并写入。LRU 算法会删除旧的页面并保留新的页面， 而应用程序将更可能读取较旧的页面而不是较新的页面（因为它再次开始顺序读取）。 系统抖动事实上， 需要研究一下没有“ 足够＂ 帧的进程。如果进程没有需要支待活动使用页面的帧数， 那么它会很快产生缺页错误。此时， 必须置换某个页面。然而， 由于它的所有页面都在使用中， 所以必须立即置换需要再次使用的页面。因此， 它会再次快速产生缺页错误， 再一次置换必须立即返回的页面， 如此快速进行。 这种高度的页面调度活动称为抖动(thrashing)。如果一个进程的调页时间多于它的执行时间，那么这个进程就是在抖动。 通过局部置换算法(localreplacement algorithm)或优先权置换算法(priority replacement al gorithm),可以限制系统抖动。如果一个进程开始抖动， 那么由于采用局部置换， 它不能从另一个进程中获取帧， 而且也不能导致后者抖动。这种方法定义了进程执行的局部性模型(locality model)。 工作集模型如上所述， 工作集模型(working-set model)是基于局部性假设的。这个模型采用参数▲定义工作集窗口(working-setwindow)。它的思想是检查最近▲个页面引用。这最近▲个页面引用的页面集合称为工作集(working-set)（如图9-20所示）。如果一个页面处于活动使用状态， 那么它处在工作集中。如果它不再使用， 那么它在最后一次引用的▲ 时间单位后， 会从工作集中删除。 例如， 给定如图所示的内存引用序列， 如果▲为10个内存引用， 那么t1时的工作集为{1, 2, 5, 6, 7}。 工作集的精度取决于▲ 的选择。如果▲太小， 那么它不能包含整个局部；如果▲太大， 那么它可能包含多个局部。在极端情况下， 如果▲为无穷大， 那么工作集为进程执行所需的所有页面的集合。因此， 最重要的工作集属性是它的大小。如果系统内的每个工作集通过计算为wss,,那么就得到D=IWSS;这里D为帧的总需求量。每个进程都使用其工作集内的页面。因此， 进程l需要WSS;帧。如果总需求大千可用帧的总数(D&gt;m)， 则将发生抖动， 因此有些进程得不到足够的帧数。","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://fallensue.cc/tags/OS/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-绪论","slug":"数据结构绪论","date":"2020-11-18T07:33:01.000Z","updated":"2020-11-19T13:23:57.037Z","comments":true,"path":"posts/75bf7760.html","link":"","permalink":"https://fallensue.cc/posts/75bf7760.html","excerpt":"","text":"什么是数据结构图书馆书目检索自动化：文件管理的数学模型，对象之间存在简单的线性关系，线性的数据结构 计算机与人对弈：格局，结果构成一棵“树”，一个数学模型，同为数据结构 十字路口交通灯的管理：“图”，同样为数据结构 基本概念以及术语数据：符号 数据元素：数据基本单位，可由若干个数据项构成 数据项：最小单位，不可分割 数据对象：数据的一个子集 数据结构：相互之间存在一种或多种关系的数据元素的集合 相互的关系称为结构 4类基本结构： （1）集合：数据元素仅同属于一个集合，无他关系 （2）线性结构：元素之间一对一关系 （3）树形结构：元素之间一对多关系 （4）图形结构或者网状结构：元素之间多对多关系 数据结构（D，S）二元组表示 D：数据元素有限集 S: D上关系有限集 结构中的“关系”为逻辑关系也可称之为逻辑结构 数据结构在计算机中表示（映像）可称为数据的物理结构（存储结构） 两种不同表示：顺序映像，非顺序映像 存储结构：链式（借助指针），顺序（相对位置） 数据类型：原子类型（整型、实型、字符型、枚举型……），结构类型 抽象数据类型（ADT）：数学模型以及定义在此模型上的一组操作 ADT构成：原子类型，固定聚合类型，可变聚合类型 算法与算法分析算法：问题求解步骤的一种描述 重要特性：（1）有穷性（2）确定性（3）可行性（4）输入（5）输出 好算法：正确，可读，健壮，效率 效率度量 两种办法：（1）事后统计（2）事前分析 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++){ c[i][j]=0; for(k=1;k&lt;=n;k++) c[i][j]+=a[i][k]*b[k][j]; } 上述代码整个算法执行时间与基本操作（乘法执行次数n^3成正比，则记作T(n)=O(n^3)）。 算法的时间量度：T(n)=O(f(n)) f(n):问题规模n的某个函数 T(n):算法时间复杂度 a){x++;s=0;} b)for(i=1;i&lt;=n;i++){x++;s+=x;} c)for(j=1;j&lt;=n;j++) for(k=1;k&lt;=n;k++){++x;s+=x;} X++语句频度分别为1，n和n^2，时间复杂度分别为O(1),O(n),O(n^2)（常量阶，对数阶，平方阶）尽量让复杂度小。 求复杂度一般考虑最坏情况，及关于n的表达式增长最快的项。 void bubble_sort(int a[],int n){ //将 a中整数序列重新排列成自大到小有序的整数序列。 for(i=n-1,change=TRUE;i&gt;=1&amp;&amp;change;i--){ change=FALSE; for(j=0;j&lt;i;j++) if(a[j]&gt;a[j+1]){a[j]←→a[j+1];change=TRUE;} } } 如上冒泡排序，最坏情况为a中序列自大到小，时间复杂度为T(n)=O(n^2) 空间复杂度：算法存储空间的量度 S(n)=O(f(n))","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-图最小生成树","slug":"数据结构-图最小生成树","date":"2020-11-18T07:30:01.000Z","updated":"2020-11-19T13:19:22.413Z","comments":true,"path":"posts/cededa76.html","link":"","permalink":"https://fallensue.cc/posts/cededa76.html","excerpt":"","text":"最小生成树定义在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。 构造网的最小生成树必须解决下面两个问题： 1、尽可能选取权值小的边，但不能构成回路； 2、选取n－1条恰当的边以连通n个顶点； 普里姆(prim)算法1.prim算法 基本思想：假设G＝(V，E)是连通的，TE是G上最小生成树中边的集合。算法从U＝{u0}（u0∈V）、TE＝{}开始。重复执行下列操作： 在所有u∈U，v∈V－U的边(u，v)∈E中找一条权值最小的边(u0,v0)并入集合TE中，同时v0并入U，直到V＝U为止。 此时，TE中必有n-1条边，T=(V，TE)为G的最小生成树。 Prim算法的核心:始终保持TE中的边集构成一棵生成树。 注意：prim算法适合稠密图，其时间复杂度为O(n^2)，其时间复杂度与边得数目无关，而kruskal算法的时间复杂度为O(eloge)跟边的数目有关，适合稀疏图。 例子如图 算法设计设最小生成树为T={U,TE}; U={u0};/*起始点*/ TE={}/*一开始没有边*/ while ( T 包含少于n-1条边) {(u,v)是一个花费最少的边，u∈U且v∉U if (没有这样的边) break; 将v添加到U; 将(u,v)添加到TE; } if ( T包含少于n-1条边) printf(&quot;No spanning tree \\n&quot;); C++代码实现: 1.邻接矩阵 #define _CRT_SECURE_NO_WARNINGS #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;vector&gt; using namespace std; //首先是使用邻接矩阵完成Prim算法 struct Graph { int vexnum; //顶点个数 int edge; //边的条数 int** arc; //邻接矩阵 string* information; //记录每个顶点名称 }; //作为记录边的信息，这些边都是达到end的所有边中，权重最小的那个 struct Assis_array { int start; //边的终点 int end; //边的起点 int weight; //边的权重 }; void CreateGraph(Graph &amp;g){ cout &lt;&lt; &quot;请输入边的条数，顶点个数&quot; &lt;&lt; endl; cin &gt;&gt; g.edge; cin &gt;&gt; g.vexnum; g.information = new string[g.vexnum]; g.arc = new int* [g.vexnum]; /*初始化矩阵*/ for (int i = 0; i &lt; g.vexnum;i++) { g.arc[i] = new int[g.vexnum]; g.information[i] = &quot;v&quot; + to_string(i + 1);//每个顶点进行命名 for (int k = 0; k &lt; g.vexnum; k++) { g.arc[i][k] = INT_MAX; } } cout &lt;&lt; &quot;请输入每条边之间的顶点编号(顶点编号从1开始),以及该边的权重：&quot; &lt;&lt; endl; for (int i = 0; i &lt; g.edge; i++) { int start; int end; cin &gt;&gt; start; //输入每条边的起点 cin &gt;&gt; end; //输入每条边的终点 int weight; cin &gt;&gt; weight; g.arc[start - 1][end - 1] = weight;//无向图的边是相反的 g.arc[end - 1][start - 1] = weight; } } //打印图 void print(Graph g) { int i; for (i = 0; i &lt; g.vexnum; i++) { //cout &lt;&lt; g.information[i] &lt;&lt; &quot; &quot;; for (int j = 0; j &lt; g.vexnum; j++) { if (g.arc[i][j] == INT_MAX) cout &lt;&lt; &quot;∞&quot; &lt;&lt; &quot; &quot;; else cout &lt;&lt; g.arc[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } } void Prim(Graph g, int begin) { //close_edge这个数组记录到达某个顶点的各个边中的权重最大的那个边 Assis_array* close_edge = new Assis_array[g.vexnum]; int j; //进行close_edge的初始化，更加开始起点进行初始化 for (j = 0; j &lt; g.vexnum; j++) { if (j != begin - 1) { close_edge[j].start = begin - 1; close_edge[j].end = j; close_edge[j].weight = g.arc[begin - 1][j]; } } //把起点的close_edge中的值设置为-1，代表已经加入到集合U了 close_edge[begin - 1].weight = -1; //访问剩下的顶点，并依次加入到集合U for (j = 1; j &lt; g.vexnum; j++) { int min = INT_MAX; int k; int index; for (k = 0; k &lt; g.vexnum; k++) { if (close_edge[k].weight != -1) { if (close_edge[k].weight &lt; min) { min = close_edge[k].weight; index = k; } } } //将权重最小的那条边的终点也加入到集合U close_edge[index].weight = -1; //输出对应的边的信息 cout &lt;&lt; g.information[close_edge[index].start] &lt;&lt; &quot;-----&quot; &lt;&lt; g.information[close_edge[index].end] &lt;&lt; &quot;=&quot; &lt;&lt; g.arc[close_edge[index].start][close_edge[index].end] &lt;&lt; endl; //更新我们的close_edge数组。 for (k = 0; k &lt; g.vexnum; k++) { if (g.arc[close_edge[index].end][k] &lt; close_edge[k].weight) { close_edge[k].weight = g.arc[close_edge[index].end][k]; close_edge[k].start = close_edge[index].end; close_edge[k].end = k; } } } } 2.邻接表 #define _CRT_SECURE_NO_WARNINGS #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; //表结点 struct ArcNode { int adjvex; //某条边指向的那个顶点的位置（一般是数组的下标）。 ArcNode* next; //指向下一个表结点 int weight; //边的权重 }; //头结点 struct Vnode { ArcNode* firstarc; //第一个和该顶点依附的边 的信息 string data; //记录该顶点的信息。 }; struct Graph_List { int vexnum; //顶点个数 int edge; //边的条数 Vnode* node; //顶点表 }; //创建图，是一个重载函数 void createGraph(Graph_List&amp; g) { cout &lt;&lt; &quot;请输入顶点数：输入顶点边的个数：&quot; &lt;&lt; endl; cin &gt;&gt; g.vexnum; cin &gt;&gt; g.edge; g.node = new Vnode[g.vexnum]; int i; for (i = 0; i &lt; g.vexnum; i++) { g.node[i].data = &quot;v&quot; + std::to_string(i + 1); //对每个顶点进行命名 g.node[i].firstarc = NULL;//初始化每个顶点的依附表结点 } cout &lt;&lt; &quot;请输入每条边之间的顶点编号(顶点编号从1开始),以及该边的权重：&quot; &lt;&lt; endl; for (i = 0; i &lt; g.edge; i++) { int start; int end; cin &gt;&gt; start; //输入每条边的起点 cin &gt;&gt; end; //输入每条边的终点 int weight; cin &gt;&gt; weight; ArcNode* next = new ArcNode; next-&gt;adjvex = end - 1; next-&gt;next = NULL; next-&gt;weight = weight; //如果第一个依附的边为空 if (g.node[start - 1].firstarc == NULL) { g.node[start - 1].firstarc = next; } else { ArcNode* temp; //临时表结点 temp = g.node[start - 1].firstarc; while (temp-&gt;next) {//找到表结点中start-1这个结点的链表的最后一个顶点 temp = temp-&gt;next; } temp-&gt;next = next; //在该链表的尾部插入一个结点 } //因为无向图边是双向的 ArcNode* next_2 = new ArcNode; next_2-&gt;adjvex = start - 1; next_2-&gt;weight = weight; next_2-&gt;next = NULL; //如果第一个依附的边为空 if (g.node[end - 1].firstarc == NULL) { g.node[end - 1].firstarc = next_2; } else { ArcNode* temp; //临时表结点 temp = g.node[end - 1].firstarc; while (temp-&gt;next) {//找到表结点中start-1这个结点的链表的最后一个顶点 temp = temp-&gt;next; } temp-&gt;next = next_2; //在该链表的尾部插入一个结点 } } } void print(Graph_List g) { cout &lt;&lt; &quot;图的邻接表：&quot; &lt;&lt; endl; for (int i = 0; i &lt; g.vexnum; i++) { cout &lt;&lt; g.node[i].data &lt;&lt; &quot; &quot;; ArcNode* next; next = g.node[i].firstarc; while (next) { cout &lt;&lt; &quot;(&quot; &lt;&lt; g.node[i].data &lt;&lt; &quot;,&quot; &lt;&lt; g.node[next-&gt;adjvex].data &lt;&lt; &quot;)=&quot; &lt;&lt; next-&gt;weight &lt;&lt; &quot; &quot;; next = next-&gt;next; } cout &lt;&lt; &quot;^&quot; &lt;&lt; endl; } } //作为记录边的信息，这些边都是达到end的所有边中，权重最小的那个 struct Assis_array { int start; //边的终点 int end; //边的起点 int weight; //边的权重 }; void Prim(Graph_List g, int begin) { cout &lt;&lt; &quot;图的最小生成树：&quot; &lt;&lt; endl; //close_edge这个数组记录到达某个顶点的各个边中的权重最大的那个边 Assis_array* close_edge = new Assis_array[g.vexnum]; int j; for (j = 0; j &lt; g.vexnum; j++) { close_edge[j].weight = INT_MAX; } ArcNode* arc = g.node[begin - 1].firstarc; while (arc) { close_edge[arc-&gt;adjvex].end = arc-&gt;adjvex; close_edge[arc-&gt;adjvex].start = begin - 1; close_edge[arc-&gt;adjvex].weight = arc-&gt;weight; arc = arc-&gt;next; } //把起点的close_edge中的值设置为-1，代表已经加入到集合U了 close_edge[begin - 1].weight = -1; //访问剩下的顶点，并加入依次加入到集合U for (j = 1; j &lt; g.vexnum; j++) { int min = INT_MAX; int k; int index; //寻找数组close_edge中权重最小的那个边 for (k = 0; k &lt; g.vexnum; k++) { if (close_edge[k].weight != -1) { if (close_edge[k].weight &lt; min) { min = close_edge[k].weight; index = k; } } } //输出对应的边的信息 cout &lt;&lt; g.node[close_edge[index].start].data &lt;&lt; &quot;-----&quot; &lt;&lt; g.node[close_edge[index].end].data &lt;&lt; &quot;=&quot; &lt;&lt; close_edge[index].weight &lt;&lt; endl; //将权重最小的那条边的终点也加入到集合U close_edge[index].weight = -1; //更新我们的close_edge数组. ArcNode* temp = g.node[close_edge[index].end].firstarc; while (temp) { if (close_edge[temp-&gt;adjvex].weight &gt; temp-&gt;weight) { close_edge[temp-&gt;adjvex].weight = temp-&gt;weight; close_edge[temp-&gt;adjvex].start = index; close_edge[temp-&gt;adjvex].end = temp-&gt;adjvex; } temp = temp-&gt;next; } } } 克鲁斯卡尔(Kruskal)算法基本思想： （1）将图中的所有边都去掉。（2）将边按权值从小到大的顺序添加到图中，保证添加的过程中不会形成环（3）重复上一步直到连接所有顶点，此时就生成了最小生成树。这是一种贪心策略。 算法设计T= { }; while ( T contains less than n-1 edges &amp;&amp; E is not empty) { choose a least cost edge (v,w) from E delete (v,w) from E; If ((v,w) does not create a cycle in T) add (v,w) to T else discard (v,w); } if (T contains fewer than n-1 edges) printf(&quot;No spanning tree\\n&quot;) 代码实现： 边集数组表示图 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; //检验输入边数和顶点数的值是否有效，可以自己推算为啥： //顶点数和边数的关系是：((Vexnum*(Vexnum - 1)) / 2) &lt; edge bool check(int Vexnum,int edge) { if (Vexnum &lt;= 0 || edge &lt;= 0 || ((Vexnum*(Vexnum - 1)) / 2) &lt; edge) return false; return true; } //判断我们每次输入的的边的信息是否合法 //顶点从1开始编号 bool check_edge(int Vexnum, int start ,int end, int weight) { if (start&lt;1 || end&lt;1 || start&gt;Vexnum || end&gt;Vexnum || weight &lt; 0) { return false; } return true; } //边集结构，用于保存每条边的信息 typedef struct edge_tag { bool visit; //判断这条边是否加入到了最小生成树中 int start; //该边的起点 int end; //该边的终点 int weight; //该边的权重 }Edge; //创建一个图，但是图是使用边集结构来保存 void createGraph(Edge * &amp;e,int Vexnum, int edge) { e = new Edge[edge];//为每条边集开辟空间 int start = 0; int end = 0; int weight = 0; int i = 0; cout &lt;&lt; &quot;输入每条边的起点、终点和权重：&quot; &lt;&lt; endl; while (i != edge) { cin &gt;&gt; start &gt;&gt; end &gt;&gt; weight; while (!check_edge(Vexnum, start, end, weight)) { cout &lt;&lt; &quot;输入的值不合法，请重新输入每条边的起点、终点和权重：&quot; &lt;&lt; endl; cin &gt;&gt; start &gt;&gt; end &gt;&gt; weight; } e[i].start = start; e[i].end = end; e[i].weight = weight; e[i].visit = false; //每条边都还没被初始化 ++i; } } //我们需要对边集进行排序，排序是按照每条边的权重，从小到大排序。 int cmp(const void* first, const void * second) { return ((Edge *)first)-&gt;weight - ((Edge *)second)-&gt;weight; } //好了，我们现在需要做的是通过一定的方式来判断 //如果我们把当前的边加入到生成树中是否会有环出现。 //通过我们之前学习树的知识，我们可以知道如果很多棵树就组成一个森林，而且 //如果同一颗树的两个结点在连上一条边，那么就会出现环， //所以我们就通过这个方式来判断加入了一个新的边后，是否会产生环， //开始我们让我们的图的每个顶点都是一颗独立的树，通过不断的组合，把这个森林变 //成来源于同一颗顶点的树 //如果不理解，画个图就明白了， //首先是找根节点的函数, //其中parent代表顶点所在子树的根结点 //child代表每个顶点孩子结点的个数 int find_root(int child, int * parent) { //此时已经找到了该顶点所在树的根节点了 if (parent[child] == child) { return child; } //往前递归，寻找它父亲的所在子树的根结点 parent[child] = find_root(parent[child], parent); return parent[child]; } //合并两个子树 bool union_tree(Edge e, int * parent, int * child) { //先找出改边所在子树的根节点 int root1; int root2; //记住我们顶点从1开始的，所以要减1 root1 = find_root(e.start-1, parent); root2 = find_root(e.end-1, parent); //只有两个顶点不在同一颗子树上，才可以把两棵树并未一颗树 if (root1 != root2) { //小树合并到大树中，看他们的孩子个数 if (child[root1] &gt; child[root2]) { parent[root2] = root1; //大树的孩子数量是小树的孩子数量加上 //大树的孩子数量在加上小树根节点自己 child[root1] += child[root2] + 1; } else { parent[root1] = root2; child[root2] += child[root1] + 1; } return true; } return false; } //克鲁斯卡算法的实现 void Kruskal() { int Vexnum = 0; int edge = 0; cout &lt;&lt; &quot;请输入图的顶点数和边数：&quot; &lt;&lt; endl; cin &gt;&gt; Vexnum &gt;&gt; edge; while (!check(Vexnum, edge)) { cout &lt;&lt; &quot;你输入的图的顶点数和边数不合法，请重新输入：&quot; &lt;&lt; endl; cin &gt;&gt; Vexnum &gt;&gt; edge; } //声明一个边集数组 Edge * edge_tag; //输入每条边的信息 createGraph(edge_tag, Vexnum, edge); int * parent = new int[Vexnum]; //记录每个顶点所在子树的根节点下标 int * child = new int[Vexnum]; //记录每个顶点为根节点时，其有的孩子节点的个数 int i; for (i = 0; i &lt; Vexnum; i++) { parent[i] = i; child[i] = 0; } //对边集数组进行排序，按照权重从小到达排序 qsort(edge_tag, edge, sizeof(Edge), cmp); int count_vex; //记录输出的边的条数 count_vex = i = 0; while (i != edge) { //如果两颗树可以组合在一起，说明该边是生成树的一条边 if (union_tree(edge_tag[i], parent, child)) { cout &lt;&lt; (&quot;v&quot; + std::to_string(edge_tag[i].start)) &lt;&lt; &quot;-----&quot; &lt;&lt; (&quot;v&quot; + std::to_string(edge_tag[i].end)) &lt;&lt;&quot;=&quot; &lt;&lt; edge_tag[i].weight &lt;&lt; endl; edge_tag[i].visit = true; ++count_vex; //生成树的边加1 } //这里表示所有的边都已经加入成功 if (count_vex == Vexnum - 1) { break; } ++i; } if (count_vex != Vexnum - 1) { cout &lt;&lt; &quot;此图为非连通图！无法构成最小生成树。&quot; &lt;&lt; endl; } delete [] edge_tag; delete [] parent; delete [] child; }","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-图的遍历","slug":"数据结构-图的遍历","date":"2020-11-15T12:00:01.000Z","updated":"2020-11-19T13:16:58.608Z","comments":true,"path":"posts/2b6326c7.html","link":"","permalink":"https://fallensue.cc/posts/2b6326c7.html","excerpt":"","text":"图的遍历深度优先遍历步骤 从一个给定的顶点v开始遍历 访问v的第一个邻居w，然后访问w的第一个还没有被访问过的邻居，以此类推。 如果某个结点没有没被访问过的邻居，那么就回溯到上一个访问的结点，并检查它的邻居是否被访问过 重复上边过程直到所有顶点均被访问 结果为V1,V2,V4,V8,V5,V6,V3,V7 算法的难点： 如何判断是否已经访问过某个顶点？ 如何搜索顶点的邻居？ 解决方案： 设置一个数组Visit[n],当第i个顶点已经被访问时, 设置Visit[i]=1. 根据不同的数据结构改变算法设计 代码分析：DFS需要回溯，那么使用递归。 算法： //访问标志的数组,为1表示访问过，为0表示未被访问 int visted[100]; //邻接表的深度优先遍历算法 void AdjacencyList::DFS(GraphAdjList *G, int i) { EdgeNode *p; visted[i] = 1; cout &lt;&lt; G-&gt;adjList[i].data &lt;&lt; &quot;--&quot;; p = G-&gt;adjList[i].firstedge; while (p) { if (!visted[p-&gt;adjvex]) { //递归访问 DFS(G, p-&gt;adjvex); } p = p-&gt;next; } } //邻接表的深度遍历操作 void AdjacencyList::DFSTraverse(GraphAdjList *G) { //初始化所有顶点都没有访问过 cout&lt;&lt;&quot;深度优先遍历结果为：&quot;&lt;&lt;endl; for (int i = 0; i &lt; G-&gt;numVertexes; i++) { visted[i] = 0; } for (int i = 0; i &lt; G-&gt;numVertexes; i++) { if (visted[i] == 0) { DFS(G, i); } } } 广度优先遍历步骤： 从一个顶点v开始访问 访问v的所有邻居 再访问v的第一个邻居w的所有邻居 再访问v的第二个邻居x的所有邻居 结果为V1,V2,V3,V4,V5,V6,V7,V8 BFS逐层访问结点(类似于层级遍历)，当访问每个结点的时候把它存起来，然后在遍历完这一层的结点之后可以溯回访问它相邻的节点，采用队列存储(给定层级上访问的第一个结点就是要返回的结点) 代码分析： 访问开始结点v 初始化一个队列，v入队 当队列不为空时，删除一个结点，将删除结点的所有邻居（如果没被访问），访问它们并将它们入队 重复以上直到队列为空 void BFSTraverse( Graph G ) { for ( v=1; v&lt;=G.vexnum; ++v ) visited[v] = FALSE; InitQueue(Q); for( v=1; v&lt;=G.vexnum; ++v ) if ( !visited[v] ) { visited[v]=TRUE; VISIT(v); EnQueue(Q, v); while (!EmptyQueue(Q)) { DeQueue(Q,u); for(w=FirstAdjVex(G, u); w&gt;0; w=NextAdjVex(G, u, w)) if( !visited[w] ) { visited[w]=TRUE; VISIT(w); EnQueue(Q, w); } } // end while } // end if }","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-图的存储结构","slug":"数据结构-图的存储结构","date":"2020-11-15T11:00:01.000Z","updated":"2020-11-19T13:17:24.553Z","comments":true,"path":"posts/5d8f99e.html","link":"","permalink":"https://fallensue.cc/posts/5d8f99e.html","excerpt":"","text":"图的存储结构邻接矩阵(Adjacency Matrix)定义设G=(V,E)是一个具有n个顶点的图。G的邻接矩阵是一个nxn的二维数组。A[n] [n]. 无向图的邻接矩阵一定是对称的，有向图的邻接矩阵不一定是对称的。 构造一个具有n个顶点与e条边的无向网G的时间复杂度为O(n^2+e*n)，初始化邻接矩阵化了O(n^2)的时间 代码实现邻接矩阵数据类型定义 #define MaxVertices 100 //定义最大容量 typedef struct{ //包含权的邻接矩阵的的定义 int Vertices[MaxVertices]; //顶点信息的数组 int Edge[MaxVertices][MaxVertices]; //边信息的数组 int numV; //顶点数 int numE; //边数 }AdjMatrix; 创建无向图的邻接矩阵 void CreateGraph(AdjMatrix *G) //图的生成函数 { int n,e,vi,vj,w,i,j; printf(&quot;请输入图的顶点数和边数（以空格分隔）：&quot;); scanf(&quot;%d%d&quot;,&amp;n,&amp;e); G-&gt;numV=n;G-&gt;numE=e; for(i=0;i&lt;n;i++) //图的初始化 for(j=0;j&lt;n;j++) { if(i==j) G-&gt;Edge[i][j]=0; else G-&gt;Edge[i][j]=32767; } for(i=0;i&lt;G-&gt;numV;i++) //将顶点存入数组中 { printf(&quot;请输入第%d个顶点的信息:&quot;,i+1); scanf(&quot;%d&quot;,&amp;G-&gt;Vertices[i]); } printf(&quot;\\n&quot;); for(i=0;i&lt;G-&gt;numE;i++) { printf(&quot;请输入边的信息i,j,w(以空格分隔):&quot;); scanf(&quot;%d%d%d&quot;,&amp;vi,&amp;vj,&amp;w); //若为不带权值的图，则w输入1 //若为带权值的图，则w输入对应权值 G-&gt;Edge[vi-1][vj-1]=w;//① G-&gt;Edge[vj-1][vi-1]=w;//② //无向图具有对称性的规律，通过①②实现 //有向图不具备此性质，所以只需要① } } 邻接表(Adjacency List)定义对于图来说，邻接矩阵是不错的一种图存储结构，但是我们也发现，对于边数相对顶点较少的图，这种结构是存在对存储空间的极大浪费的。因此我们考虑另外一种存储结构方式：邻接表（Adjacency List），即数组与链表相结合的存储方法。 每个结点由三个域组成，邻接点域(Adjvex)指示与顶点vi邻接的点在图中的位置，链域(nextarc)指示下一条边或弧的结点；数据域(info)存储和边或弧相关的信息，如权值等。 每个链表有一个表头结点，在表头结点中除了设有链域(firstarc)指向链表中第一个结点之外，还设有存储顶点vi的名或其他相关信息的数据域(data) 如图所示 代码实现#include&lt;iostream&gt; using namespace std; #define MAXVEX 100 /* 最大顶点数,应由用户定义 */ typedef char VertexType; /* 顶点类型应由用户定义 */ typedef int EdgeType; /* 边上的权值类型应由用户定义 */ typedef struct EdgeNode /* 边表结点 */ { int adjvex; /* 邻接点域,存储该顶点对应的下标 */ EdgeType weight; /* 用于存储权值,对于非网图可以不需要 */ struct EdgeNode *next; /* 链域,指向下一个邻接点 */ } EdgeNode; typedef struct VextexNode /* 顶点表结点 */ { VertexType data; /* 顶点域,存储顶点信息 */ EdgeNode *firstedge; /* 边表头指针 */ } VextexNode, AdjList[MAXVEX]; typedef struct { AdjList adjList; int numNodes, numEdges; /* 图中当前顶点数和边数 */ } GraphAdjList; void CreateALGraph(GraphAdjList *Gp) { int i, j, k; EdgeNode *pe; cout &lt;&lt; &quot;输入顶点数和边数(空格分隔）:&quot; &lt;&lt; endl; cin &gt;&gt; Gp-&gt;numNodes &gt;&gt; Gp-&gt;numEdges; for (i = 0 ; i &lt; Gp-&gt;numNodes; i++) { cout &lt;&lt; &quot;输入顶点信息：&quot; &lt;&lt; endl; cin &gt;&gt; Gp-&gt;adjList[i].data; Gp-&gt;adjList[i].firstedge = NULL; /* 将边表置为空表 */ } for (k = 0; k &lt; Gp-&gt;numEdges; k++) /* 建立边表 */ { cout &lt;&lt; &quot;输入边(vi,vj)的顶点序号i,j（空格分隔）:&quot; &lt;&lt; endl; cin &gt;&gt; i &gt;&gt; j; pe = (EdgeNode *)malloc( sizeof(EdgeNode)); pe-&gt;adjvex = j; /* 邻接序号为j */ /* 将pe的指针指向当前顶点上指向的结点 */ pe-&gt;next = Gp-&gt;adjList[i].firstedge; Gp-&gt;adjList[i].firstedge = pe; /* 将当前顶点的指针指向pe */ pe = (EdgeNode *)malloc( sizeof(EdgeNode)); pe-&gt;adjvex = i; pe-&gt;next = Gp-&gt;adjList[j].firstedge; Gp-&gt;adjList[j].firstedge = pe; } } int main( void) { GraphAdjList GL; CreateALGraph(&amp;GL); return 0; } 在建立邻接表以及逆邻接表时，若输入的顶点信息为顶点的编号，则建立邻接表的时间复杂度为O(n+e)，否则，需要通过查找才能得到顶点在图中位置，则时间复杂度为O(n*e)","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"数据结构-图的基本定义","slug":"数据结构-图基本定义","date":"2020-11-14T13:30:01.000Z","updated":"2020-11-19T13:18:00.953Z","comments":true,"path":"posts/790212ce.html","link":"","permalink":"https://fallensue.cc/posts/790212ce.html","excerpt":"","text":"图的基本定义基本术语图（graph）图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中的顶点的集合，E是图G中边的集合。 顶点(Vertex)图中的数据元素。线性表中我们把数据元素叫元素，树中将数据元素叫结点。 边顶点之间的逻辑关系用边来表示，边集可以是空的。 无向边(Edge)若两个顶点之间的边没有方向，则称这条边为无向边。用(V1,V2)表示。(V1,V2) ≠ (V2,V1) 有向边(弧)(Arc)若两个顶点之间的边有方向，则称这条边为有向边。用&lt;V1,V2&gt;表示，V1为弧尾(Tail)(或终端点)，V2为弧头(Head)(或初始点)。&lt;V1,V2&gt; ≠ &lt;V2,V1&gt; 无向图(Undirected graphs)图中任意两个顶点之间的边都是无向边。 有向图(Directed graphs) 图中任意两个顶点之间的边都是有向边。 完全图(Completed graph) 有(1/2)*n(n-1)条边的无向图称为无向完全图，有n(n-1)条弧的有向图称为有向完全图。 稀疏图(Sparse graph)有很少条边或弧(如e&lt;nlogn)的图。 稠密图(Dense graph):不是稀疏图的图。 权（Weight）与图的边或弧相关的数。 网（Network）带权的图。 子图（Subgraph）假设G=（V,{E}）和G‘=（V’,{E’}），如果V’包含于V且E’包含于E，则称G’为G的子图。 邻接点(Adjacent)如果边(v,w)属于E，则称顶点v与w互为邻接点,v与w相邻接。边(v,w)依附于顶点v与w，或者说(v,w)和顶点v和w相关联。 度(Degree)是与v相关联的边的数目，记为TD(V).有向图中，入度表示指向自己的边的数目，出度表示指向其他边的数目，该顶点的度等于入度与出度的和. 路径(Path)从一个点到另一个的顶点序列，第一个顶点与最后一个顶点相同的路径称为回路或环(Cycle)。序列中顶点不重复的路径称为简单路径。 连通图(Connected graph)图中任意两个顶点都是连通的(从一个顶点到另一个顶点有路径)。 连通分量(Connected Component)无向图中的极大连通子图。 强连通图有向图中任意两个顶点之间都有路径。 生成树极小连通子图，含有图中全部顶点，但只有足以构成一棵树的n-1条边。","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://fallensue.cc/tags/DataStructure/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"OS内存管理","slug":"OS内存管理","date":"2020-11-10T13:55:01.000Z","updated":"2020-11-19T13:15:51.144Z","comments":true,"path":"posts/48e0383b.html","link":"","permalink":"https://fallensue.cc/posts/48e0383b.html","excerpt":"","text":"内存管理为什么需要内存管理？原因： 内存越来越不值钱 需要高效的利用CPU的能力 背景CPU根据程序计数器的值从内存中提取指令，这些指令可能引起对特定内存地址的额外加载以及存储。 一个典型的指令执行周期， 首先从内存中读取指令。接着， 该指令会被解码， 也可能需要从内存中读取操作数。内存单元只看到地址流，而不知道这些地址从何产生。 基本硬件CPU可以直接访问的通用存储只有内存和处理器内置的寄存器。因此，执行指令以及指令使用的数据，应该处在这些可以直接访问的存础设备上。如果数据不在内存中， 那么在CPU 使用它们之前应先把数据移到内存。 CPU 内置寄存器通常可以在一个CPU 时钟周期内完成访问。完成内存的访问可能需要多个CPU 时钟周期。在这种情况下， 由于没有数据以便完成正在执行的指令， CPU 通常需要暂停(stall)。由于内存访问的频繁，这种情况是我们不想见到的。补救措施是在CPU 与内存之间， 通常是在CPU 芯片上， 增加更快的内存；这称为高速缓存(cache)。 为了确保操作的正确，首先，我们需要确保每个进程都有一个单独的内存空间。单独的进程内存空间可以保护进程而不互相影响，这对于将多个进程加到内存以便并发执行来说至关重要，通过两个寄存器，通常为基地址和界限地址，如图8所示，我们可以提供这种保护。基地址寄存器含有最小的合法的物理内存地址，而界限地址寄存器指定了范围的大小。 内存空间的保护是通过CPU对在用户模式下产生的地址与寄存器的地址进行比较而得成的。只有操作系统可以通过特殊的特权指令，才能加载基地址寄存器和界限地址寄存器。这个方案允许操作系统修改这两个寄存器的值，而不允许用户程序修改它们。 在内核模式下执行的操作系统可以无限制地访问操作系统及用户的内存。 地址绑定源程序中的地址通常是用符号表示，编译器会将这些符号地址绑定到可重定位的地址。链接程序或加载程序再将这些可重定位的地址绑定到绝对地址（如74014)。每次绑定都是从一个地址空间到另一个地址空间的映射。 通常，指令和数据绑定到存储器地址可在沿途的任何一步中进行： 编译时：如果在编译时就已知道进程将在内存中的驻留地址，那么就可以生成绝对代码。 加载时：如果在编译时并不知道进程将驻留在何处，那么编译器就应生成可重定位代码。 执行时：如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定应延迟到执行时才进行。 逻辑地址空间与物理地址空间CPU生成的地址叫做逻辑地址，内存单元看到的地址（即加载到内存地址寄存器的地址）通常称为物理地址。 编译时和加载时的地址绑定方法生成相同的逻辑地址和物理地址。然而， 执行时的地址绑定方案生成不同的逻辑地址和物理地址。在这种情况下， 我们通常称逻辑地址为虚拟地址。 从虚拟地址到物理地址的运行时映射是由内存管理单元（MMU）来完成。 动态加载为了获得更好的内存空间利用率，可以使用动态加载。采用动态加载时，一个程序只有在调用时才会加载。当一个程序需要调用另一个程序时，调用程序首先检查另一个程序是否加载。如果没有，则将其加载到内存中。 优点：只有一个程序被需要时才会加载，不需要操作系统提供特别支持。 交换进程必须在内存中以便执行。不过，进程可以暂时从内存交换到备份存储器，当再次执行时再调回内存中。 标准交换标准交换在内存与备份存储之间移动进程。备份存储通常是快速硬盘。系统维护一个可运行的所有进程的就绪队列，它们的映像在备份存储或者是内存中。 这种交换的上下文切换时间相当高。主要耗时是传输时间，为有效使用这种方法， 用户需要告诉系统它的内存需求情况。因此， 具有动态内存需求的进程需要通过系统调用来通知操作系统内存使用情况。 想换出一个进程必须保证它是空闲的。 现代操作系统现在并不使用标准交换。它的交换时间太多， 它提供的执行时间太少， 不是合理的内存管理的解决方案。 连续内存分配内存通常分为两个区域：一个用于驻留操作系统，另一个用于用户进程。 通常， 我们需要将多个进程同时放在内存中。因此我们需要考虑， 如何为输入队列中需要调入内存的进程分配内存空间。在采用连续内存分配时，每个进程位于一个连续的内存区域， 与包含下一个进程的内存相连。 内存保护防止进程访问不属于它的内存，可以采用重定位寄存器以及界限寄存器。每个逻辑地址应在界限寄存器规定的范围内。MMU通过动态地将逻辑地址加上重定位寄存器的值， 来进行映射。映射后的地址再发送到内存。 内存分配最简单：将内存分为多个固定大小的分区，每个分区可以只包含一个进程。（多分区方法）当一个分区空闲时，可以从输入队列中选择一个进程，来调入空闲分区。当该进程终止时，它的分区可以用于其他进程。 对于可变分区方案，操作系统有一个表，用于记录哪些内存可用和哪些内存已用。一大块的可用内存被称为孔 从一组可用孔中选择一个空闲孔的最常用方法包括：首次适应、最优适应、最差适应 首次适应：分配首个足够大的孔。 最优适应：分配最小的足够大的空。 最差适应：分配最大的孔。 碎片用于内存分配的首次适应和最优适应算法都有外部碎片的问题。 外部碎片问题：随着进程加载到内存和从内存退出， 空闲内存空间被分为小的片段。当总的可用内存之和可以满足请求但并不连续时， 这就出现了外部碎片问题：存储被分成了大量的小孔。这个问题可能很严重。最坏情况下，每两个进程之间就有空闲（或浪费的）块。 内部碎片：因此， 通常按固定大小的块为单位（而不是字节）来分配内存。采用这种方案， 进程所分配的内存可能比所需的要大。这两个数字之差称为内部碎片，这部分内存在分区内部，但又不能用。 外部碎片问题解决方法：紧缩，目的是移动内存内容以便将所有空闲空间合并成一整块。 外部碎片化问题的另一个可能的解决方案是：允许进程的逻辑地址空间是不连续的。 分段定义将内存看作一组不同长度的段，这些段之间并没有一定的顺序。逻辑地址空间是由一组段构成。每个段都有名称以及长度。地址指定了段名称以及段内偏移。用户通过两个量来指定地址：段名称和段偏移。 为了实现简单，段是编号的，是通过段号而不是段名称来引用。 逻辑地址由一个有序对&lt;段号，偏移&gt;组成。 允许进程的物理地址空间非连续。 分段硬件段表：将用户定义的二维地址映射到一维物理地址。 段表的每个条目都有段基地址和段界限，段基地址包含该段在内存中的开始物理地址，而段界限指定该段的长度。 每个逻辑地址由两部分组成：段号s和段偏移d，段号是段表的索引，逻辑地址偏移应该在0和段界限之间。如果不合法就由操作系统处理，如果合法，那么就与基地址相加而得到所需字节的物理内存地址。因此，段表实际上是基址寄存器值和界限寄存器值的数组。 每个段都在段表中有一个条目， 它包括段在物理内存内的开始地址（基地址）和该段的长度（界限）。 分页优势：避免了外部碎片以及紧缩，分段不可以。避免了将不同大小的内存块匹配到交换空间的麻烦问题。 基本方法将物理内存分为固定大小的块，称为帧或页帧；将逻辑内存也分为同样大小的块，称为页或页面。 逻辑地址空间要求的内存可以远远的大于实际的物理内存。 硬件支持由CPU生成的每个地址分为两个部分：页码(p)和页偏移(d)。页码作为页表的索引。页表包含每页所在物理内存单元的基地址。这个基地址与页偏移的组合就形成了物理内存地址，可发送到物理单元。如下图所示。 页大小（同帧大小一样）是由硬件来决定的。将页的大小选为2的幂可以方便地将逻辑地址转换为页码与页偏移。如果逻辑地址空间为2^m,且页的大小为2^n字节，那么逻辑地址的高m-n位表示页码，低n位表示页偏移。逻辑地址如下图所示 其中p作为页表的索引，而d作为页的偏移。 分页本身是一种动态的重定位。每个逻辑地址由分页硬件绑定位某个物理地址。采用分页类似于采用一组基址(重定位)寄存器，每个基址对应着一个内存帧。 分页不会产生外部碎片：每个空闲帧都可以分配给需要它的进程。 不过分页会有内部碎片，因为分配是以桢为单位来进行的，如果进程要求的内存并不是也的整数倍，那么最后一个帧可能会用不完。如果进程大小与页大小无关，那么每个进程的内部碎片的均值为半页。 分页内存系统的物理内存大小不同于进程的最大逻辑大小。分页允许我们使用的物理内存大于CPU地址指针可访问的空间。 分页的一个重要方面是，程序员视图的内存和实际的物理内存的清楚分离。帧同样有帧表用于保存。分页增加了上下文切换的时间。 页表结构分层分页两层分页算法：将页表再分页。 例如，再次假设一个系统，具有32位逻辑地址空间和4K大小的页。一个逻辑地址被分为20位的页码和12位的页偏移。因为要对页表进行再分页，所以此页码可分为10位的页码以及10位的页偏移。如下图所示。 其中p1是用来访问外部页表的索引， 而p2是内部页表的页偏移。采用这种结构的地址转换方法如图所示，这种方案称作向前映射页表。 但是如果外部页表实在太大，要分层分页就会很多，对于64位的架构，这个通常是不恰当的。 哈希页表通常用于处理大于32位地址空间，采用虚拟页码作为哈希值。 哈希页表的每一个条目都包括一个链表， 该链表的元素哈希到同一位置（该链表用来解决处理碰撞）。每个元素由三个字段组成： 1） 虚拟页码， 2 ) 映射的帧码， 3） 指向链表内下一个元素的指针。 该算法工作如下：虚拟地址的虚拟页码哈希到哈希表。用虚拟页码与链表内的第一个元素的第一个字段相比较。如果匹配， 那么相应的帧码（第二个字段）就用来形成物理地址；如果不匹配， 那么与链表内的后续节点的第一个字段进行比较， 以查找匹配的页码。如图所示。 倒置页表对千每个真正的内存页或帧， 倒置页表才有一个条目。每个条目包含保存在真正内存位置上的页的虚拟地址，以及拥有该页进程的信息。因此， 整个系统只有一个页表， 并且每个物理内存的页只有一条相应的条目。工作原理如图所示。","categories":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://fallensue.cc/tags/OS/"}],"keywords":[{"name":"学习","slug":"学习","permalink":"https://fallensue.cc/categories/学习/"}]},{"title":"Hello Hexo","slug":"Hello Hexo","date":"2020-11-06T14:16:01.000Z","updated":"2020-11-19T13:15:51.144Z","comments":true,"path":"posts/a1751c09.html","link":"","permalink":"https://fallensue.cc/posts/a1751c09.html","excerpt":"","text":"序言过了这么久终于能够有一个自己的博客了，以后有什么想法就会往上面发。","categories":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://fallensue.cc/tags/Hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2020-11-18T14:22:43.472Z","comments":true,"path":"posts/186f70d4.html","link":"","permalink":"https://fallensue.cc/posts/186f70d4.html","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://fallensue.cc/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://fallensue.cc/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fallensue.cc/categories/技术/"}]}]}